Assume you are an experienced tester. I am going to give you python functions and you are going to give me the inputs to test this function. The inputs are provided in the form of actions. You have to provide two tests for each function with the most number of parameters as possible (if applicable). However, you have to follow the format that I provide to you below.

# Format:
{
    "env": "incident_management_redos",
    "interface_num": 3,
    "task": {
        "actions": [
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            },
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            }
        ]
    }
}

where the name of action is the function name and the arguments are the parameters of the function. You have to provide multiple actions for a single file in a single test if applicable. 

# Functions:
import json
from typing import Any, Dict, List
from datetime import datetime, timedelta
from tau_bench.envs.tool import Tool

class GetSlaBreachIncidents(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], client_id: str = None, start_date: str = None, end_date: str = None, status: str = None) -> str:
        """
        Retrieves incidents that have breached their Service Level Agreements (SLAs).
        Only incidents with 'resolved_at' or 'closed_at' timestamps are considered for resolution SLA breaches.
        """
        # Define SLA_MATRIX inside the function
        SLA_MATRIX = {
            'premium': {
                'P1': {'response': (15, 30), 'resolution': (120, 240)},
                'P2': {'response': (60, 120), 'resolution': (480, 1440)},
                'P3': {'response': (240, 480), 'resolution': (2880, 4320)},
                'P4': {'response': (1440, 2880), 'resolution': (7680, 7680)}
            },
            'standard': {
                'P1': {'response': (60, 120), 'resolution': (480, 1440)},
                'P2': {'response': (240, 480), 'resolution': (1440, 2880)},
                'P3': {'response': (1440, 1440), 'resolution': (4320, 7200)},
                'P4': {'response': (2880, 4320), 'resolution': (10080, 10080)}
            },
            'basic': {
                'P1': {'response': (240, 480), 'resolution': (1440, 2880)},
                'P2': {'response': (1440, 1440), 'resolution': (4320, 7200)},
                'P3': {'response': (2880, 4320), 'resolution': (7200, 14400)},
                'P4': {'response': (7200, 10080), 'resolution': (20160, 20160)}
            }
        }
        
        incidents_data = data.get("incidents", {})
        sla_agreements_data = data.get("sla_agreements", {})
        incident_ci_data = data.get("incident_configuration_items", {})
        ci_client_assignments_data = data.get("ci_client_assignments", {})
        
        breach_incidents = []
        
        # Detailed debugging - let's see what we're actually working with
        debug_info = {
            "data_structure": {
                "incidents_count": len(incidents_data),
                "sla_agreements_count": len(sla_agreements_data),
                "incident_ci_relationships_count": len(incident_ci_data),
                "ci_client_assignments_count": len(ci_client_assignments_data),
                "available_tables": list(data.keys())
            },
            "sample_data": {},
            "processing_steps": []
        }
        
        # Sample actual data
        if incidents_data:
            sample_incident_id = list(incidents_data.keys())[0]
            debug_info["sample_data"]["incident"] = {
                "id": sample_incident_id,
                "data": incidents_data[sample_incident_id]
            }
        
        if sla_agreements_data:
            sample_sla_id = list(sla_agreements_data.keys())[0]
            debug_info["sample_data"]["sla"] = {
                "id": sample_sla_id,
                "data": sla_agreements_data[sample_sla_id]
            }
        
        if incident_ci_data:
            sample_ici_id = list(incident_ci_data.keys())[0]
            debug_info["sample_data"]["incident_ci"] = {
                "id": sample_ici_id,
                "data": incident_ci_data[sample_ici_id]
            }
        
        if ci_client_assignments_data:
            sample_cca_id = list(ci_client_assignments_data.keys())[0]
            debug_info["sample_data"]["ci_client_assignment"] = {
                "id": sample_cca_id,
                "data": ci_client_assignments_data[sample_cca_id]
            }
        
        # Parse date filters
        filter_start_dt = datetime.strptime(start_date, '%Y-%m-%d') if start_date else None
        filter_end_dt = datetime.strptime(end_date, '%Y-%m-%d') if end_date else None
        
        debug_info["processing_steps"].append(f"Date filters: start={start_date}, end={end_date}")
        
        # Helper function to find client_id for an incident through CI relationships
        def get_incident_client_id(incident_id: str) -> str:
            debug_info["processing_steps"].append(f"Looking for client for incident {incident_id}")
            
            # Find CIs affected by this incident
            affected_ci_ids = []
            for relationship_id, relationship in incident_ci_data.items():
                if relationship.get("incident_id") == incident_id:
                    affected_ci_ids.append(relationship.get("ci_id"))
                    debug_info["processing_steps"].append(f"Found CI {relationship.get('ci_id')} for incident {incident_id}")
            
            debug_info["processing_steps"].append(f"Affected CIs for incident {incident_id}: {affected_ci_ids}")
            
            # Find client assignments for these CIs
            client_assignments = []
            for assignment_id, assignment in ci_client_assignments_data.items():
                if assignment.get("ci_id") in affected_ci_ids:
                    client_assignments.append(assignment)
                    debug_info["processing_steps"].append(f"Found client assignment: CI {assignment.get('ci_id')} -> Client {assignment.get('client_id')} ({assignment.get('assignment_type')})")
            
            # Return primary assignment if available
            for assignment in client_assignments:
                if assignment.get("assignment_type") == "primary":
                    debug_info["processing_steps"].append(f"Returning primary client {assignment.get('client_id')} for incident {incident_id}")
                    return assignment.get("client_id")
            
            # Otherwise return any assignment
            if client_assignments:
                client_id = client_assignments[0].get("client_id")
                debug_info["processing_steps"].append(f"Returning first available client {client_id} for incident {incident_id}")
                return client_id
            
            debug_info["processing_steps"].append(f"No client found for incident {incident_id}")
            return None
        
        incidents_checked = 0
        incidents_with_resolution = 0
        incidents_with_client = 0
        incidents_with_sla = 0
        
        for incident_id, incident in incidents_data.items():
            incidents_checked += 1
            
            # Only consider incidents that have been resolved or closed
            if not incident.get("resolved_at") and not incident.get("closed_at"):
                debug_info["processing_steps"].append(f"Incident {incident_id}: No resolution timestamp")
                continue
            
            incidents_with_resolution += 1
            debug_info["processing_steps"].append(f"Incident {incident_id}: Has resolution timestamp")
            
            # Apply status filter
            if status and incident.get("status") != status:
                debug_info["processing_steps"].append(f"Incident {incident_id}: Status filter mismatch ({incident.get('status')} != {status})")
                continue
            
            # Apply time range filter based on detection_time
            detection_time_str = incident.get("detection_time")
            if not detection_time_str:
                debug_info["processing_steps"].append(f"Incident {incident_id}: No detection_time")
                continue
            
            try:
                # Handle various datetime formats
                if detection_time_str.endswith('Z'):
                    detection_time_str = detection_time_str[:-1] + '+00:00'
                incident_detection_dt = datetime.fromisoformat(detection_time_str)
                
                if filter_start_dt and incident_detection_dt < filter_start_dt:
                    debug_info["processing_steps"].append(f"Incident {incident_id}: Before start date")
                    continue
                if filter_end_dt and incident_detection_dt > filter_end_dt:
                    debug_info["processing_steps"].append(f"Incident {incident_id}: After end date")
                    continue
            except ValueError as e:
                debug_info["processing_steps"].append(f"Incident {incident_id}: Invalid detection_time format: {e}")
                continue
            
            # Get client_id through CI relationships
            incident_client_id = get_incident_client_id(incident_id)
            if not incident_client_id:
                debug_info["processing_steps"].append(f"Incident {incident_id}: No client relationship found")
                continue
            
            incidents_with_client += 1
            
            # Apply client_id filter
            if client_id and incident_client_id != client_id:
                debug_info["processing_steps"].append(f"Incident {incident_id}: Client filter mismatch ({incident_client_id} != {client_id})")
                continue
            
            incident_severity = incident.get("severity")
            if not incident_severity:
                debug_info["processing_steps"].append(f"Incident {incident_id}: No severity")
                continue
            
            # Find the SLA agreement for the incident's client
            client_sla = None
            for sla_id, sla_agreement in sla_agreements_data.items():
                if sla_agreement.get("client_id") == incident_client_id and sla_agreement.get("status") == "active":
                    client_sla = sla_agreement
                    debug_info["processing_steps"].append(f"Incident {incident_id}: Found active SLA {sla_id} for client {incident_client_id}")
                    break
            
            if not client_sla:
                debug_info["processing_steps"].append(f"Incident {incident_id}: No active SLA for client {incident_client_id}")
                continue
            
            incidents_with_sla += 1
            
            client_tier = client_sla.get("tier")
            if not client_tier or client_tier not in SLA_MATRIX:
                debug_info["processing_steps"].append(f"Incident {incident_id}: Invalid tier {client_tier}")
                continue
            
            sla_config = SLA_MATRIX[client_tier].get(incident_severity)
            if not sla_config:
                debug_info["processing_steps"].append(f"Incident {incident_id}: No SLA config for {client_tier}/{incident_severity}")
                continue
            
            # Use the maximum resolution time from the range as the target
            expected_resolution_minutes = sla_config['resolution'][1]
            
            # Calculate actual resolution duration
            resolved_at_str = incident.get("resolved_at") or incident.get("closed_at")
            try:
                if resolved_at_str.endswith('Z'):
                    resolved_at_str = resolved_at_str[:-1] + '+00:00'
                incident_resolved_dt = datetime.fromisoformat(resolved_at_str)
                
                actual_resolution_duration_minutes = (incident_resolved_dt - incident_detection_dt).total_seconds() / 60
                
                debug_info["processing_steps"].append(f"Incident {incident_id}: Duration {actual_resolution_duration_minutes:.2f} min vs SLA {expected_resolution_minutes} min")
                
                # Check for SLA breach
                if actual_resolution_duration_minutes > expected_resolution_minutes:
                    incident_copy = incident.copy()
                    incident_copy["client_id"] = incident_client_id
                    incident_copy["sla_tier"] = client_tier
                    incident_copy["expected_resolution_minutes"] = expected_resolution_minutes
                    incident_copy["actual_resolution_minutes"] = round(actual_resolution_duration_minutes, 2)
                    incident_copy["breach_by_minutes"] = round(actual_resolution_duration_minutes - expected_resolution_minutes, 2)
                    breach_incidents.append(incident_copy)
                    debug_info["processing_steps"].append(f"Incident {incident_id}: BREACH DETECTED!")
                else:
                    debug_info["processing_steps"].append(f"Incident {incident_id}: No breach")
                    
            except ValueError as e:
                debug_info["processing_steps"].append(f"Incident {incident_id}: Invalid resolved_at format: {e}")
                continue
        
        debug_info["summary"] = {
            "incidents_checked": incidents_checked,
            "incidents_with_resolution": incidents_with_resolution,
            "incidents_with_client": incidents_with_client,
            "incidents_with_sla": incidents_with_sla,
            "breaches_found": len(breach_incidents)
        }
        
        return json.dumps({
            "success": True,
            "count": len(breach_incidents),
            "breach_incidents": breach_incidents,
            "debug": debug_info
        }, indent=2)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_sla_breach_incidents",
                "description": "Retrieves incidents that have breached their Service Level Agreements (SLAs). Includes detailed debugging information.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "client_id": {
                            "type": "string",
                            "description": "Optional: Filter incidents by a specific client ID."
                        },
                        "start_date": {
                            "type": "string",
                            "description": "Optional: Start date for the time range (YYYY-MM-DD)."
                        },
                        "end_date": {
                            "type": "string",
                            "description": "Optional: End date for the time range (YYYY-MM-DD)."
                        },
                        "status": {
                            "type": "string",
                            "description": "Optional: Filter incidents by status."
                        }
                    },
                    "required": []
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageContracts(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        entity_data: Optional[Dict[str, Any]] = None,
        entity_id: Optional[str] = None
    ) -> str:
        """
        Create or update SLA agreement records.
        
        Actions:
        - create: Create new SLA agreement record (requires entity_data)
        - update: Update existing SLA agreement record (requires entity_id and entity_data)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        timestamp = "2025-10-01T00:00:00"
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })
        
        sla_agreements = data.get("sla_agreements", {})
        clients = data.get("clients", {})
        users = data.get("users", {})
        
        if action == "create":
            if not entity_data:
                return json.dumps({
                    "success": False,
                    "error": "entity_data is required for create action"
                })
            
            # Validate required fields (based on DB schema)
            required_fields = ["client_id", "tier", "support_coverage", "effective_date", "created_by"]
            missing_fields = [field for field in required_fields if field not in entity_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not entity_data[field] or str(entity_data[field]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
            
            # Validate allowed fields
            allowed_fields = ["client_id", "tier", "support_coverage", "effective_date", "expiration_date", "created_by", "status"]
            invalid_fields = [field for field in entity_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields: {', '.join(invalid_fields)}"
                })
            
            # Validate tier enum
            valid_tiers = ["premium", "standard", "basic"]
            if entity_data["tier"] not in valid_tiers:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid tier '{entity_data['tier']}'. Must be one of: {', '.join(valid_tiers)}"
                })
            
            # Validate support_coverage enum
            valid_support_coverage = ["24x7", "business_hours", "on_call"]
            if entity_data["support_coverage"] not in valid_support_coverage:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid support_coverage '{entity_data['support_coverage']}'. Must be one of: {', '.join(valid_support_coverage)}"
                })
            
            # Validate status enum if provided
            if "status" in entity_data:
                valid_status = ["active", "inactive", "expired"]
                if entity_data["status"] not in valid_status:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status '{entity_data['status']}'. Must be one of: {', '.join(valid_status)}"
                    })
            
            # Validate optional fields are not empty if provided
            optional_fields = ["expiration_date"]
            for field in optional_fields:
                if field in entity_data and entity_data[field] is not None:
                    if str(entity_data[field]).strip() == "":
                        return json.dumps({
                            "success": False,
                            "error": f"Field '{field}' cannot be empty if provided"
                        })
            
            # Validate client_id exists
            if str(entity_data["client_id"]) not in clients:
                return json.dumps({
                    "success": False,
                    "error": "Client not found"
                })
            
            # Validate created_by exists
            if str(entity_data["created_by"]) not in users:
                return json.dumps({
                    "success": False,
                    "error": "User not found"
                })
            
            # Create new SLA agreement
            new_id = str(generate_id(sla_agreements))
            new_sla = {
                "sla_id": new_id,
                "client_id": str(entity_data["client_id"]),
                "tier": entity_data["tier"],
                "support_coverage": entity_data["support_coverage"],
                "effective_date": entity_data["effective_date"],
                "expiration_date": entity_data.get("expiration_date"),
                "created_by": str(entity_data["created_by"]),
                "created_at": timestamp,
                "updated_at": timestamp,
                "status": entity_data.get("status", "active")
            }
            sla_agreements[new_id] = new_sla
            
            return json.dumps({
                "success": True,
                "action": "create",
                "sla_id": new_id,
                "sla_data": new_sla
            })
        
        elif action == "update":
            if not entity_id:
                return json.dumps({
                    "success": False,
                    "error": "entity_id is required for update action"
                })
            
            if entity_id not in sla_agreements:
                return json.dumps({
                    "success": False,
                    "error": f"SLA agreement {entity_id} not found"
                })
            
            # Check if SLA is inactive or expired
            current_sla = sla_agreements[entity_id]
            if current_sla.get("status") in ["inactive", "expired"]:
                return json.dumps({
                    "success": False,
                    "error": f"Cannot update SLA agreement {entity_id} with status '{current_sla.get('status')}'. Please reactivate the SLA first."
                })
            
            if not entity_data:
                return json.dumps({
                    "success": False,
                    "error": "entity_data is required for update action"
                })
            
            # Validate allowed fields
            allowed_fields = ["client_id", "tier", "support_coverage", "effective_date", "expiration_date", "created_by", "status"]
            invalid_fields = [field for field in entity_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields
            for field, value in entity_data.items():
                if field != "expiration_date" and value is not None and str(value).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
                elif field == "expiration_date" and value is not None and str(value).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty if provided"
                    })
            
            # Validate tier enum if provided
            if "tier" in entity_data:
                valid_tiers = ["premium", "standard", "basic"]
                if entity_data["tier"] not in valid_tiers:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid tier. Must be one of: {', '.join(valid_tiers)}"
                    })
            
            # Validate support_coverage enum if provided
            if "support_coverage" in entity_data:
                valid_support_coverage = ["24x7", "business_hours", "on_call"]
                if entity_data["support_coverage"] not in valid_support_coverage:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid support_coverage. Must be one of: {', '.join(valid_support_coverage)}"
                    })
            
            # Validate status enum if provided
            if "status" in entity_data:
                valid_status = ["active", "inactive", "expired"]
                if entity_data["status"] not in valid_status:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status. Must be one of: {', '.join(valid_status)}"
                    })
            
            # Validate client_id if being updated
            if "client_id" in entity_data:
                if str(entity_data["client_id"]) not in clients:
                    return json.dumps({
                        "success": False,
                        "error": "Client not found"
                    })
            
            # Validate created_by if being updated
            if "created_by" in entity_data:
                if str(entity_data["created_by"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "User not found"
                    })
            
            # Update SLA agreement
            updated_sla = sla_agreements[entity_id].copy()
            for key, value in entity_data.items():
                if key in ["client_id", "created_by"]:
                    updated_sla[key] = str(value)
                else:
                    updated_sla[key] = value
            updated_sla["updated_at"] = timestamp
            sla_agreements[entity_id] = updated_sla
            
            return json.dumps({
                "success": True,
                "action": "update",
                "sla_id": entity_id,
                "sla_data": updated_sla
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_contracts",
                "description": "Create or update SLA agreement records in the incident management system. For creation, establishes new SLA agreement records with comprehensive validation. For updates, modifies existing records while maintaining data integrity. Validates SLA tiers, support coverage, and status values according to system requirements.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new record, 'update' to modify existing record"
                        },
                        "entity_data": {
                            "type": "object",
                            "description": "SLA agreement data object containing fields for creating or updating SLA agreements",
                            "properties": {
                                "client_id": {
                                    "type": "string",
                                    "description": "Client identifier (required for create, cannot be empty, must exist in system)"
                                },
                                "tier": {
                                    "type": "string",
                                    "description": "SLA tier level (required for create). Must be one of: premium, standard, basic"
                                },
                                "support_coverage": {
                                    "type": "string",
                                    "description": "Support coverage level (required for create). Must be one of: 24x7, business_hours, on_call"
                                },
                                "effective_date": {
                                    "type": "string",
                                    "description": "Date when SLA becomes effective (required for create, cannot be empty)"
                                },
                                "expiration_date": {
                                    "type": "string",
                                    "description": "Date when SLA expires (optional, cannot be empty if provided)"
                                },
                                "created_by": {
                                    "type": "string",
                                    "description": "User identifier who created the SLA (required for create, cannot be empty, must exist in system)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status of the SLA agreement (optional, defaults to 'active'). Must be one of: active, inactive, expired"
                                }
                            }
                        },
                        "entity_id": {
                            "type": "string",
                            "description": "Unique identifier of the SLA agreement record. Required for update action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageCommunications(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, communication_data: Dict[str, Any] = None, communication_id: str = None) -> str:
        """
        Create or update communication records for incident notifications.

        Actions:
        - create: Create new communication (requires incident_id, communication_type, recipient_type, sender, delivery_method, message_content)
        - update: Update existing communication (requires communication_id and fields to update)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for communications"
            })
        
        # get existing data tables
        communications = data.get("communications", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        # allowed enums
        valid_types = ["status_update", "resolution_notice", "escalation_notice", "bridge_invitation"]
        valid_recipient_types = ["client", "internal", "executive"]
        valid_methods = ["email", "portal", "sms", "phone"]
        valid_statuses = ["pending", "sent", "delivered", "failed"]

        # valid values
        required_user_status = ["active"]

        # for create action
        if action == "create":
            if not communication_data:
                return json.dumps({
                    "success": False,
                    "error": "communication_data is required for create action"
                })
            
            # Validate required fields
            required_fields = ["incident_id", "communication_type", "recipient_type", "message_content", "sender", "delivery_method"]
            
            missing_fields = [field for field in required_fields if field not in communication_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid communication details - missing fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not communication_data[field] or str(communication_data[field]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
            
            # Allowed fields
            allowed_fields = ["incident_id", "communication_type", "recipient_type", "message_content", "sender", "recipient", "delivery_method", "delivery_status", "sent_at"]

            comm_fields = [field for field in communication_data if field not in allowed_fields]
            if comm_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Unrecognized fields in communication_data: {', '.join(comm_fields)}"
                })
            
            # Validate incident exists
            if str(communication_data["incident_id"]) not in incidents:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Incident not found"
                })
            
            # Validate communication_type
            if communication_data["communication_type"] not in valid_types:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid communication type - must be one of: {', '.join(valid_types)}"
                })
            
            # Validate recipient_type
            if communication_data["recipient_type"] not in valid_recipient_types:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid recipient type - must be one of: {', '.join(valid_recipient_types)}"
                })
            
            # Validate sender exists
            if str(communication_data["sender"]) not in users:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Sender user not found"
                })
            
            # Validate that sender user is active
            if users[str(communication_data["sender"])]["status"] not in required_user_status: 
                return json.dumps({ 
                    "success": False, 
                    "error": "Halt: User 'sender' must be active" 
                })
            
            # Validate delivery_method
            if communication_data["delivery_method"] not in valid_methods:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid delivery method - must be one of: {', '.join(valid_methods)}"
                })
            
            # Validate optional fields
            if communication_data.get("recipient"):
                if not str(communication_data["recipient"]).strip():
                    return json.dumps({
                        "success": False,
                        "error": "Field 'recipient' cannot be empty if provided"
                    })
                
                # Validate recipient if provided
                if str(communication_data["recipient"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Recipient user not found"
                    })
                
                # Validate that recipient user is active
                if users[str(communication_data["recipient"])]["status"] not in required_user_status: 
                    return json.dumps({ 
                        "success": False, 
                        "error": "Halt: User 'recipient' must be active" 
                    })
                
            # Validate delivery_status
            delivery_status = communication_data.get("delivery_status", "pending")
            if delivery_status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid delivery status - must be one of: {', '.join(valid_statuses)}"
                })
            
            # Validate sent_at is not empty if provided
            if "sent_at" in communication_data:
                if not str(communication_data["sent_at"]).strip():  
                    return json.dumps({
                        "success": False,
                        "error": "Halt: sent_at cannot be empty"
                    })
            
            # Generate new communication ID
            new_comm_id = generate_id(communications)
            
            # Create new communication record
            new_comm = {
                "communication_id": str(new_comm_id),
                "incident_id": str(communication_data["incident_id"]),
                "communication_type": communication_data["communication_type"],
                "recipient_type": communication_data["recipient_type"],
                "message_content": communication_data["message_content"],
                "sender": str(communication_data["sender"]),
                "recipient": str(communication_data["recipient"]) if communication_data.get("recipient") not in (None, "") else None,
                "delivery_method": communication_data["delivery_method"],
                "delivery_status": delivery_status,
                "sent_at": communication_data.get("sent_at") or None,
                "created_at": "2025-10-07T00:00:00"
            }
            
            communications[str(new_comm_id)] = new_comm
            
            return json.dumps({
                "success": True,
                "action": "create",
                "communication_id": str(new_comm_id),
                "message": f"Communication {new_comm_id} created successfully",
                "communication_data": new_comm
            })
        
        # for update action
        elif action == "update":
            if not communication_id:
                return json.dumps({
                    "success": False,
                    "error": "communication_id is required for update action"
                })

            if str(communication_id) not in communications:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Communication not found"
                })
            
            if not communication_data:
                return json.dumps({
                    "success": False,
                    "error": "communication_data is required for update action"
                })
            
            # Validate at least one optional field is provided
            update_fields = ["communication_type", "recipient_type", "message_content", "sender", "recipient", "delivery_method", "delivery_status", "sent_at"]

            provided_fields = [field for field in update_fields if field in communication_data]
            if not provided_fields:
                return json.dumps({
                    "success": False,
                    "error": f"At least one optional field must be provided for updates {', '.join(update_fields)}"
                })
            
            # Validate only allowed fields for updates
            invalid_fields = [field for field in communication_data.keys() if field not in update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for communication updating: {', '.join(invalid_fields)}"
                })

            # Validate non-empty fields
            for field, value in communication_data.items():
                if field != "recipient" and value is not None and str(value).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate communication type if provided
            if "communication_type" in communication_data and communication_data["communication_type"] not in valid_types:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid communication type - must be one of: {', '.join(valid_types)}"
                })
            
            # Validate recipient type if provided
            if "recipient_type" in communication_data and communication_data["recipient_type"] not in valid_recipient_types:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid recipient type - must be one of: {', '.join(valid_recipient_types)}"
                })
            
            # Validate sender if provided
            if "sender" in communication_data:
                if str(communication_data["sender"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Sender user not found"
                    })
                
                # Validate that sender user is active
                if users[str(communication_data["sender"])]["status"] not in required_user_status: 
                    return json.dumps({ 
                        "success": False, 
                        "error": "Halt: User 'sender' must be active" 
                    })
            
            # Validate recipient if provided
            if "recipient" in communication_data:
                if communication_data["recipient"] is not None and str(communication_data["recipient"]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": "Field 'recipient' cannot be empty if provided"
                    })
                
                if communication_data["recipient"] is not None:
                    if str(communication_data["recipient"]) not in users:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: Recipient user not found"
                        })
                    
                    # Validate that recipient user is active
                    if users[str(communication_data["recipient"])]["status"] not in required_user_status: 
                        return json.dumps({ 
                            "success": False, 
                            "error": "Halt: User 'recipient' must be active" 
                        })
            
            # Validate delivery method if provided
            if "delivery_method" in communication_data and communication_data["delivery_method"] not in valid_methods:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid delivery method - must be one of: {', '.join(valid_methods)}"
                })
            
            # Validate delivery_status if provided
            if "delivery_status" in communication_data and communication_data["delivery_status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid delivery status - must be one of: {', '.join(valid_statuses)}"
                })
            
            # Get current communication record
            current_comm = communications[str(communication_id)]
            # Update communication record with modified information
            updated_comm = current_comm.copy()
            for key, value in communication_data.items():
                if key in ["recipient", "delivery_method", "sent_at"]:
                    updated_comm[key] = str(value) if value not in (None, "") else None
                else:
                    updated_comm[key] = value

            communications[str(communication_id)] = updated_comm
            
            return json.dumps({
                "success": True,
                "action": "update",
                "communication_id": str(communication_id),
                "message": f"Communication {communication_id} updated successfully",
                "communication_data": updated_comm
            })
        
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_communications",
                "description": "Create or update communication records for incident notifications in the incident management system. This tool manages all incident-related communications including status updates, resolution notices, escalation notifications, and bridge invitations. Handles multi-channel delivery (email, portal, SMS, phone) to various recipient types (client, internal, executive). Validates sender/recipient user existence, ensures proper communication types, tracks delivery status, and maintains communication audit trail.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to record new communication or 'update' to modify existing communication"
                        },
                        "communication_data": {
                            "type": "object",
                            "description": "Communication data object containing fields for creating or updating communications",
                            "properties": {
                                "incident_id": {
                                    "type": "string",
                                    "description": "Related incident identifier (required for create, cannot be empty)"
                                },
                                "communication_type": {
                                    "type": "string",
                                    "description": "Type of communication (required for create). Must be one of: status_update, resolution_notice, escalation_notice, bridge_invitation"
                                },
                                "recipient_type": {
                                    "type": "string",
                                    "description": "Type of recipient (required for create). Must be one of: client, internal, executive"
                                },
                                "sender": {
                                    "type": "string",
                                    "description": "User identifier sending the communication (required for create, must be active user)"
                                },
                                "recipient": {
                                    "type": "string",
                                    "description": "Specific user identifier receiving the communication (optional, must be active user if provided)"
                                },
                                "delivery_method": {
                                    "type": "string",
                                    "description": "Method of delivery (required for create). Must be one of: email, portal, sms, phone"
                                },
                                "message_content": {
                                    "type": "string",
                                    "description": "Content of the communication message (required for create, cannot be empty)"
                                },
                                "sent_at": {
                                    "type": "string",
                                    "description": "Timestamp when communication was sent in YYYY-MM-DDTHH:MM:SS format (optional, cannot be empty if provided)"
                                },
                                "delivery_status": {
                                    "type": "string",
                                    "description": "Delivery status (optional, defaults to 'pending'). Must be one of: pending, sent, delivered, failed"
                                }
                            }
                        },
                        "communication_id": {
                            "type": "string",
                            "description": "Unique identifier of the communication. Required for update action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class LogAuditRecords(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        reference_id: str,
        reference_type: str,
        action: str,
        user_id: str,
        field_name: Optional[str] = None,
        old_value: Optional[str] = None,
        new_value: Optional[str] = None
    ) -> str:
        """
        Create audit trail records to track changes made to database records.
        
        Parameters:
        - reference_id: ID of the record that was changed
        - reference_type: Type of record being audited
        - action: Action performed (create, update)
        - user_id: ID of the user who performed the action
        - field_name: Name of the field that was changed (required for update)
        - old_value: Previous value of the field (nullable)
        - new_value: New value of the field (required for update)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        timestamp = "2025-10-01T00:00:00"
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })
        
        audit_trails = data.get("audit_trails", {})
        users = data.get("users", {})
        
        # Validate reference_type based on DBML schema
        valid_reference_types = [
            "user", "client", "sla", "ci", "incident", "escalation", "bridge", 
            "change", "rollback", "work_order", "problem", "incident_ci", 
            "problem_ci", "client_ci"
        ]
        if reference_type not in valid_reference_types:
            return json.dumps({
                "success": False,
                "error": f"Invalid reference_type '{reference_type}'. Must be one of: {', '.join(valid_reference_types)}"
            })
        
        # Validate action enum based on DBML schema
        valid_actions = ["create", "update"]
        if action not in valid_actions:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be one of: {', '.join(valid_actions)}"
            })
        
        # Business rule validation
        if action == "create" and field_name is not None:
            return json.dumps({
                "success": False,
                "error": "field_name should be null for create actions"
            })
        
        if action == "create" and old_value is not None:
            return json.dumps({
                "success": False,
                "error": "old_value should be null for create actions"
            })
        
        if action == "update":
            if field_name is None or str(field_name).strip() == "":
                return json.dumps({
                    "success": False,
                    "error": "field_name is required for update actions"
                })
            if new_value is None or str(new_value).strip() == "":
                return json.dumps({
                    "success": False,
                    "error": "new_value is required for update actions"
                })
        
        # Validate user_id FK
        user_id_str = str(user_id).strip().strip('"')
        if user_id_str not in users:
            return json.dumps({
                "success": False,
                "error": f"User '{user_id_str}' not found"
            })
        if users[user_id_str]["status"] != "active":
            return json.dumps({
                "success": False,
                "error": f"User '{user_id_str}' is not active"
            })
        
        # Validate that the referenced entity exists based on reference_type
        reference_tables = {
            "user": "users",
            "client": "clients",
            "sla": "sla_agreements",
            "ci": "configuration_items",
            "incident": "incidents",
            "escalation": "escalations",
            "bridge": "bridges",
            "change": "change_requests",
            "rollback": "rollback_requests",
            "work_order": "work_orders",
            "problem": "problem_tickets",
            "incident_ci": "incident_configuration_items",
            "problem_ci": "problem_configuration_items",
            "client_ci": "ci_client_assignments"
        }
        
        reference_table = reference_tables.get(reference_type)
        if reference_table and reference_table in data:
            reference_id_str = str(reference_id).strip().strip('"')
            if reference_id_str not in data[reference_table]:
                return json.dumps({
                    "success": False,
                    "error": f"{reference_type.title()} '{reference_id_str}' not found"
                })
        
        audit_trail_id = generate_id(audit_trails)
        
        new_audit_trail = {
            "audit_id": str(audit_trail_id),
            "reference_id": str(reference_id),
            "reference_type": reference_type,
            "action": action,
            "user_id": user_id_str,
            "field_name": field_name if field_name else None,
            "old_value": old_value if old_value else None,
            "new_value": new_value if new_value else None,
            "created_at": timestamp
        }
        
        audit_trails[str(audit_trail_id)] = new_audit_trail
        return json.dumps({
            "success": True,
            "audit_id": str(audit_trail_id),
            "audit_data": new_audit_trail
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "log_audit_records",
                "description": "Create audit trail records to track changes made to database records. Validates user activity, reference types, and enforces business rules for create vs update actions.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "reference_id": {
                            "type": "string",
                            "description": "ID of the record that was changed (required, cannot be empty)"
                        },
                        "reference_type": {
                            "type": "string",
                            "description": "Type of record being audited. Must be one of: user, client, sla, ci, incident, escalation, bridge, change, rollback, work_order, problem, incident_ci, problem_ci, client_ci",
                            "enum": ["user", "client", "sla", "ci", "incident", "escalation", "bridge", "change", "rollback", "work_order", "problem", "incident_ci", "problem_ci", "client_ci"]
                        },
                        "action": {
                            "type": "string",
                            "description": "Action performed. Must be one of: create, update. Note: field_name must be null for create actions, old_value must be null for create actions",
                            "enum": ["create", "update"]
                        },
                        "user_id": {
                            "type": "string",
                            "description": "ID of the user who performed the action (required, must be an active user)"
                        },
                        "field_name": {
                            "type": "string",
                            "description": "Name of the field that was changed (required for update actions, must be null for create actions)"
                        },
                        "old_value": {
                            "type": "string",
                            "description": "Previous value of the field (nullable, must be null for create actions)"
                        },
                        "new_value": {
                            "type": "string",
                            "description": "New value of the field (required for update actions, nullable for create actions)"
                        }
                    },
                    "required": ["reference_id", "reference_type", "action", "user_id"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverWorkflows(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover workflow entities (communications, approval_requests). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - communications: Communication records
        - approval_requests: Approval Request records
        """
        if entity_type not in ["communications", "approval_requests"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'communications' or 'approval_requests'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    if entity_type == "communications":
                        id_field = "communication_id"
                    else:  # approval_requests
                        id_field = "approval_id"
                    results.append({**entity_data, id_field: entity_id})
            else:
                if entity_type == "communications":
                    id_field = "communication_id"
                else:  # approval_requests
                    id_field = "approval_id"
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_workflows",
                "description": "Discover workflow entities (communications, approval requests). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'communications' or 'approval_requests'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "communication_id": {
                                    "type": "string",
                                    "description": "Communication ID (for communications)"
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "Associated incident ID"
                                },
                                "communication_type": {
                                    "type": "string",
                                    "description": "Type of communication: 'status_update', 'resolution_notice', 'escalation_notice', 'bridge_invitation' (for communications)"
                                },
                                "recipient_type": {
                                    "type": "string",
                                    "description": "Type of recipient: 'client', 'internal', 'executive' (for communications)"
                                },
                                "sender": {
                                    "type": "string",
                                    "description": "User ID of sender (for communications)"
                                },
                                "recipient": {
                                    "type": "string",
                                    "description": "User ID of recipient (for communications)"
                                },
                                "delivery_method": {
                                    "type": "string",
                                    "description": "Delivery method: 'email', 'portal', 'sms', 'phone' (for communications)"
                                },
                                "message_content": {
                                    "type": "string",
                                    "description": "Message content (for communications)"
                                },
                                "delivery_status": {
                                    "type": "string",
                                    "description": "Delivery status: 'pending', 'sent', 'delivered', 'failed' (for communications)"
                                },
                                "sent_at": {
                                    "type": "string",
                                    "description": "Sent timestamp in YYYY-MM-DD format (for communications)"
                                },
                                "approval_id": {
                                    "type": "string",
                                    "description": "Approval request ID (for approval_requests)"
                                },
                                "reference_id": {
                                    "type": "string",
                                    "description": "ID of the record requiring approval (for approval_requests)"
                                },
                                "reference_type": {
                                    "type": "string",
                                    "description": "Type of record requiring approval: 'escalation', 'bridge', 'change', 'rollback', 'rca', 'incident_closure' (for approval_requests)"
                                },
                                "requested_by": {
                                    "type": "string",
                                    "description": "User ID who requested approval (for approval_requests)"
                                },
                                "requested_action": {
                                    "type": "string",
                                    "description": "Action being requested: 'create_escalation', 'initiate_bridge', 'create_change_request', 'create_rollback_request', 'conduct_rca', 'close_incident' (for approval_requests)"
                                },
                                "approver": {
                                    "type": "string",
                                    "description": "User ID of approver (for approval_requests)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Approval status: 'pending', 'approved', 'denied' (for approval_requests)"
                                },
                                "requested_at": {
                                    "type": "string",
                                    "description": "Request timestamp in YYYY-MM-DD format (for approval_requests)"
                                },
                                "responded_at": {
                                    "type": "string",
                                    "description": "Response timestamp in YYYY-MM-DD format (for approval_requests)"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageAssets(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        entity_type: str,
        entity_data: Optional[Dict[str, Any]] = None,
        entity_id: Optional[str] = None
    ) -> str:
        """
        Create or update asset records (configuration items or CI-client assignments).

        Actions:
        - create: Create a new record (requires entity_type and entity_data)
        - update: Update an existing record (requires entity_type, entity_id, and entity_data)

        Entity Types:
        - configuration_items: Manages individual configuration items.
        - ci_client_assignments: Manages the assignment of configuration items to clients.
        """

        def generate_id(table: Dict[str, Any], prefix: str = "") -> str:
            if not table:
                return f"{prefix}1"
            max_id_num = 0
            for k in table.keys():
                try:
                    # Extract numeric part, handling potential non-numeric keys gracefully
                    if k.startswith(prefix):
                        num_part = int(k[len(prefix):])
                        if num_part > max_id_num:
                            max_id_num = num_part
                except ValueError:
                    continue # Ignore keys that don't match the expected format
            return f"{prefix}{max_id_num + 1}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if entity_type not in ["configuration_items", "ci_client_assignments"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'configuration_items' or 'ci_client_assignments'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        config_items = data.get("configuration_items", {})
        ci_client_assignments = data.get("ci_client_assignments", {})
        users = data.get("users", {}) # For responsible_owner validation
        clients = data.get("clients", {}) # For client_id validation

        # Define valid enums based on DBML schema
        valid_ci_types = ["server", "application", "database", "network", "storage", "service"]
        valid_environments = ["production", "staging", "development", "testing"]
        valid_operational_statuses = ["operational", "degraded", "down"]

        if action == "create":
            if not entity_data:
                return json.dumps({
                    "success": False,
                    "error": "entity_data is required for create action"
                })

            if entity_type == "configuration_items":
                required_fields = ["ci_name", "ci_type", "environment", "operational_status", "responsible_owner"]
                for field in required_fields:
                    if field not in entity_data or not entity_data[field] or str(entity_data[field]).strip() == "":
                        return json.dumps({
                            "success": False,
                            "error": f"Missing or empty required field for configuration_items: '{field}'"
                        })

                # Validate enums
                if entity_data["ci_type"] not in valid_ci_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid ci_type '{entity_data['ci_type']}'. Must be one of: {', '.join(valid_ci_types)}"
                    })
                if entity_data["environment"] not in valid_environments:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid environment '{entity_data['environment']}'. Must be one of: {', '.join(valid_environments)}"
                    })
                if entity_data["operational_status"] not in valid_operational_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid operational_status '{entity_data['operational_status']}'. Must be one of: {', '.join(valid_operational_statuses)}"
                    })

                # Validate responsible_owner exists and is active
                responsible_owner = str(entity_data["responsible_owner"]).strip().strip('"')
                if responsible_owner not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Responsible owner user '{responsible_owner}' not found"
                    })
                if users[responsible_owner]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Responsible owner user '{responsible_owner}' is not active"
                    })

                # Check for unique ci_name
                for ci in config_items.values():
                    if ci["ci_name"] == entity_data["ci_name"]:
                        return json.dumps({
                            "success": False,
                            "error": f"Configuration item with name '{entity_data['ci_name']}' already exists."
                        })

                new_id = generate_id(config_items, "CI")
                new_ci = {
                    "ci_id": new_id,
                    "ci_name": entity_data["ci_name"],
                    "ci_type": entity_data["ci_type"],
                    "environment": entity_data["environment"],
                    "operational_status": entity_data["operational_status"],
                    "responsible_owner": responsible_owner,
                    "created_at": timestamp,
                    "updated_at": timestamp
                }
                config_items[new_id] = new_ci
                return json.dumps({
                    "success": True,
                    "action": "create",
                    "entity_type": entity_type,
                    "ci_id": new_id,
                    "ci_data": new_ci
                })

            elif entity_type == "ci_client_assignments":
                required_fields = ["ci_id", "client_id"]
                for field in required_fields:
                    if field not in entity_data or not entity_data[field] or str(entity_data[field]).strip() == "":
                        return json.dumps({
                            "success": False,
                            "error": f"Missing or empty required field for ci_client_assignments: '{field}'"
                        })

                # Validate ci_id and client_id exist
                ci_id = str(entity_data["ci_id"]).strip().strip('"')
                client_id = str(entity_data["client_id"]).strip().strip('"')

                if ci_id not in config_items:
                    return json.dumps({
                        "success": False,
                        "error": f"Configuration item '{ci_id}' not found."
                    })
                if client_id not in clients:
                    return json.dumps({
                        "success": False,
                        "error": f"Client '{client_id}' not found."
                    })

                # Check for unique assignment (ci_id, client_id)
                for assignment in ci_client_assignments.values():
                    if assignment["ci_id"] == ci_id and assignment["client_id"] == client_id:
                        return json.dumps({
                            "success": False,
                            "error": f"Assignment for CI '{ci_id}' to client '{client_id}' already exists."
                        })

                new_id = generate_id(ci_client_assignments, "ASSIGN")
                new_assignment = {
                    "assignment_id": new_id,
                    "ci_id": ci_id,
                    "client_id": client_id,
                    "created_at": timestamp
                }
                ci_client_assignments[new_id] = new_assignment
                return json.dumps({
                    "success": True,
                    "action": "create",
                    "entity_type": entity_type,
                    "assignment_id": new_id,
                    "assignment_data": new_assignment
                })

        elif action == "update":
            if not entity_id:
                return json.dumps({
                    "success": False,
                    "error": "entity_id is required for update action"
                })
            if not entity_data:
                return json.dumps({
                    "success": False,
                    "error": "entity_data is required for update action"
                })

            entity_id = str(entity_id).strip().strip('"')

            if entity_type == "configuration_items":
                if entity_id not in config_items:
                    return json.dumps({
                        "success": False,
                        "error": f"Configuration item '{entity_id}' not found."
                    })

                # Validate allowed fields for update
                allowed_fields = ["ci_name", "ci_type", "environment", "operational_status", "responsible_owner"]
                invalid_fields = [field for field in entity_data if field not in allowed_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields for configuration_items update: {', '.join(invalid_fields)}"
                    })

                # Validate non-empty fields
                for field, value in entity_data.items():
                    if value is None or (isinstance(value, str) and value.strip() == ""):
                        return json.dumps({
                            "success": False,
                            "error": f"Field '{field}' cannot be empty"
                        })

                # Validate enums if provided
                if "ci_type" in entity_data and entity_data["ci_type"] not in valid_ci_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid ci_type '{entity_data['ci_type']}'. Must be one of: {', '.join(valid_ci_types)}"
                    })
                if "environment" in entity_data and entity_data["environment"] not in valid_environments:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid environment '{entity_data['environment']}'. Must be one of: {', '.join(valid_environments)}"
                    })
                if "operational_status" in entity_data and entity_data["operational_status"] not in valid_operational_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid operational_status '{entity_data['operational_status']}'. Must be one of: {', '.join(valid_operational_statuses)}"
                    })

                # Validate responsible_owner if provided
                if "responsible_owner" in entity_data:
                    responsible_owner = str(entity_data["responsible_owner"]).strip().strip('"')
                    if responsible_owner not in users:
                        return json.dumps({
                            "success": False,
                            "error": f"Responsible owner user '{responsible_owner}' not found"
                        })
                    if users[responsible_owner]["status"] != "active":
                        return json.dumps({
                            "success": False,
                            "error": f"Responsible owner user '{responsible_owner}' is not active"
                        })
                    entity_data["responsible_owner"] = responsible_owner

                # Check for unique ci_name if updated
                if "ci_name" in entity_data:
                    for ci_id_key, ci in config_items.items():
                        if ci_id_key != entity_id and ci["ci_name"] == entity_data["ci_name"]:
                            return json.dumps({
                                "success": False,
                                "error": f"Configuration item with name '{entity_data['ci_name']}' already exists."
                            })

                updated_ci = config_items[entity_id].copy()
                for key, value in entity_data.items():
                    updated_ci[key] = value
                updated_ci["updated_at"] = timestamp
                config_items[entity_id] = updated_ci
                return json.dumps({
                    "success": True,
                    "action": "update",
                    "entity_type": entity_type,
                    "ci_id": entity_id,
                    "ci_data": updated_ci
                })

            elif entity_type == "ci_client_assignments":
                if entity_id not in ci_client_assignments:
                    return json.dumps({
                        "success": False,
                        "error": f"CI-Client assignment '{entity_id}' not found."
                    })

                # Based on the DBML schema, ci_id and client_id are not directly updatable via assignment_id.
                # Assignments are typically immutable; if changes are needed, the old assignment is deleted,
                # and a new one is created.
                return json.dumps({
                    "success": False,
                    "error": "CI-Client assignments are generally immutable. Please delete and re-create if changes are needed."
                })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_assets",
                "description": "Create or update asset records. This includes managing configuration items (CIs) and their assignments to clients. Use 'configuration_items' for individual asset details and 'ci_client_assignments' for linking CIs to clients.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new record, 'update' to modify existing record"
                        },
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to manage. Must be 'configuration_items' or 'ci_client_assignments'.",
                            "enum": ["configuration_items", "ci_client_assignments"]
                        },
                        "entity_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating or updating the specified entity_type. The required fields vary based on 'entity_type' and 'action'.",
                            "properties": {
                                # Properties relevant for 'configuration_items'
                                "ci_name": {
                                    "type": "string",
                                    "description": "Name of the Configuration Item (required for creating 'configuration_items', must be unique, cannot be empty). Updatable."
                                },
                                "ci_type": {
                                    "type": "string",
                                    "description": "Type of the Configuration Item (required for creating 'configuration_items'). Must be one of: server, application, database, network, storage, service. Updatable.",
                                    "enum": ["server", "application", "database", "network", "storage", "service"]
                                },
                                "environment": {
                                    "type": "string",
                                    "description": "Environment where the CI is deployed (required for creating 'configuration_items'). Must be one of: production, staging, development, testing. Updatable.",
                                    "enum": ["production", "staging", "development", "testing"]
                                },
                                "operational_status": {
                                    "type": "string",
                                    "description": "Operational status of the CI (required for creating 'configuration_items'). Must be one of: operational, degraded, down. Updatable.",
                                    "enum": ["operational", "degraded", "down"]
                                },
                                "responsible_owner": {
                                    "type": "string",
                                    "description": "User ID of the responsible owner for the CI (required for creating 'configuration_items', must be an active user). Updatable."
                                },
                                # Properties relevant for 'ci_client_assignments'
                                "ci_id": {
                                    "type": "string",
                                    "description": "ID of the Configuration Item to assign (required for creating 'ci_client_assignments', must exist). Not updatable for existing assignments."
                                },
                                "client_id": {
                                    "type": "string",
                                    "description": "ID of the Client to assign the CI to (required for creating 'ci_client_assignments', must exist). Not updatable for existing assignments."
                                }
                            }
                        },
                        "entity_id": {
                            "type": "string",
                            "description": "Unique identifier of the entity to update. Required for 'update' action only. For 'configuration_items', this is 'ci_id'. For 'ci_client_assignments', this is 'assignment_id'."
                        }
                    },
                    "required": ["action", "entity_type"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageApprovalRequests(Tool):
    """
    Create and update approval requests for escalations, bridges, changes, rollbacks, RCAs, and incident closures.
    """
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        approval_id: Optional[str] = None,
        reference_id: Optional[str] = None,
        reference_type: Optional[str] = None,
        requested_by: Optional[str] = None,
        requested_action: Optional[str] = None,
        approver: Optional[str] = None,
        status: Optional[str] = None
    ) -> str:
        """
        Create or update approval request records.

        Actions:
        - create: Create new approval request (requires reference_id, reference_type, requested_by, requested_action, approver)
        - update: Update existing approval request (requires approval_id; optional: status)
        """
        def generate_id(table: Dict[str, Any]) -> str:
            """Generates a new unique ID for a record."""
            if not table:
                return "1"
            return str(max(int(k) for k in table.keys()) + 1)

        timestamp = "2025-10-01T12:00:00"
        approvals = data.get("approval_requests", {})
        users = data.get("users", {})

        valid_reference_types = ["escalation", "bridge", "change", "rollback", "rca", "incident_closure"]
        valid_requested_actions = [
            "create_escalation", "initiate_bridge", "create_change_request",
            "create_rollback_request", "conduct_rca", "close_incident"
        ]
        valid_statuses = ["pending", "approved", "denied"]

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": "Invalid action. Must be 'create' or 'update'"
            })

        if action == "update" and not approval_id:
            return json.dumps({
                "success": False,
                "error": "approval_id is required for update action"
            })

        if action == "create":
            if not all([reference_id, reference_type, requested_by, requested_action, approver]):
                return json.dumps({
                    "success": False,
                    "error": "reference_id, reference_type, requested_by, requested_action, and approver are required for create action"
                })

            # Validate users exist and are active
            for user_id in [requested_by, approver]:
                if user_id not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"User with ID {user_id} not found"
                    })
                if users[user_id]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"User with ID {user_id} is not active"
                    })

            if reference_type not in valid_reference_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid reference_type. Must be one of: {', '.join(valid_reference_types)}"
                })

            # Validate requested_action
            if requested_action not in valid_requested_actions:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid requested_action. Must be one of: {', '.join(valid_requested_actions)}"
                })

            new_id = generate_id(approvals)
            new_approval = {
                "approval_id": new_id,
                "reference_id": reference_id,
                "reference_type": reference_type,
                "requested_by": requested_by,
                "requested_action": requested_action,
                "approver": approver,
                "status": "pending",
                "requested_at": timestamp,
                "responded_at": None
            }
            approvals[new_id] = new_approval

            return json.dumps({
                "success": True,
                "action": "create",
                "approval_id": new_id,
                "approval_data": new_approval
            })

        if action == "update":
            if approval_id not in approvals:
                return json.dumps({
                    "success": False,
                    "error": f"Approval request with ID {approval_id} not found"
                })

            # Validate at least one field is being updated
            if status is None:
                return json.dumps({
                    "success": False,
                    "error": "status must be provided for update"
                })

            existing_approval = approvals[approval_id]

            if status is not None:
                if status not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
                    })
                existing_approval["status"] = status
                if status in ["approved", "denied"]:
                    existing_approval["responded_at"] = timestamp

            return json.dumps({
                "success": True,
                "action": "update",
                "approval_id": approval_id,
                "approval_data": existing_approval
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        """
        Returns comprehensive information about the tool's capabilities, parameters, and data schema.
        """
        return {
            "type": "function",
            "function": {
                "name": "manage_approval_requests",
                "description": "Create/update approval requests for various items requiring approval. Supports escalations, bridges, changes, rollbacks, RCAs, and incident closures. Actions: 'create' (requires reference_id, reference_type, requested_by, requested_action, approver), 'update' (requires approval_id; optional: status).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' or 'update'",
                            "enum": ["create", "update"]
                        },
                        "approval_id": {
                            "type": "string",
                            "description": "Required for update. ID of the approval request to update"
                        },
                        "reference_id": {
                            "type": "string",
                            "description": "Required for create. ID of the item needing approval (e.g., escalation_id, bridge_id, change_id)"
                        },
                        "reference_type": {
                            "type": "string",
                            "description": "Required for create. Type of item requiring approval",
                            "enum": ["escalation", "bridge", "change", "rollback", "rca", "incident_closure"]
                        },
                        "requested_by": {
                            "type": "string",
                            "description": "Required for create. ID of the active user requesting approval"
                        },
                        "requested_action": {
                            "type": "string",
                            "description": "Required for create. Specific action being requested",
                            "enum": ["create_escalation", "initiate_bridge", "create_change_request", "create_rollback_request", "conduct_rca", "close_incident"]
                        },
                        "approver": {
                            "type": "string",
                            "description": "Required for create. ID of the active user who needs to approve"
                        },
                        "status": {
                            "type": "string",
                            "description": "For update only. New status of the approval request",
                            "enum": ["pending", "approved", "denied"]
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageAttachments(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        attachment_data: Optional[Dict[str, Any]] = None,
        attachment_id: Optional[str] = None # Although attachments are typically immutable, including for consistency if a delete action were added later.
    ) -> str:
        """
        Create new attachment records.

        Actions:
        - create: Create a new attachment record (requires attachment_data)
        """

        def generate_id(table: Dict[str, Any], prefix: str) -> str:
            if not table:
                return f"{prefix}1"
            max_id = 0
            for k in table.keys():
                try:
                    num = int(k[len(prefix):])
                    if num > max_id:
                        max_id = num
                except ValueError:
                    continue
            return f"{prefix}{max_id + 1}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create"]: # Attachments are typically created and then immutable, not updated.
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        attachments = data.get("attachments", {})
        users = data.get("users", {})
        
        # Tables that can be referenced by attachments
        reference_tables = {
            "incident": data.get("incidents", {}),
            "change": data.get("change_requests", {}),
            "rca": data.get("root_cause_analyses", {}),
            "report": data.get("incident_reports", {}),
            "pir": data.get("post_incident_reviews", {}),
            "communication": data.get("communications", {}),
            "work_order": data.get("work_orders", {}),
            "problem": data.get("problem_tickets", {})
        }

        # Define valid enums based on DBML schema
        valid_reference_types = [
            "incident", "change", "rca", "report", "pir", "communication", "work_order", "problem"
        ]

        if action == "create":
            if not attachment_data:
                return json.dumps({
                    "success": False,
                    "error": "attachment_data is required for create action"
                })

            # Validate required fields as per DBML
            required_fields = [
                "reference_id", "reference_type", "file_name", "file_url",
                "file_type", "file_size_bytes", "uploaded_by"
            ]
            missing_fields = [field for field in required_fields if field not in attachment_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if (isinstance(attachment_data[field], str) and str(attachment_data[field]).strip() == "") or attachment_data[field] is None:
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty or null"
                    })

            # Validate reference_type enum
            reference_type = attachment_data["reference_type"]
            if reference_type not in valid_reference_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid reference_type '{reference_type}'. Must be one of: {', '.join(valid_reference_types)}"
                })

            # Validate uploaded_by FK
            uploaded_by = str(attachment_data["uploaded_by"]).strip().strip('"')
            if uploaded_by not in users:
                return json.dumps({
                    "success": False,
                    "error": f"Uploaded by user '{uploaded_by}' not found"
                })
            if users[uploaded_by]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"Uploaded by user '{uploaded_by}' is not active"
                })

            # Validate reference_id FK based on reference_type
            reference_id = str(attachment_data["reference_id"]).strip().strip('"')
            target_table = reference_tables.get(reference_type)
            if not target_table:
                return json.dumps({
                    "success": False,
                    "error": f"Reference type '{reference_type}' does not map to a known table for validation."
                })
            if reference_id not in target_table:
                return json.dumps({
                    "success": False,
                    "error": f"Reference ID '{reference_id}' not found in '{reference_type}' table."
                })
            
            # Validate file_size_bytes is a positive integer
            file_size_bytes = attachment_data["file_size_bytes"]
            if not isinstance(file_size_bytes, int) or file_size_bytes < 0:
                return json.dumps({
                    "success": False,
                    "error": f"file_size_bytes must be a non-negative integer."
                })

            new_id = generate_id(attachments, "ATT")
            new_attachment = {
                "attachment_id": new_id,
                "reference_id": reference_id,
                "reference_type": reference_type,
                "file_name": attachment_data["file_name"],
                "file_url": attachment_data["file_url"],
                "file_type": attachment_data["file_type"],
                "file_size_bytes": file_size_bytes,
                "uploaded_by": uploaded_by,
                "uploaded_at": timestamp
            }
            attachments[new_id] = new_attachment
            return json.dumps({
                "success": True,
                "action": "create",
                "attachment_id": new_id,
                "attachment_data": new_attachment
            })
        
        # No 'update' action for attachments as per schema (no updated_at field, implies immutability)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_attachments",
                "description": "Create new attachment records in the system. Attachments are associated with various record types like incidents, changes, or problem tickets.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to add a new attachment."
                        },
                        "attachment_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating an attachment.",
                            "properties": {
                                "reference_id": {
                                    "type": "string",
                                    "description": "The ID of the record this attachment belongs to (e.g., incident_id, change_id). Required for create, cannot be empty. Must refer to an existing record of the specified reference_type."
                                },
                                "reference_type": {
                                    "type": "string",
                                    "description": "The type of record this attachment is linked to (e.g., incident, change, rca). Required for create. Must be one of: incident, change, rca, report, pir, communication, work_order, problem.",
                                    "enum": ["incident", "change", "rca", "report", "pir", "communication", "work_order", "problem"]
                                },
                                "file_name": {
                                    "type": "string",
                                    "description": "The name of the attached file (e.g., 'screenshot.png'). Required for create, cannot be empty."
                                },
                                "file_url": {
                                    "type": "string",
                                    "description": "The URL or path where the file is stored (e.g., 'https://storage.example.com/files/abc.png'). Required for create, cannot be empty."
                                },
                                "file_type": {
                                    "type": "string",
                                    "description": "The MIME type or extension of the file (e.g., 'image/png', 'application/pdf'). Required for create, cannot be empty."
                                },
                                "file_size_bytes": {
                                    "type": "integer",
                                    "description": "The size of the file in bytes. Required for create, must be a non-negative integer."
                                },
                                "uploaded_by": {
                                    "type": "string",
                                    "description": "The user ID of the person who uploaded the attachment. Required for create. Must refer to an existing active user."
                                }
                            }
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageClients(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        client_data: Optional[Dict[str, Any]] = None,
        client_id: Optional[str] = None
    ) -> str:
        """
        Create or update client records.

        Actions:
        - create: Create a new client record (requires client_data)
        - update: Update an existing client record (requires client_id and client_data)
        """

        def generate_id(table: Dict[str, Any]) -> str:
            if not table:
                return "CLI1"
            max_id = 0
            for k in table.keys():
                try:
                    num = int(k[3:]) # Assuming format 'CLIX'
                    if num > max_id:
                        max_id = num
                except ValueError:
                    continue
            return f"CLI{max_id + 1}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        clients = data.get("clients", {})
        # No 'users' needed for primary_contact_id validation as per this schema for clients table

        # Define valid enums based on DBML schema
        valid_company_types = ["enterprise", "mid_market", "smb", "startup"]
        valid_support_coverages = ["24x7", "business_hours", "on_call"]
        valid_preferred_communications = ["email", "portal", "phone", "slack"]
        valid_statuses = ["active", "inactive"]

        if action == "create":
            if not client_data:
                return json.dumps({
                    "success": False,
                    "error": "client_data is required for create action"
                })

            # Validate required fields as per DBML
            # client_name, company_type, support_coverage, preferred_communication are NOT NULL
            required_fields = ["client_name", "company_type", "support_coverage", "preferred_communication"]
            missing_fields = [field for field in required_fields if field not in client_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not client_data[field] or (isinstance(client_data[field], str) and str(client_data[field]).strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate client_name uniqueness
            client_name = str(client_data["client_name"]).strip()
            for client in clients.values():
                if client["client_name"].lower() == client_name.lower():
                    return json.dumps({
                        "success": False,
                        "error": f"Client with name '{client_name}' already exists."
                    })

            # Validate registration_number uniqueness if provided
            registration_number = client_data.get("registration_number")
            if registration_number:
                registration_number = str(registration_number).strip()
                for client in clients.values():
                    if client.get("registration_number") and client["registration_number"].lower() == registration_number.lower():
                        return json.dumps({
                            "success": False,
                            "error": f"Client with registration number '{registration_number}' already exists."
                        })
            
            # Validate enums
            if client_data["company_type"] not in valid_company_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid company_type '{client_data['company_type']}'. Must be one of: {', '.join(valid_company_types)}"
                })
            if client_data["support_coverage"] not in valid_support_coverages:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid support_coverage '{client_data['support_coverage']}'. Must be one of: {', '.join(valid_support_coverages)}"
                })
            if client_data["preferred_communication"] not in valid_preferred_communications:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid preferred_communication '{client_data['preferred_communication']}'. Must be one of: {', '.join(valid_preferred_communications)}"
                })
            
            # Status is 'active' by default, if provided, must be valid
            status = client_data.get("status", "active")
            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{status}'. Must be one of: {', '.join(valid_statuses)}"
                })

            new_id = generate_id(clients)
            new_client = {
                "client_id": new_id,
                "client_name": client_name,
                "registration_number": registration_number if registration_number else None, # Nullable
                "company_type": client_data["company_type"],
                "primary_address": client_data.get("primary_address"), # Nullable
                "support_coverage": client_data["support_coverage"],
                "preferred_communication": client_data["preferred_communication"],
                "status": status,
                "created_at": timestamp,
                "updated_at": timestamp
            }
            clients[new_id] = new_client
            return json.dumps({
                "success": True,
                "action": "create",
                "client_id": new_id,
                "client_data": new_client
            })

        elif action == "update":
            if not client_id:
                return json.dumps({
                    "success": False,
                    "error": "client_id is required for update action"
                })
            client_id = str(client_id).strip().strip('"')
            if client_id not in clients:
                return json.dumps({
                    "success": False,
                    "error": f"Client '{client_id}' not found"
                })

            if not client_data:
                return json.dumps({
                    "success": False,
                    "error": "client_data is required for update action"
                })

            # Allowed fields for update
            allowed_fields = [
                "client_name", "registration_number", "company_type", "primary_address",
                "support_coverage", "preferred_communication", "status"
            ]
            invalid_fields = [field for field in client_data if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for update: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields (if provided, they shouldn't be empty strings, but nullable fields can be None)
            # Note: company_type, support_coverage, preferred_communication, status are NOT NULL, so cannot be empty string/None if provided for update
            nullable_fields = ["registration_number", "primary_address"]
            for field, value in client_data.items():
                if field not in nullable_fields and (value is None or (isinstance(value, str) and value.strip() == "")):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
                elif field in nullable_fields and (isinstance(value, str) and value.strip() == ""):
                    client_data[field] = None # Treat empty string as null for nullable fields

            # Validate client_name uniqueness if updated
            if "client_name" in client_data:
                updated_client_name = str(client_data["client_name"]).strip()
                for existing_client_id, client in clients.items():
                    if existing_client_id != client_id and client["client_name"].lower() == updated_client_name.lower():
                        return json.dumps({
                            "success": False,
                            "error": f"Client with name '{updated_client_name}' already exists."
                        })
                client_data["client_name"] = updated_client_name

            # Validate registration_number uniqueness if updated
            if "registration_number" in client_data and client_data["registration_number"] is not None:
                updated_reg_num = str(client_data["registration_number"]).strip()
                for existing_client_id, client in clients.items():
                    if existing_client_id != client_id and client.get("registration_number") and client["registration_number"].lower() == updated_reg_num.lower():
                        return json.dumps({
                            "success": False,
                            "error": f"Client with registration number '{updated_reg_num}' already exists."
                        })
                client_data["registration_number"] = updated_reg_num
            elif "registration_number" in client_data and client_data["registration_number"] is None:
                client_data["registration_number"] = None # Allow setting to null

            # Validate enums if provided
            if "company_type" in client_data and client_data["company_type"] not in valid_company_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid company_type '{client_data['company_type']}'. Must be one of: {', '.join(valid_company_types)}"
                })
            if "support_coverage" in client_data and client_data["support_coverage"] not in valid_support_coverages:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid support_coverage '{client_data['support_coverage']}'. Must be one of: {', '.join(valid_support_coverages)}"
                })
            if "preferred_communication" in client_data and client_data["preferred_communication"] not in valid_preferred_communications:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid preferred_communication '{client_data['preferred_communication']}'. Must be one of: {', '.join(valid_preferred_communications)}"
                })
            if "status" in client_data and client_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{client_data['status']}'. Must be one of: {', '.join(valid_statuses)}"
                })

            updated_client = clients[client_id].copy()
            for key, value in client_data.items():
                updated_client[key] = value
            updated_client["updated_at"] = timestamp
            clients[client_id] = updated_client
            return json.dumps({
                "success": True,
                "action": "update",
                "client_id": client_id,
                "client_data": updated_client
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_clients",
                "description": "Create or update client records in the system. This tool allows for managing client details, including their company type, support coverage, and communication preferences.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to add a new client, 'update' to modify an existing client."
                        },
                        "client_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating or updating a client.",
                            "properties": {
                                "client_name": {
                                    "type": "string",
                                    "description": "The unique name of the client (required for create, must be unique, cannot be empty). Updatable."
                                },
                                "registration_number": {
                                    "type": "string",
                                    "description": "The client's unique registration number (optional, must be unique if provided). Updatable, can be set to null."
                                },
                                "company_type": {
                                    "type": "string",
                                    "description": "The type of company (required for create). Must be one of: enterprise, mid_market, smb, startup. Updatable.",
                                    "enum": ["enterprise", "mid_market", "smb", "startup"]
                                },
                                "primary_address": {
                                    "type": "string",
                                    "description": "The client's primary physical address (optional). Updatable, can be set to null."
                                },
                                "support_coverage": {
                                    "type": "string",
                                    "description": "The level of support coverage for the client (required for create). Must be one of: 24x7, business_hours, on_call. Updatable.",
                                    "enum": ["24x7", "business_hours", "on_call"]
                                },
                                "preferred_communication": {
                                    "type": "string",
                                    "description": "The client's preferred method of communication (required for create). Must be one of: email, portal, phone, slack. Updatable.",
                                    "enum": ["email", "portal", "phone", "slack"]
                                },
                                "status": {
                                    "type": "string",
                                    "description": "The operational status of the client (optional for create, defaults to 'active'). Must be one of: active, inactive. Updatable.",
                                    "enum": ["active", "inactive"]
                                }
                            }
                        },
                        "client_id": {
                            "type": "string",
                            "description": "The unique identifier of the client to update. Required for 'update' action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageChangeControl(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        change_request_data: Optional[Dict[str, Any]] = None,
        change_id: Optional[str] = None
    ) -> str:
        """
        Create or update change request records.

        Actions:
        - create: Create a new change request record (requires change_request_data)
        - update: Update an existing change request record (requires change_id and change_request_data)
        """

        def generate_id(table: Dict[str, Any], prefix: str) -> str:
            if not table:
                return f"{prefix}1"
            max_id = 0
            for k in table.keys():
                try:
                    num = int(k[len(prefix):])
                    if num > max_id:
                        max_id = num
                except ValueError:
                    continue
            return f"{prefix}{max_id + 1}"

        def generate_change_number(table: Dict[str, Any]) -> str:
            if not table:
                return "CHG0000001"
            max_num = 0
            for change in table.values():
                change_num = change.get("change_number", "")
                if change_num.startswith("CHG"):
                    try:
                        num = int(change_num[3:])
                        if num > max_num:
                            max_num = num
                    except ValueError:
                        continue
            return f"CHG{max_num + 1:07d}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        change_requests = data.get("change_requests", {})
        users = data.get("users", {})
        incidents = data.get("incidents", {})
        problem_tickets = data.get("problem_tickets", {})

        # Define valid enums based on DBML schema
        valid_change_types = ["standard", "normal", "emergency"]
        valid_risk_levels = ["low", "medium", "high", "critical"]
        valid_statuses = ["requested", "approved", "denied", "scheduled", "implemented", "cancelled"]

        if action == "create":
            if not change_request_data:
                return json.dumps({
                    "success": False,
                    "error": "change_request_data is required for create action"
                })

            # Validate required fields as per DBML
            required_fields = ["title", "description", "change_type", "risk_level", "requested_by"]
            missing_fields = [field for field in required_fields if field not in change_request_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not change_request_data[field] or (isinstance(change_request_data[field], str) and change_request_data[field].strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate enums
            if change_request_data["change_type"] not in valid_change_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid change_type '{change_request_data['change_type']}'. Must be one of: {', '.join(valid_change_types)}"
                })
            if change_request_data["risk_level"] not in valid_risk_levels:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid risk_level '{change_request_data['risk_level']}'. Must be one of: {', '.join(valid_risk_levels)}"
                })
            
            # Status defaults to 'requested' if not provided
            status = change_request_data.get("status", "requested")
            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{status}'. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate requested_by user exists and is active
            requested_by = str(change_request_data["requested_by"]).strip().strip('"')
            if requested_by not in users:
                return json.dumps({
                    "success": False,
                    "error": f"User '{requested_by}' not found"
                })
            if users[requested_by]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"User '{requested_by}' is not active"
                })
            
            # Validate optional approved_by if provided
            approved_by = change_request_data.get("approved_by")
            if approved_by:
                approved_by = str(approved_by).strip().strip('"')
                if approved_by not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Approved by user '{approved_by}' not found"
                    })
                if users[approved_by]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Approved by user '{approved_by}' is not active"
                    })
            
            # Validate optional incident_id if provided
            incident_id = change_request_data.get("incident_id")
            if incident_id:
                incident_id = str(incident_id).strip().strip('"')
                if incident_id not in incidents:
                    return json.dumps({
                        "success": False,
                        "error": f"Incident '{incident_id}' not found"
                    })
            
            # Validate optional problem_ticket_id if provided
            problem_ticket_id = change_request_data.get("problem_ticket_id")
            if problem_ticket_id:
                problem_ticket_id = str(problem_ticket_id).strip().strip('"')
                if problem_ticket_id not in problem_tickets:
                    return json.dumps({
                        "success": False,
                        "error": f"Problem ticket '{problem_ticket_id}' not found"
                    })

            new_id = generate_id(change_requests, "")
            new_change_number = generate_change_number(change_requests)
            
            new_cr = {
                "change_id": new_id,
                "change_number": new_change_number,
                "incident_id": incident_id if incident_id else None,
                "problem_ticket_id": problem_ticket_id if problem_ticket_id else None,
                "title": change_request_data["title"],
                "description": change_request_data["description"],
                "change_type": change_request_data["change_type"],
                "risk_level": change_request_data["risk_level"],
                "requested_by": requested_by,
                "approved_by": approved_by if approved_by else None,
                "status": status,
                "implementation_date": change_request_data.get("implementation_date"),
                "created_at": timestamp,
                "updated_at": timestamp
            }
            change_requests[new_id] = new_cr
            return json.dumps({
                "success": True,
                "action": "create",
                "change_id": new_id,
                "change_request_data": new_cr
            })

        elif action == "update":
            if not change_id:
                return json.dumps({
                    "success": False,
                    "error": "change_id is required for update action"
                })
            change_id = str(change_id).strip().strip('"')
            if change_id not in change_requests:
                return json.dumps({
                    "success": False,
                    "error": f"Change request '{change_id}' not found"
                })

            if not change_request_data:
                return json.dumps({
                    "success": False,
                    "error": "change_request_data is required for update action"
                })

            # Allowed fields for update (change_id, change_number, created_at are not updatable)
            allowed_fields = [
                "title", "description", "change_type", "risk_level", "status",
                "requested_by", "approved_by", "implementation_date",
                "incident_id", "problem_ticket_id"
            ]
            invalid_fields = [field for field in change_request_data if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for update: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields (if provided, they shouldn't be empty strings, but nullable fields can be None)
            nullable_fields = ["approved_by", "implementation_date", "incident_id", "problem_ticket_id"]
            for field, value in change_request_data.items():
                if field not in nullable_fields and (value is None or (isinstance(value, str) and value.strip() == "")):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
                elif field in nullable_fields and (isinstance(value, str) and value.strip() == ""):
                    change_request_data[field] = None # Treat empty string as null for nullable fields

            # Validate enums if provided
            if "change_type" in change_request_data and change_request_data["change_type"] not in valid_change_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid change_type. Must be one of: {', '.join(valid_change_types)}"
                })
            if "risk_level" in change_request_data and change_request_data["risk_level"] not in valid_risk_levels:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid risk_level. Must be one of: {', '.join(valid_risk_levels)}"
                })
            if "status" in change_request_data and change_request_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate user fields if provided
            for user_field in ["requested_by", "approved_by"]:
                if user_field in change_request_data and change_request_data[user_field] is not None:
                    user_id = str(change_request_data[user_field]).strip().strip('"')
                    if user_id not in users:
                        return json.dumps({
                            "success": False,
                            "error": f"User '{user_id}' for field '{user_field}' not found"
                        })
                    if users[user_id]["status"] != "active":
                        return json.dumps({
                            "success": False,
                            "error": f"User '{user_id}' for field '{user_field}' is not active"
                        })
                    change_request_data[user_field] = user_id
                elif user_field in change_request_data and change_request_data[user_field] is None:
                    change_request_data[user_field] = None # Allow setting to null

            # Validate incident_id if provided
            if "incident_id" in change_request_data and change_request_data["incident_id"] is not None:
                incident_id = str(change_request_data["incident_id"]).strip().strip('"')
                if incident_id not in incidents:
                    return json.dumps({
                        "success": False,
                        "error": f"Incident '{incident_id}' not found"
                    })
                change_request_data["incident_id"] = incident_id
            elif "incident_id" in change_request_data and change_request_data["incident_id"] is None:
                change_request_data["incident_id"] = None # Allow setting to null
            
            # Validate problem_ticket_id if provided
            if "problem_ticket_id" in change_request_data and change_request_data["problem_ticket_id"] is not None:
                problem_ticket_id = str(change_request_data["problem_ticket_id"]).strip().strip('"')
                if problem_ticket_id not in problem_tickets:
                    return json.dumps({
                        "success": False,
                        "error": f"Problem ticket '{problem_ticket_id}' not found"
                    })
                change_request_data["problem_ticket_id"] = problem_ticket_id
            elif "problem_ticket_id" in change_request_data and change_request_data["problem_ticket_id"] is None:
                change_request_data["problem_ticket_id"] = None # Allow setting to null

            updated_cr = change_requests[change_id].copy()
            for key, value in change_request_data.items():
                updated_cr[key] = value
            updated_cr["updated_at"] = timestamp
            change_requests[change_id] = updated_cr
            return json.dumps({
                "success": True,
                "action": "update",
                "change_id": change_id,
                "change_request_data": updated_cr
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_change_control",
                "description": "Create or update change request records in the change management system. This tool supports documenting, categorizing, and tracking changes to IT services and infrastructure.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish a new change request, 'update' to modify an existing change request."
                        },
                        "change_request_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating or updating a change request.",
                            "properties": {
                                "title": {
                                    "type": "string",
                                    "description": "Brief title or summary of the change (required for create, cannot be empty). Updatable."
                                },
                                "description": {
                                    "type": "string",
                                    "description": "Detailed description of the change, including its purpose and scope (required for create, cannot be empty). Updatable."
                                },
                                "change_type": {
                                    "type": "string",
                                    "description": "Classification of the change (required for create). Must be one of: standard, normal, emergency. Updatable.",
                                    "enum": ["standard", "normal", "emergency"]
                                },
                                "risk_level": {
                                    "type": "string",
                                    "description": "Risk level of the change (required for create). Must be one of: low, medium, high, critical. Updatable.",
                                    "enum": ["low", "medium", "high", "critical"]
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Current status of the change request (optional for create, defaults to 'requested'). Must be one of: requested, approved, denied, scheduled, implemented, cancelled. Updatable.",
                                    "enum": ["requested", "approved", "denied", "scheduled", "implemented", "cancelled"]
                                },
                                "requested_by": {
                                    "type": "string",
                                    "description": "User ID of the person who requested the change (required for create, must be an active user). Updatable."
                                },
                                "approved_by": {
                                    "type": "string",
                                    "description": "User ID of the person who approved the change (optional, must be an active user if provided). Updatable, can be set to null."
                                },
                                "implementation_date": {
                                    "type": "string",
                                    "description": "Date the change was implemented in YYYY-MM-DDTHH:MM:SS format (optional). Updatable, can be set to null."
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "Related incident ID (optional, must exist if provided). Updatable, can be set to null."
                                },
                                "problem_ticket_id": {
                                    "type": "string",
                                    "description": "Related problem ticket ID (optional, must exist if provided). Updatable, can be set to null."
                                }
                            }
                        },
                        "change_id": {
                            "type": "string",
                            "description": "The unique identifier of the change request to update. Required for 'update' action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# Policy:
# **Incident Management Policy & SOPs**

The current time is 2025-10-04 12:00:00 UTC

## **Introduction**

This document defines the operational guide for an Incident Management automation agent. It is designed for single-turn execution: each procedure must be self-contained and completed in one interaction.

**Validation first**: All inputs must be validated. If any required element is missing or invalid, the process halts with a clear error message.

**Logging**: Every INSERT, UPDATE, or DELETE operation must generate an audit_log entry with entity_type, entity_id, operation_type, changed_by_id, field_name, old_value, and new_value. .

**Role-based permissions**: Only designated roles may perform an action; other roles may do so only with explicit approval from a role authorized to perform it.

### **What is "Halt"?**

When a process halts, the agent immediately stops execution of the current SOP and returns a message to the user that says "cannot continue the process" \- therefore no further steps within that SOP are performed. The agent will use the **transfer_to_human** tool to transfer the request to a human agent.

## **Standard Operating Procedures**

### **Entities Lookup / Discovery**

Use this whenever you need to find, search, or verify entities; fetch details for validation or reporting; or when another SOP needs entity information first.

1. **Obtain:**  
* **Required**: entity_type  
* **Optional**: Include any filters for that entity (e.g., ID, status, dates) used to narrow the search.  
2. **Pick one discovery tool that matches the entity type:**  
* For clients, call **discover_clients** (filter by client_id, client_name, client_type, industry, country, status)  
* For **vendors**, call **discover_vendors** (filter by vendor_id, vendor_name, vendor_type, status)  
* For **users**, call **discover_users**  (filter by user_id, email, role, client_id, vendor_id, status)  
* For **products**, call **discover_products**  (filter by product_id, product_name, product_type, version, vendor_support_id, status)  
* For **infrastructure components**, call **discover_components** (filter by component_id, product_id, component_name, component_type, environment, location, port_number, status)  
* For **client subscriptions,** **sla agreements** call **discover_subscription_agreements** (filter by subscription_id, client_id, product_id, subscription_type, start_date, end_date, sla_tier, rto_hours, status, sla_id, subscription_id, severity_level, response_time_minutes, resolution_time_hours, availability_percentage).  
* For **incidents, post incident reviews** call **discover_incident_entities** (filter by incident_id, incident_code, client_id, component_id, reporter_id, assigned_manager_id, severity, status, category, detection_source, detected_at, impact, urgency).  
* For **workarounds**, call **discover_workaround_entities** (filter by workaround_id, incident_id, implemented_by_id, effectiveness, status, implemented_at)  
* For **root cause analysis**, call **discover_rca_entities** (filter by rca_id, incident_id, analysis_method, conducted_by_id, completed_at, status)  
* For **escalations**, call **discover_escalation_entities** (filter by escalation_id, escalation_code, incident_id, escalated_by_id, escalated_to_id, escalation_reason, escalation_level, escalated_at, acknowledged_at, resolved_at, status)  
* For **change requests, rollback requests**, call **discover_change_entities** (filter by change_id, change_code, rollback_id, incident_id, requested_by_id, approved_by_id, change_type, status)  
* For **metrics**, call **discover_metrics_entities** (filter by metric_id, incident_id, metric_type, value_minutes, target_minutes, recorded_at)  
* For **incident reports**, call **discover_incident_entities** (filter by report_id, incident_id, report_type, generated_by_id, generated_at, status)  
* For communications, call **discover_communication_entities** (filter by communication_id, incident_id, sender_id, recipient_id, recipient_type, communication_type, sent_at, delivery_status, pir_id, incident_id, facilitator_id, scheduled_date, timeline_accuracy_rating, communication_effectiveness_rating, technical_response_rating)  
* For **knowledge base articles**, call **discover_kb_article_entities** (filter by article_id, incident_id, created_by_id, reviewed_by_id, article_type, category, view_count, status)  
3. **Run the selected discovery tool and wait for the results.**  
4. **Acquire the result** \- whether it is a single match, multiple matches, or none.

**Halt, and use transfer_to_human if any of these occur:**

* The entity_type is missing or invalid  
* The requester is not authorized  
* The discovery tool fails to execute

---

## **Client Management Operations**

### **Create Client Record**

1. **Obtain:**  
* **Required**: client_name, client_type (enterprise, mid_market, small_business, startup), country  
* **Optional**: registration_number, contact_email, industry, status (active, inactive, suspended)  
* **Validate** that client_name and registration_number (if provided) are unique using **discover_clients**.  
2. **Create** the client record using **manage_clients**.  
3. **Create** an audit entry for client creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Client name or registration number already exists  
* Invalid client_type or country  
* Client creation failed  
* Audit trail logging failure

---

### **Update Client Information**

**1.   Obtain:**

* **Required**: client_id  
* **Optional**: client_name, registration_number, contact_email, client_type (enterprise, mid_market, small_business, startup), industry, country, status (active, inactive, suspended) (at least one must be provided)  
* **Validate** that client exists and is accessible to the user using **discover_clients**.

2**. Verify** that the approval to conduct the action is present using **check_approval**    (system_administrator or incident_manager or account_manager approval required). 

**3. If updating** client_name or registration_number, validate uniqueness using **discover_clients**.

**4. Update** the client record using **manage_clients**.

**5. Create** an audit entry for client update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Client not found  
* User not authorized for client updates  
* New client_name or registration_number already exists  
* Invalid client_type or status  
* Client update failed  
* Audit trail logging failure

---

**User Management Operations**

### **Create User Account**

1. **Obtain:**  
* **Required**: first_name, last_name, email, role (incident_manager, technical_support, account_manager, executive, vendor_contact, system_administrator, client_contact), timezone  
* **Optional**: phone, department, client_id, vendor_id, status (active, inactive, on_leave)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager approval required).  
3. **Validate** that email is unique using **discover_users**.  
4. **If client_id provided**, validate that client exists and has active status using **discover_clients**.  
5. **If vendor_id provided**, validate that vendor exists and has active status using **discover_vendors**.  
6. **Create** the user account using **manage_users**.  
7. **Create** an audit entry for user creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Email already exists  
* Client or vendor not found or inactive  
* Invalid role or timezone  
* Approval missing for elevated role creation  
* User creation failed  
* Audit trail logging failure

---

### **Update User Information**

1. **Obtain:**  
* **Required**: user_id  
* **Optional**: first_name, last_name, email, phone, role (incident_manager, technical_support, account_manager, executive, vendor_contact, system_administrator, client_contact), department, client_id, vendor_id, timezone, status (active, inactive, on_leave) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager approval required).  
3. **Validate** that user exists using **discover_users**.  
4. **If updating email**, validate uniqueness using **discover_users**.  
5. **Update** the user record using **manage_users**.  
6. **Create** an audit entry for user update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing approval for updating user information  
* User not found  
* New email already exists  
* Invalid role or status  
* Approval missing for role elevation  
* User update failed  
* Audit trail logging failure

---

## **Vendor Management Operations**

### **Create Vendor Record**

1. **Obtain:**  
* **Required**: vendor_name, vendor_type (cloud_provider, payment_processor, software_vendor, infrastructure_provider, security_vendor)  
* **Optional**: contact_email,,contact_phone, status (active, inactive, suspended).  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager or executive approval required)  
3. **Validate** that vendor_name is unique using **discover_vendors**.  
4. **Create** the vendor record using **manage_vendors**.  
5. **Create** an audit entry for vendor creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for vendor creation  
* Missing or invalid inputs  
* Vendor name already exists  
* Invalid vendor_type  
* Vendor creation failed  
* Audit trail logging failure

---

### **Update Vendor Information**

1. **Obtain:**  
* **Required**: vendor_id  
* **Optional**: vendor_name, vendor_type (cloud_provider, payment_processor, software_vendor, infrastructure_provider, security_vendor), contact_email, contact_phone, status (active, inactive, suspended) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager or executive approval required).  
3. **Validate** that vendor exists using **discover_vendors**.  
4. **If updating vendor_name**, validate uniqueness using **discover_vendors**.  
5. **Update** the vendor record using **manage_vendors**.  
6. **Create** an audit entry for vendor update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for vendor update  
* Vendor not found  
* New vendor_name already exists  
* Invalid vendor_type or status  
* Vendor update failed  
* Audit trail logging failure

---

## **Product and Infrastructure Operations**

### **Create Product Record**

1. **Obtain:**  
* **Required**: product_name, product_type (payment_processing, banking_system, api_gateway, data_integration, reporting_platform, security_service, backup_service, monitoring_tool)  
* **Optional**: version, vendor_support_id, status (active, deprecated, maintenance)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager or executive approval required)  
3. **Validate** that product_name is unique using **discover_products**.  
4. **If vendor_support_id provided**, validate that vendor exists and has active status using **discover_vendors**.  
5. **Create** the product record using **manage_products**.  
6. **Create** an audit entry for product creation using **log_audit_records**

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Product name already exists  
* Vendor not found or inactive  
* Invalid product_type  
* Product creation failed  
* Audit trail logging failure

## **Update Product Record**

1. **Obtain:**  
* **Required**: product_id  
* **Optional**: product_name, product_type (payment_processing, banking_system, api_gateway, data_integration, reporting_platform, security_service, backup_service, monitoring_tool), version, vendor_support_id, status (active, deprecated, maintenance) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager or executive approval required).  
3. **Validate** that product exists using **discover_products**.  
4. **If updating product_name**, validate uniqueness using **discover_products**.  
5. **If updating vendor_support_id**, validate that vendor exists and has active status using **discover_vendors**.  
6. **Update** the product record using **manage_products**.  
7. **Create** an audit entry for product update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for product update  
* Product not found  
* New product_name already exists  
* Vendor not found or inactive (if updating vendor_support_id)  
* Invalid product_type or status  
* Product update failed  
* Audit trail logging failure

---

## **Create Infrastructure Component**

1. **Obtain:**  
* **Required**: component_name, component_type (sftp_server, api_endpoint, database, load_balancer, firewall, authentication_service, payment_gateway, file_storage, monitoring_system), environment (production, staging, development, test)  
* **Optional**: product_id, location, port_number, status (online, offline, maintenance, degraded)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or technical_support or incident_manager approval required).  
3. **Validate** that component_name is unique within the specified product using **discover_components**.  
4. **If product_id provided**, validate that product exists and has active status using **discover_products**.  
5. **Create** the infrastructure component using **manage_components**.  
6. **Create** an audit entry for component creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for component creation  
* Missing or invalid inputs  
* Product not found or inactive (if product_id specified)  
* Component name already exists within product  
* Invalid component_type, environment, or status  
* Component creation failed  
* Audit trail logging failure

## **Update Infrastructure Component**

1. **Obtain:**  
* **Required**: component_id  
* **Optional**: component_name, component_type (sftp_server, api_endpoint, database, load_balancer, firewall, authentication_service, payment_gateway, file_storage, monitoring_system), product_id, environment (production, staging, development, test), location, port_number, status (online, offline, maintenance, degraded) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or technical_support or incident_manager approval required).  
3. **Validate** that component exists using **discover_components**.  
4. **If updating component_name**, validate uniqueness within the specified product using **discover_components**.  
5. **If updating product_id**, validate that product exists and has active status using **discover_products**.  
6. **Update** the infrastructure component using **manage_components**.  
7. **Create** an audit entry for component update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for component update  
* Component not found  
* Product not found or inactive (if updating product_id)  
* New component_name already exists within product  
* Invalid component_type, environment, or status  
* Component update failed  
* Audit trail logging failure

---

## **Subscription and Service Level Management**

### **Create Client Subscription**

1. **Obtain:**  
* **Required**: client_id, product_id, subscription_type (full_service, limited_service, trial, custom), start_date, sla_tier (premium, standard, basic), rto_hours  
* **Optional**: end_date, status (active, expired, cancelled, suspended)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (account_manager or incident_manager or executive approval required).  
3. **Validate** that client exists and has active status using **discover_clients**.  
4. **Validate** that product exists and has active status using **discover_products**.  
5. **Create** the subscription record using **manage_client_subscriptions**.  
6. **Create** an audit entry for subscription creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for subscription creation  
* Missing or invalid inputs  
* Client not found or inactive  
* Product not found or inactive  
* Invalid subscription_type, sla_tier, or rto_hours  
* Subscription creation failed  
* Audit trail logging failure

---

### **Update Client Subscription**

1. **Obtain:**  
* **Required**: subscription_id  
* **Optional**: subscription_type (full_service, limited_service, trial, custom), start_date, end_date, sla_tier (premium, standard, basic), rto_hours, status (active, expired, cancelled, suspended) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (account_manager or incident_manager or executive approval required).  
3. **Validate** that subscription exists using **discover_subscription_agreements**.  
4. **Update** the subscription record using **manage_client_subscriptions**.  
5. **Create** an audit entry for subscription update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for subscription update  
* Subscription not found  
* Invalid subscription_type, sla_tier, status, or dates  
* Subscription update failed  
* Audit trail logging failure

---

### **Create SLA Agreement**

1. **Obtain:**  
* **Required**: subscription_id, severity_level (P1, P2, P3, P4), response_time_minutes, resolution_time_hours  
* **Optional**: availability_percentage  
2. **Verify** that the approval to conduct the action is present using **check_approval** (account_manager or system_administrator or executive approval required).  
3. **Validate** that subscription exists and has active status using **discover_subscription_agreements**.  
4. **Validate** that response and resolution times align with subscription tier using the following guidelines:  
* **Premium tier**: P1: 15-30 min response, 2-4 hrs resolution; P2: 1-2 hrs response, 8-24 hrs resolution; P3: 4-8 hrs response, 48-72 hrs resolution; P4: 24-48 hrs response, 128 hrs resolution  
* **Standard tier**: P1: 1-2 hrs response, 8-24 hrs resolution; P2: 4-8 hrs response, 24-48 hrs resolution; P3: 24 hrs response, 72-120 hrs resolution; P4: 48-72 hrs response, 168 hrs resolution  
* **Basic tier**: P1: 4-8 hrs response, 24-48 hrs resolution; P2: 24 hrs response, 72-120 hrs resolution; P3: 48-72 hrs response, 5-10 days resolution; P4: 5-7 days response, 2 weeks resolution  
5. **Create** the SLA agreement using **manage_sla_agreements**.  
6. **Create** an audit entry for SLA creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for SLA creation  
* Missing or invalid inputs  
* Subscription not found or inactive  
* Response/resolution times don't align with subscription tier  
* Invalid severity_level or availability_percentage  
* SLA creation failed  
* Audit trail logging failure

### **Update SLA Agreement**

1. **Obtain:**  
* **Required**: sla_id  
* **Optional**: severity_level (P1, P2, P3, P4), response_time_minutes, resolution_time_hours, availability_percentage (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (account_manager or system_administrator or executive approval required).  
3. **Validate** that SLA agreement exists using **discover_subscription_agreements**.  
4. **Retrieve** the associated subscription to determine subscription tier.  
5. **If updating response_time_minutes or resolution_time_hours**, validate that new times align with subscription tier using the following guidelines:  
* **Premium tier**: P1: 15-30 min response, 2-4 hrs resolution; P2: 1-2 hrs response, 8-24 hrs resolution; P3: 4-8 hrs response, 48-72 hrs resolution; P4: 24-48 hrs response, 128 hrs resolution  
* **Standard tier**: P1: 1-2 hrs response, 8-24 hrs resolution; P2: 4-8 hrs response, 24-48 hrs resolution; P3: 24 hrs response, 72-120 hrs resolution; P4: 48-72 hrs response, 168 hrs resolution  
* **Basic tier**: P1: 4-8 hrs response, 24-48 hrs resolution; P2: 24 hrs response, 72-120 hrs resolution; P3: 48-72 hrs response, 5-10 days resolution; P4: 5-7 days response, 2 weeks resolution  
6. **Update** the SLA agreement using **manage_sla_agreements**.  
7. **Create** an audit entry for SLA update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for SLA update  
* SLA agreement not found  
* Response/resolution times don't align with subscription tier  
* Invalid severity_level or availability_percentage  
* SLA update failed  
* Audit trail logging failure

---

## **Incident Operations**

### **Create Incident**

1. **Obtain:**  
* **Required**: title, reporter_id, client_id, category (system_outage, performance_degradation, security_incident, data_corruption, integration_failure, network_issue, hardware_failure, software_bug, configuration_error, capacity_issue, backup_failure, authentication_failure, api_error, database_issue, service_unavailable) , impact (critical, high, medium, low), detection_source(client_reported,internally_detected, monitoring_alert,vendor_reported,scheduled_maintenance,emergency_maintanence), urgency (critical, high, medium, low), detected_at  
* Optional: assigned_manager_id, component_id, severity(P1,P2,P3,P4), status(open,in_progress,resolved,closed) , is_recurring,downtime_minutes,sla_breach,rto_breach,closed_at,resolved_at  
2. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or technical_support or system_administrator or executive approval required).  
3. **Validate** that reporter exists and has active status using **discover_users**.  
4. **Validate** that client exists and has active status using **discover_clients**.  
5. **If component_id provided**, validate that component exists using **discover_products**.  
6. **If assigned_manager_id provided**, validate that user exists using **discover_users**.  
7. **Create** the incident record using **manage_incidents.**  
8. **Create** an audit entry for incident creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for creating an incident  
* Missing or invalid inputs  
* Reporter not found or inactive  
* Client not found or inactive  
* Component not found  
* Assigned manager not found  
* Invalid category, impact, urgency, or severity  
* Incident creation failed  
* Audit trail logging failure

---

### **Update Incident**

1. **Obtain:**  
* **Required**: incident_id  
2. **Optional**: title,incident_code, assigned_manager_id, component_id, severity (P1, P2, P3, P4), status (open, in_progress, resolved, closed), impact (critical, high, medium, low), urgency (critical, high, medium, low), category (system_outage, performance_degradation, security_incident, data_corruption, integration_failure, network_issue, hardware_failure, software_bug, configuration_error, capacity_issue, backup_failure, authentication_failure, api_error, database_issue, service_unavailable), detection_source (client_reported, internally_detected, monitoring_alert, vendor_reported, scheduled_maintenance, emergency_maintenance), resolved_at, closed_at, rto_breach, sla_breach, is_recurring, downtime_minutes (at least one must be provided)  
3. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or technical_support or system_administrator or executive approval required)  
4. **Validate** that incident exists using **discover_incident_entities**.  
5. **If updating assigned_manager_id**, validate that user exists using **discover_users**.  
6. **Update** the incident record using **manage_incidents**.  
7. **Create** an audit entry for incident update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing to update incident  
* Incident not found  
* Assigned manager not found or has invalid role  
* Invalid severity, impact, urgency, category, or timestamps  
* Incident update failed  
* Audit trail logging failure

---

### **Resolve Incident**

1. **Obtain:**  
* **Required**: incident_id  
2. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or technical_support or executive approval required)  
3. **Validate** that incident exists and has status of in_progress or open using **discover_incident_entities**.  
4. **Update** incident status to resolved and set resolved_at timestamp using **manage_incidents**.  
5. **Create** an audit entry for incident resolution using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing approval to resolve incident  
* Incident not found or invalid status  
* Report generation failed  
* Incident resolution update failed  
* Audit trail logging failure

---

### **Close Incident**

1. **Obtain:**  
* **Required**: incident_id  
2. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or executive approval required).  
3. **Validate** that incident exists and has status of resolved using **discover_incident_entities**.  
4. **Update** incident status to closed and set closed_at timestamp using **manage_incidents**.  
5. **Create** an audit entry for incident closure using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing to close incident  
* Incident not found or status not resolved  
* Incident closure failed  
* Audit trail logging failure

---

## **Communication Management**

### **Create Communication**

1. **Obtain:**  
* **Required**: incident_id, sender_id, recipient_id, recipient_type (client, internal_team, executive, vendor, regulatory), communication_type (email, sms, phone_call, status_page, portal_update)  
* **Optional**: delivery_status (sent, delivered, failed, pending), sent_at  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( incident_manager or technical_support or system_administrator or account_manager approval required).  
3. **Validate** that incident exists using **discover_incident_entities**.  
4. **Validate** that sender and recipient exists and has active status using **discover_users**.  
5. **Create** the communication record using **manage_communications**.  
6. **Create** an audit entry for communication using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing approval  for creating communication record  
* Missing or invalid inputs  
* Incident not found  
* Sender not found or inactive  
* Recipient not found (if specified)  
* Invalid recipient_type or communication_type  
* Communication recording failed  
* Audit trail logging failure

## **Update Communication**

1. **Obtain:**  
* **Required**: communication_id  
* **Optional**: incident_id, sender_id, recipient_id, recipient_type (client, internal_team, executive, vendor, regulatory), communication_type (email, sms, phone_call, status_page, portal_update), delivery_status (sent, delivered, failed, pending), sent_at (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( incident_manager or technical_support or system_administrator or account_manager approval required).  
3. **Validate** that communication record exists using **discover_communication_entities**.  
4. If updating incident_id, sender_id, or recipient_id, validate that the communication record has delivery_status of "pending" using **discover_communication_entities**. These fields can only be updated when delivery_status is "pending".  
5. **If updating incident_id**, validate that incident exists using **discover_incident_entities**.  
6. **If updating sender_id**, validate that sender exists and has active status using **discover_users**.  
7. **If updating recipient_id**, validate that recipient exists using **discover_users**.  
8. **Update** the communication record using **manage_communications**.  
9. **Create** an audit entry for communication update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing to update communication record  
* Communication record not found  
* Incident not found (if updating incident_id)  
* Sender not found or inactive (if updating sender_id)  
* Recipient not found (if updating recipient_id)  
* Invalid recipient_type, communication_type, or delivery_status  
* Communication update failed  
* Audit trail logging failure

---

## **Workaround and Resolution Management**

### **Create Workaround**

1. **Obtain:**  
* **Required**: incident_id, implemented_by_id, effectiveness (complete, partial, minimal),implemented_at  
* **Optional**: status (active, inactive, replaced)   
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that incident exists and has status of open or in_progress using **discover_incident_entities**.  
4. **Create** the workaround record using **manage_work_arounds**.  
5. **Create** an audit entry for workaround implementation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Incident not found or invalid status  
* Implementing user not found or has invalid role  
* Invalid effectiveness level  
* Workaround creation failed  
* Audit trail logging failure

---

## **Update Workaround**

1. **Obtain:**  
* **Required**: workaround_id  
* **Optional**: effectiveness (complete, partial, minimal), status (active, inactive, replaced) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that workaround record exists using **discover_workaround_entities**.  
4. **Update** the workaround record using **manage_work_arounds**.  
5. **Create** an audit entry for workaround update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for workaround update  
* Workaround not found  
* Invalid effectiveness level or status  
* Workaround update failed  
* Audit trail logging failure

---

### **Conduct Root Cause Analysis**

1. **Obtain:**  
* **Required**: incident_id, conducted_by_id, analysis_method (five_whys, fishbone, timeline_analysis, fault_tree)  
* **Optional**: completed_at, status (in_progress, completed, approved)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that incident exists and has status of resolved or closed using **discover_incident_entities**.  
4. **Create** the root cause analysis record using **manage_root_cause_analysis**.  
5. **Create** an audit entry for RCA initiation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for conduct root cause analysis  
* Missing or invalid inputs  
* Incident not found or invalid status  
* Invalid analysis_method  
* RCA creation failed  
* Audit trail logging failure

---

### **Update Root Cause Analysis**

1. **Obtain:**  
* **Required**: rca_id  
* **Optional**: analysis_method (five_whys, fishbone, timeline_analysis, fault_tree), completed_at, status (in_progress, completed, approved) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that RCA record exists using **discover_rca_entities**.  
4. **Update** the RCA record using **manage_root_cause_analysis**.  
5. **Create** an audit entry for RCA update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for updating rca  
* RCA not found  
* Invalid analysis_method or status  
* RCA update failed  
* Audit trail logging failure

---

## **Escalation Management**

### **Create Escalation**

1. **Obtain:**  
* **Required**: incident_id, escalated_by_id, escalated_to_id, escalation_reason (sla_breach, severity_increase, resource_unavailable, executive_request, client_demand), escalated_at ,escalation_level (technical, management, executive, vendor)  
* **Optional**: acknowledged_at, resolved_at, status (open, acknowledged, resolved)  
2. **Validate** that incident exists and has status of open or in_progress using **discover_incident_entities**.  
3. **Validate** that escalated_by and escalated_to  user exists and has active status using **discover_users**.  
4. **Create** the escalation record using **manage_escalations**.  
5. **Create** an audit entry for escalation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Incident not found or invalid status  
* Escalating user not found or inactive  
* Escalation target user not found or has invalid role for level  
* Invalid escalation_reason or escalation_level  
* Escalation creation failed  
* Audit trail logging failure

---

### **Update Escalation Status**

1. **Obtain:**  
* **Required**: escalation_id  
* **Optional**: escalation_code, acknowledged_at, resolved_at, status (open, acknowledged, resolved) (at least one must be provided)  
2. **Validate** that escalation exists using **discover_escalation_entities**.  
3. **Update** the escalation record using **manage_escalations**.  
4. **Create** an audit entry for escalation update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Escalation not found  
* User not authorized to update escalation  
* Invalid status or timestamps  
* Escalation update failed  
* Audit trail logging failure

---

## **Change Management Operations**

### **Create Change Request**

1. **Obtain:**  
* **Required**: title, change_type (emergency, standard, normal), requested_by_id, risk_level (high, medium, low)  
* **Optional**: incident_id, approved_by_id, scheduled_start, scheduled_end, actual_start, actual_end, status (requested, approved, scheduled, in_progress, completed, failed, rolled_back)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required)..  
3. **If incident_id provided**, validate that incident exists using **discover_incident_entities**  
4. **Create** the change request record using **manage_change_requests**.  
5. **Create** an audit entry for change request using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing Approval for creating a change request  
* Missing or invalid inputs  
* Incident not found (if specified)  
* Invalid change_type, risk_level, or status  
* Change request creation failed  
* Audit trail logging failure

---

### **Update Change Request**

1. **Obtain:**  
* **Required**: change_id  
* **Optional**: title,change_code, change_type (emergency, standard, normal), approved_by_id, risk_level (high, medium, low), scheduled_start, scheduled_end, actual_start, actual_end, status (requested, approved, scheduled, in_progress, completed, failed, rolled_back) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that change request exists using **discover_change_entities**.  
4. **Update** the change request using **manage_change_requests**.  
5. **Create** an audit entry for change update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for update change request  
* Change request not found  
* User not authorized  
* Invalid change_type, risk_level, status, or timestamps  
* Change request update failed  
* Audit trail logging failure

---

### **Create Rollback Request**

1. **Obtain:**  
* **Required**: change_id, requested_by_id  
* **Optional**: incident_id, approved_by_id, executed_at, validation_completed, status (requested, approved, in_progress, completed, failed).  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or executive approval required)  
3. **Validate** that change request exists using **discover_change_entities**.  
4. **If incident_id provided**, validate that incident exists using **discover_incident_entities**.  
5. **Create** the rollback request using **manage_rollback_requests**.  
6. **Create** an audit entry for rollback request using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for rollback request  
* Missing or invalid inputs  
* Change request not found  
* Requesting user not found or has invalid role  
* Incident not found (if specified)  
* Rollback request creation failed  
* Audit trail logging failure

---

### **Update Rollback Request**

1. **Obtain:**  
* **Required**: rollback_id  
* **Optional**: rollback_code , approved_by_id, executed_at, validation_completed, status (requested, approved, in_progress, completed, failed) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (  incident_manager or system_administrator or executive approval required).  
3. **Validate** that rollback request exists using **discover_change_entities**.  
4. **Update** the rollback request using **manage_rollback_requests**.  
5. **Create** an audit entry for rollback update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing Approval for rollback request  
* Rollback request not found  
* User not authorized  
* Invalid status or timestamps  
* Rollback update failed  
* Audit trail logging failure

---

## **Metrics and Reporting Operations**

### **Record Performance Metrics**

1. **Obtain:**  
* **Required**: incident_id, metric_type (MTTA, MTTD, MTTR, MTTM, FTR), value_minutes  
* **Optional**: target_minutes, recorded_at  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( incident_manager or system_administrator approval required).  
3. **Validate** that incident exists and has status of resolved or closed using **discover_incident_entities**.  
4. **Create** the metrics record using **manage_metrics**.  
5. **Create** an audit entry for metrics recording using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Incident not found or invalid status  
* User not authorized  
* Invalid metric_type or value_minutes  
* Metrics recording failed  
* Audit trail logging failure

---

### **Generate Incident Report**

1. **Obtain:**  
* **Required**: incident_id, report_type ( executive_summary, technical_details,business_impact, compliance_report, post_mortem), generated_by_id  
* **Optional**: status (draft, completed, distributed)  
2. **Validate** that generating user exists and has appropriate role (incident_manager, executive) using **discover_users**..  
3. **Generate** the report using **manage_incident_reports**.  
4. **Create** an audit entry for report generation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing approval for generating report  
* Missing or invalid inputs  
* Invalid report_type or status  
* Incident not resolved/closed for post_mortem  
* Report generation failed  
* Audit trail logging failure

---

## **Knowledge Management Operations**

### **Create Knowledge Base Article**

1. **Obtain:**  
* **Required**: title, article_type (troubleshooting, resolution_steps, prevention_guide, faq), created_by_id, category(authentication_issues, payment_processing, api_integration, data_synchronization, system_outages, performance_degradation, security_incidents, backup_recovery, user_management, billing_issues, compliance_procedures, vendor_escalations, configuration_changes, monitoring_alerts, network_connectivity, database_issues, file_transfer_problems, reporting_errors, mobile_app_issues, browser_compatibility, third_party_integrations, scheduled_maintenance, emergency_procedures, client_onboarding, account_provisioning, sla_management, incident_response, change_management, capacity_planning, disaster_recovery)  
* **Optional**: incident_id, reviewed_by_id, view_count, status (draft, published, archived)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager approval required).  
3. **If incident_id provided**, validate that incident exists and is resolved or closed using **discover_incident_entities**.  
4. **If reviewed_by_id provided**, validate that reviewer exists and has appropriate role using **discover_users**.  
5. **Create** the knowledge base article using **manage_kb_articles**.  
6. **Create** an audit entry for article creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Creating user not found or has invalid role  
* Incident not found or invalid status (if specified)  
* Reviewer not found (if specified)  
* Invalid article_type, category, or status  
* Knowledge article creation failed  
* Audit trail logging failure

---

### **Update Knowledge Base Article**

1. **Obtain:**  
* **Required**: article_id  
* **Optional**: title, article_type (troubleshooting, resolution_steps, prevention_guide, faq), incident_id, reviewed_by_id, category, view_count, status (draft, published, archived) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager approval required).  
3. **Validate** that article exists using **discover_kb_article_entities**.  
4. **If updating reviewed_by_id**, validate that reviewer exists using **discover_users**.  
5. **Update** the knowledge article using **manage_kb_articles**.  
6. **Create** an audit entry for article update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Article not found  
* User not authorized  
* Reviewer not found (if specified)  
* Invalid article_type, category, or status  
* Article update failed  
* Audit trail logging failure

---

### **Create Post-Incident Review**

1. **Obtain:**  
* **Required**: incident_id, scheduled_date, facilitator_id  
* **Optional**: timeline_accuracy_rating, communication_effectiveness_rating, technical_response_rating, status (scheduled, completed, cancelled)   
2. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or executive approval required).  
3. **Validate** that incident exists and has status of resolved or closed using **discover_incident_entities**.  
4. **Validate** that facilitator exists and has an appropriate role (incident_manager, executive) using **discover_users**.  
5. **Create** the post-incident review record using **manage_post_incident_reviews**.  
6. **Create** an audit entry for PIR creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for PIR creation  
* Missing or invalid inputs  
* Incident not found or invalid status  
* Facilitator not found or has invalid role  
* Invalid scheduled_date or ratings  
* PIR creation failed  
* Audit trail logging failure

---

### **Update Post-Incident Review**

1. **Obtain:**  
* **Required**: pir_id  
* **Optional**: scheduled_date, facilitator_id, timeline_accuracy_rating, communication_effectiveness_rating, technical_response_rating, status (scheduled, completed, cancelled) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( incident_manager or executive approval required).  
3. **Validate** that PIR exists using **discover_incident_entities**..  
4. **Update** the post-incident review using **manage_post_incident_review**.  
5. **Create** an audit entry for PIR update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing  
* PIR not found  
* User not authorized  
* Invalid scheduled_date, ratings, or status  
* PIR update failed  
* Audit trail logging failure

---

## **Authority and Access Controls**

**Permission Validation**

All operations verify user authority based on:

* **role** field (incident_manager, technical_support, account_manager, executive, vendor_contact, system_administrator, client_contact)  
* **client_id** association through client_id field in users table  
* **vendor_id** association through vendor_id field in users table  
* **status** field must be active in users table

Operations requiring elevated permissions use a check_approval tool to verify proper authorization before proceeding.

# Database Schema:
// Use DBML to define your database structure
// Docs: https://dbml.dbdiagram.io/docs

// B2B Incident Management Database Schema
// This schema represents a comprehensive database for managing incidents,
// clients, products, infrastructure, and operational processes

Table clients {
  client_id string [primary key]
  client_name varchar(100) [not null]
  registration_number varchar(100)
  contact_email string
  client_type enum('enterprise','mid_market','small_business','startup') [not null]
  industry varchar(100)
  country varchar(100)
  status enum('active','inactive','suspended') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table vendors {
  vendor_id string [primary key]
  vendor_name varchar(100) [not null]
  vendor_type enum('cloud_provider','payment_processor','software_vendor','infrastructure_provider','security_vendor') [not null]
  contact_email varchar(100)
  contact_phone varchar(20)
  // escalation_contact varchar(100)
  status enum('active','inactive','suspended') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table users {
  user_id string [primary key]
  client_id string
  vendor_id string
  first_name varchar(100) [not null]
  last_name varchar(100) [not null]
  email varchar(320) [not null, unique]
  phone varchar(20)
  role enum('incident_manager','technical_support', 'account_manager','executive','vendor_contact','system_administrator', 'client_contact') [not null]
  department varchar(100)
  timezone varchar(50) [not null]
  status enum('active','inactive','on_leave') [not null, default: 'active']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table products {
  product_id string [primary key]
  product_name varchar(100) [not null]
  product_type enum('payment_processing','banking_system','api_gateway','data_integration','reporting_platform','security_service','backup_service','monitoring_tool') [not null]
  version varchar(50)
  vendor_support_id string // references vendors.vendor_id
  // internal_team_lead_id string // references users.user_id
  status enum('active','deprecated','maintenance') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table infrastructure_components {
  component_id string [primary key]
  product_id string
  component_name varchar(100) [not null]
  component_type enum('sftp_server','api_endpoint','database','load_balancer','firewall','authentication_service','payment_gateway','file_storage','monitoring_system') [not null]
  environment enum('production','staging','development','test') [not null]
  location varchar(100)
  port_number int
  status enum('online','offline','maintenance','degraded') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table client_subscriptions {
  subscription_id string [primary key]
  client_id string [not null]
  product_id string [not null]
  subscription_type enum('full_service','limited_service','trial','custom') [not null]
  start_date date [not null]
  end_date date
  sla_tier enum('premium','standard','basic') [not null]
  rto_hours int [not null] // Recovery Time Objective
  status enum('active','expired','cancelled','suspended') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table sla_agreements {
  sla_id string [primary key]
  subscription_id string [not null]
  severity_level enum('P1','P2','P3','P4') [not null]
  response_time_minutes int [not null]
  resolution_time_hours int [not null]
  availability_percentage decimal(5,2)
  created_at timestamp [not null, default: `NOW()`]
}

Table incidents {
  incident_id string [primary key]
  incident_code varchar(50) [unique, not null] // e.g., 'INC-2024-00123', 'INCIDENT-001234'
  title varchar(100) [not null]
  reporter_id string [not null]
  assigned_manager_id string
  client_id string [not null]
  component_id string
  // vendor_id string // For vendor-related incidents
  // vendor_ticket_id varchar(100) // Vendor's ticket reference
  // vendor_status varchar(100) // Status from vendor side
  // vendor_estimated_resolution timestamp // Vendor's ETA
  severity enum('P1','P2','P3','P4') [not null]
  status enum('open','in_progress','resolved','closed') [not null]
  impact enum('critical','high','medium','low') [not null]
  urgency enum('critical','high','medium','low') [not null]
  // category enum('client_onboarding','client_support','client_escalation','data_update','system_outage','security_breach','performance_issue','integration_failure','vendor_issue') [not null]
  
  // Technical categories - WHAT went wrong
  category enum(
    'system_outage',
    'performance_degradation',
    'security_incident',
    'data_corruption',
    'integration_failure',
    'network_issue',
    'hardware_failure',
    'software_bug',
    'configuration_error',
    'capacity_issue',
    'backup_failure',
    'authentication_failure',
    'api_error',
    'database_issue',
    'service_unavailable'
  ) [not null]
  
  // Business/operational context - WHO is affected and WHY it matters
  detection_source enum(
    'client_reported',
    'internally_detected',
    'monitoring_alert',
    'vendor_reported',
    'scheduled_maintenance',
    'emergency_maintenance'
  ) [not null]
  
  detected_at timestamp [not null]
  resolved_at timestamp
  closed_at timestamp
  rto_breach boolean [default: false]
  sla_breach boolean [default: false]
  is_recurring boolean [default: false]
  downtime_minutes int
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

// Table incident_updates {
//   update_id string [primary key]
//   incident_id string [not null]
//   updated_by_id string [not null]
//   update_type enum('status_change','severity_change','assignment','workaround','resolution','communication') [not null]
//   field_name varchar(50) [not null]
//   old_value varchar(100)
//   new_value varchar(100)
//   created_at timestamp [not null, default: `NOW()`]
// }

Table audit_log {
  audit_id string [primary key]
  entity_type varchar(100) [not null] // Which table was modified (e.g., 'incidents', 'clients', 'users')
  entity_id string [not null] // ID of the record that changed
  operation_type enum('INSERT','UPDATE','DELETE') [not null]
  changed_by_id string [not null] // User who made the change
  field_name varchar(100) // Specific field that changed (can be null for multi-field updates)
  old_value text // Previous value
  new_value text // New value
  created_at timestamp [not null, default: `NOW()`]
}

Table workarounds {
  workaround_id string [primary key]
  incident_id string [not null]
  implemented_by_id string [not null]
  effectiveness enum('complete','partial','minimal') [not null]
  status enum('active','inactive','replaced') [not null]
  implemented_at timestamp [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table root_cause_analysis {
  rca_id string [primary key]
  incident_id string [not null]
  analysis_method enum('five_whys','fishbone','timeline_analysis','fault_tree') [not null]
  conducted_by_id string [not null]
  completed_at timestamp
  status enum('in_progress','completed','approved') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table communications {
  communication_id string [primary key]
  incident_id string [not null]
  sender_id string [not null]
  recipient_id string
  recipient_type enum('client','internal_team','executive','vendor','regulatory') [not null]
  communication_type enum('email','sms','phone_call','status_page','portal_update') [not null]
  sent_at timestamp [not null]
  delivery_status enum('sent','delivered','failed','pending') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table escalations {
  escalation_id string [primary key]
  escalation_code varchar(50) [unique, not null] // e.g., 'ESC-2024-00789', 'ESCALATION-001234'
  incident_id string [not null]
  escalated_by_id string [not null]
  escalated_to_id string [not null]
  escalation_reason enum('sla_breach','severity_increase','resource_unavailable','executive_request','client_demand') [not null]
  escalation_level enum('technical','management','executive','vendor') [not null]
  escalated_at timestamp [not null]
  acknowledged_at timestamp
  resolved_at timestamp
  status enum('open','acknowledged','resolved') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table change_requests {
  change_id string [primary key]
  change_code varchar(50) [unique, not null] // e.g., 'CHG-2024-00456', 'CR-001234'
  incident_id string
  title varchar(100) [not null]
  change_type enum('emergency','standard','normal') [not null]
  requested_by_id string [not null]
  approved_by_id string
  risk_level enum('high','medium','low') [not null]
  scheduled_start timestamp
  scheduled_end timestamp
  actual_start timestamp
  actual_end timestamp
  status enum('requested','approved','scheduled','in_progress','completed','failed','rolled_back') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table rollback_requests {
  rollback_id string [primary key]
  rollback_code varchar(50) [unique, not null] // e.g., 'RBK-2024-00321', 'ROLLBACK-001234'
  change_id string [not null]
  incident_id string
  requested_by_id string [not null]
  approved_by_id string
  executed_at timestamp
  validation_completed boolean [default: false]
  status enum('requested','approved','in_progress','completed','failed') [not null]
  created_at timestamp [not null, default: `NOW()`]
}



// Vendor incidents are now handled directly in the incidents table
// with vendor_id and vendor_ticket_id fields

Table metrics {
  metric_id string [primary key]
  incident_id string [not null]
  metric_type enum('MTTA','MTTD','MTTR','MTTM','FTR') [not null]
  value_minutes int [not null]
  target_minutes int
  recorded_at timestamp [not null]
  created_at timestamp [not null, default: `NOW()`]
}

// Table compliance_events {
//   compliance_id string [primary key]
//   incident_id string [not null]
//   regulation_type enum('GDPR','HIPAA','SOX','PCI_DSS','FFIEC','CCPA','FCC','NERC') [not null]
//   event_type enum('breach_assessment','notification_required','reporting_deadline','audit_trigger') [not null]
//   deadline timestamp
//   completed_at timestamp
//   responsible_party_id string [not null]
//   status enum('pending','in_progress','completed','overdue') [not null]
//   created_at timestamp [not null, default: `NOW()`]
// }

Table incident_reports {
  report_id string [primary key]
  incident_id string [not null]
  report_type enum('executive_summary','technical_details','business_impact','compliance_report','post_mortem') [not null]
  generated_by_id string [not null]
  generated_at timestamp [not null]
  status enum('draft','completed','distributed') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table knowledge_base_articles {
  article_id string [primary key]
  // article_code varchar(50) [unique, not null] // e.g., 'KB-00741'
  incident_id string
  title varchar(100) [not null]
  article_type enum('troubleshooting','resolution_steps','prevention_guide','faq') [not null]
  created_by_id string [not null]
  reviewed_by_id string
  category enum(
    'authentication_issues',
    'payment_processing', 
    'api_integration',
    'data_synchronization',
    'system_outages',
    'performance_degradation',
    'security_incidents',
    'backup_recovery',
    'user_management',
    'billing_issues',
    'compliance_procedures',
    'vendor_escalations',
    'configuration_changes',
    'monitoring_alerts',
    'network_connectivity',
    'database_issues',
    'file_transfer_problems',
    'reporting_errors',
    'mobile_app_issues',
    'browser_compatibility',
    'third_party_integrations',
    'scheduled_maintenance',
    'emergency_procedures',
    'client_onboarding',
    'account_provisioning',
    'sla_management',
    'incident_response',
    'change_management',
    'capacity_planning',
    'disaster_recovery'
  )
  view_count int [default: 0]
  status enum('draft','published','archived') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table post_incident_reviews {
  pir_id string [primary key]
  incident_id string [not null]
  scheduled_date timestamp [not null]
  facilitator_id string [not null]
  timeline_accuracy_rating int
  communication_effectiveness_rating int
  technical_response_rating int
  status enum('scheduled','completed','cancelled') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

// Relationships
Ref: users.client_id > clients.client_id
Ref: users.vendor_id > vendors.vendor_id
// Ref: products.internal_team_lead_id > users.user_id
Ref: products.vendor_support_id > vendors.vendor_id
Ref: client_subscriptions.client_id > clients.client_id
Ref: client_subscriptions.product_id > products.product_id
Ref: sla_agreements.subscription_id > client_subscriptions.subscription_id
Ref: incidents.reporter_id > users.user_id
Ref: incidents.assigned_manager_id > users.user_id
Ref: incidents.client_id > clients.client_id
Ref: incidents.component_id > infrastructure_components.component_id
// Ref: incidents.vendor_id > vendors.vendor_id
// Ref: incident_updates.incident_id > incidents.incident_id
// Ref: incident_updates.updated_by_id > users.user_id
Ref: workarounds.incident_id > incidents.incident_id
Ref: workarounds.implemented_by_id > users.user_id
Ref: root_cause_analysis.incident_id > incidents.incident_id
Ref: root_cause_analysis.conducted_by_id > users.user_id
Ref: communications.incident_id > incidents.incident_id
Ref: communications.sender_id > users.user_id
Ref: escalations.incident_id > incidents.incident_id
Ref: escalations.escalated_by_id > users.user_id
Ref: escalations.escalated_to_id > users.user_id
Ref: change_requests.incident_id > incidents.incident_id
Ref: change_requests.requested_by_id > users.user_id
Ref: change_requests.approved_by_id > users.user_id
Ref: rollback_requests.change_id > change_requests.change_id
Ref: rollback_requests.incident_id > incidents.incident_id
Ref: rollback_requests.requested_by_id > users.user_id
Ref: rollback_requests.approved_by_id > users.user_id
Ref: metrics.incident_id > incidents.incident_id
// Ref: compliance_events.incident_id > incidents.incident_id
// Ref: compliance_events.responsible_party_id > users.user_id
Ref: incident_reports.incident_id > incidents.incident_id
Ref: incident_reports.generated_by_id > users.user_id
Ref: knowledge_base_articles.incident_id > incidents.incident_id
Ref: knowledge_base_articles.created_by_id > users.user_id
Ref: knowledge_base_articles.reviewed_by_id > users.user_id
Ref: post_incident_reviews.incident_id > incidents.incident_id
Ref: post_incident_reviews.facilitator_id > users.user_id
Ref: infrastructure_components.product_id > products.product_id

You have to provide the json file for each function separately including all the tests for that function in the actions part. You are going to provide the bash script that will create and populate those json files in a folder named tools_regression_tests/interface_3/.

Note: ids are just numeric strings "1", "2", ...
