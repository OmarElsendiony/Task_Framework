Assume you are an experienced tester. I am going to give you python functions and you are going to give me the inputs to test this function. The inputs are provided in the form of actions. You have to provide two tests for each function with the most number of parameters as possible (if applicable). However, you have to follow the format that I provide to you below.

# Format:
{
    "env": "hr_experts",
    "interface_num": 5,
    "task": {
        "actions": [
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            },
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            }
        ]
    }
}

where the name of action is the function name and the arguments are the parameters of the function. You have to provide multiple actions for a single file in a single test if applicable. 

# Functions:
import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverPayrollEntities(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover payroll entities.
        
        Supported entities:
        - payroll_records: Payroll records by payroll_id, employee_id, pay_period_start, pay_period_end, hours_worked, hourly_rate, payment_date, status, approved_by, created_at, updated_at
        - payroll_deductions: Payroll deductions by deduction_id, payroll_id, deduction_type, amount, created_by, created_at
        """
        if entity_type not in ["payroll_records", "payroll_deductions"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'payroll_records' or 'payroll_deductions'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        id_field = "payroll_id" if entity_type == "payroll_records" else "deduction_id"
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, id_field: entity_id})
            else:
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_payroll_entities",
                "description": "Discover payroll entities. Entity types: 'payroll_records' (payroll records; filterable by payroll_id (string), employee_id (string), pay_period_start (date), pay_period_end (date), hours_worked (decimal), hourly_rate (decimal), payment_date (date), status (enum: 'draft', 'approved', 'paid', 'cancelled'), approved_by (string), created_at (timestamp), updated_at (timestamp)), 'payroll_deductions' (payroll deductions; filterable by deduction_id (string), payroll_id (string), deduction_type (enum: 'tax', 'insurance', 'retirement', 'garnishment', 'equipment', 'other'), amount (decimal), created_by (string), created_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'payroll_records' or 'payroll_deductions'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For payroll_records, filters are: payroll_id (string), employee_id (string), pay_period_start (date), pay_period_end (date), hours_worked (decimal), hourly_rate (decimal), payment_date (date), status (enum: 'draft', 'approved', 'paid', 'cancelled'), approved_by (string), created_at (timestamp), updated_at (timestamp). For payroll_deductions, filters are: deduction_id (string), payroll_id (string), deduction_type (enum: 'tax', 'insurance', 'retirement', 'garnishment', 'equipment', 'other'), amount (decimal), created_by (string), created_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverPerformanceEntities(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover performance entities.
        
        Supported entities:
        - performance_reviews: Performance reviews by review_id, employee_id, reviewer_id, review_period_start, review_period_end, review_type, overall_rating, goals_achievement_score, communication_score, teamwork_score, leadership_score, technical_skills_score, status, created_at, updated_at
        """
        if entity_type not in ["performance_reviews"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'performance_reviews'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get("performance_reviews", {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "review_id": entity_id})
            else:
                results.append({**entity_data, "review_id": entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_performance_entities",
                "description": "Discover performance entities. Entity types: 'performance_reviews' (performance reviews; filterable by review_id (string), employee_id (string), reviewer_id (string), review_period_start (date), review_period_end (date), review_type (enum: 'annual', 'quarterly', 'probationary', 'project_based'), overall_rating (enum: 'exceeds_expectations', 'meets_expectations', 'below_expectations', 'unsatisfactory'), goals_achievement_score (decimal), communication_score (decimal), teamwork_score (decimal), leadership_score (decimal), technical_skills_score (decimal), status (enum: 'draft', 'submitted', 'approved'), created_at (timestamp), updated_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'performance_reviews'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For performance_reviews, filters are: review_id (string), employee_id (string), reviewer_id (string), review_period_start (date), review_period_end (date), review_type (enum: 'annual', 'quarterly', 'probationary', 'project_based'), overall_rating (enum: 'exceeds_expectations', 'meets_expectations', 'below_expectations', 'unsatisfactory'), goals_achievement_score (decimal), communication_score (decimal), teamwork_score (decimal), leadership_score (decimal), technical_skills_score (decimal), status (enum: 'draft', 'submitted', 'approved'), created_at (timestamp), updated_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverExpenseEntities(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover expense entities.
        
        Supported entities:
        - expense_reimbursements: Expense reimbursements by reimbursement_id, employee_id, expense_date, amount, expense_type, receipt_file_path, status, approved_by, payment_date, created_at, updated_at
        """
        if entity_type not in ["expense_reimbursements"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'expense_reimbursements'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get("expense_reimbursements", {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "reimbursement_id": entity_id})
            else:
                results.append({**entity_data, "reimbursement_id": entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_expense_entities",
                "description": "Discover expense entities. Entity types: 'expense_reimbursements' (expense reimbursements; filterable by reimbursement_id (string), employee_id (string), expense_date (date), amount (decimal), expense_type (enum: 'travel', 'meals', 'equipment', 'training', 'other'), receipt_file_path (string), status (enum: 'submitted', 'approved', 'rejected', 'paid'), approved_by (string), payment_date (date), created_at (timestamp), updated_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'expense_reimbursements'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For expense_reimbursements, filters are: reimbursement_id (string), employee_id (string), expense_date (date), amount (decimal), expense_type (enum: 'travel', 'meals', 'equipment', 'training', 'other'), receipt_file_path (string), status (enum: 'submitted', 'approved', 'rejected', 'paid'), approved_by (string), payment_date (date), created_at (timestamp), updated_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverDocumentEntities(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover document entities.
        
        Supported entities:
        - document_storage: Document storage records by document_id, document_name, document_type, employee_id, file_path, upload_date, uploaded_by, confidentiality_level, retention_period_years, expiry_date, status, created_at
        """
        if entity_type not in ["document_storage"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'document_storage'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get("document_storage", {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "document_id": entity_id})
            else:
                results.append({**entity_data, "document_id": entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_document_entities",
                "description": "Discover document entities. Entity types: 'document_storage' (document storage records; filterable by document_id (string), document_name (string), document_type (enum: 'contract', 'policy', 'handbook', 'form', 'certificate', 'report', 'resume', 'offer_letter'), employee_id (string), file_path (string), upload_date (timestamp), uploaded_by (string), confidentiality_level (enum: 'public', 'internal', 'confidential', 'restricted'), retention_period_years (integer), expiry_date (date), status (enum: 'active', 'archived', 'deleted'), created_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'document_storage'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For document_storage, filters are: document_id (string), document_name (string), document_type (enum: 'contract', 'policy', 'handbook', 'form', 'certificate', 'report', 'resume', 'offer_letter'), employee_id (string), file_path (string), upload_date (timestamp), uploaded_by (string), confidentiality_level (enum: 'public', 'internal', 'confidential', 'restricted'), retention_period_years (integer), expiry_date (date), status (enum: 'active', 'archived', 'deleted'), created_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverBenefitsEntities(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover benefits entities.
        
        Supported entities:
        - benefits_plans: Benefits plans by plan_id, plan_name, plan_type, provider, employee_cost, employer_cost, status, effective_date, expiration_date, created_at, updated_at
        - employee_benefits: Employee benefits by enrollment_id, employee_id, plan_id, enrollment_date, status, coverage_level, beneficiary_name, beneficiary_relationship, created_at, updated_at
        """
        if entity_type not in ["benefits_plans", "employee_benefits"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'benefits_plans' or 'employee_benefits'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        id_field = "plan_id" if entity_type == "benefits_plans" else "enrollment_id"
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, id_field: entity_id})
            else:
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_benefits_entities",
                "description": "Discover benefits entities. Entity types: 'benefits_plans' (benefits plans; filterable by plan_id (string), plan_name (string), plan_type (enum: 'health_insurance', 'dental', 'vision', 'life_insurance', 'disability', 'retirement_401k', 'pto', 'flexible_spending'), provider (string), employee_cost (decimal), employer_cost (decimal), status (enum: 'active', 'inactive'), effective_date (date), expiration_date (date), created_at (timestamp), updated_at (timestamp)), 'employee_benefits' (employee benefits; filterable by enrollment_id (string), employee_id (string), plan_id (string), enrollment_date (date), status (enum: 'active', 'terminated', 'pending'), coverage_level (enum: 'employee_only', 'employee_spouse', 'employee_children', 'family'), beneficiary_name (string), beneficiary_relationship (string), created_at (timestamp), updated_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'benefits_plans' or 'employee_benefits'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For benefits_plans, filters are: plan_id (string), plan_name (string), plan_type (enum: 'health_insurance', 'dental', 'vision', 'life_insurance', 'disability', 'retirement_401k', 'pto', 'flexible_spending'), provider (string), employee_cost (decimal), employer_cost (decimal), status (enum: 'active', 'inactive'), effective_date (date), expiration_date (date), created_at (timestamp), updated_at (timestamp). For employee_benefits, filters are: enrollment_id (string), employee_id (string), plan_id (string), enrollment_date (date), status (enum: 'active', 'terminated', 'pending'), coverage_level (enum: 'employee_only', 'employee_spouse', 'employee_children', 'family'), beneficiary_name (string), beneficiary_relationship (string), created_at (timestamp), updated_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverTrainingEntities(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover training entities.
        
        Supported entities:
        - training_programs: Training programs by program_id, program_name, program_type, duration_hours, delivery_method, mandatory, status, created_at, updated_at
        - employee_training: Employee training records by training_record_id, employee_id, program_id, enrollment_date, completion_date, status, score, certificate_issued, expiry_date, created_at, updated_at
        """
        if entity_type not in ["training_programs", "employee_training"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'training_programs' or 'employee_training'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        id_field = "program_id" if entity_type == "training_programs" else "training_record_id"
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, id_field: entity_id})
            else:
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_training_entities",
                "description": "Discover training entities. Entity types: 'training_programs' (training programs; filterable by program_id (string), program_name (string), program_type (enum: 'onboarding', 'compliance', 'technical', 'leadership', 'safety', 'diversity', 'ai_ethics'), duration_hours (integer), delivery_method (enum: 'in_person', 'online', 'hybrid', 'self_paced'), mandatory (boolean), status (enum: 'active', 'inactive', 'draft'), created_at (timestamp), updated_at (timestamp)), 'employee_training' (employee training records; filterable by training_record_id (string), employee_id (string), program_id (string), enrollment_date (date), completion_date (date), status (enum: 'enrolled', 'in_progress', 'completed', 'failed', 'cancelled'), score (decimal), certificate_issued (boolean), expiry_date (date), created_at (timestamp), updated_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'training_programs' or 'employee_training'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For training_programs, filters are: program_id (string), program_name (string), program_type (enum: 'onboarding', 'compliance', 'technical', 'leadership', 'safety', 'diversity', 'ai_ethics'), duration_hours (integer), delivery_method (enum: 'in_person', 'online', 'hybrid', 'self_paced'), mandatory (boolean), status (enum: 'active', 'inactive', 'draft'), created_at (timestamp), updated_at (timestamp). For employee_training, filters are: training_record_id (string), employee_id (string), program_id (string), enrollment_date (date), completion_date (date), status (enum: 'enrolled', 'in_progress', 'completed', 'failed', 'cancelled'), score (decimal), certificate_issued (boolean), expiry_date (date), created_at (timestamp), updated_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverLeaveEntities(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover leave entities.
        
        Supported entities:
        - leave_requests: Leave requests by leave_id, employee_id, leave_type, start_date, end_date, days_requested, status, approved_by, approval_date, remaining_balance, created_at, updated_at
        """
        if entity_type not in ["leave_requests"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'leave_requests'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get("leave_requests", {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "leave_id": entity_id})
            else:
                results.append({**entity_data, "leave_id": entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_leave_entities",
                "description": "Discover leave entities. Entity types: 'leave_requests' (leave requests; filterable by leave_id (string), employee_id (string), leave_type (enum: 'annual', 'sick', 'fmla', 'personal', 'bereavement', 'jury_duty'), start_date (date), end_date (date), days_requested (decimal), status (enum: 'pending', 'approved', 'rejected', 'cancelled'), approved_by (string), approval_date (timestamp), remaining_balance (decimal), created_at (timestamp), updated_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'leave_requests'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For leave_requests, filters are: leave_id (string), employee_id (string), leave_type (enum: 'annual', 'sick', 'fmla', 'personal', 'bereavement', 'jury_duty'), start_date (date), end_date (date), days_requested (decimal), status (enum: 'pending', 'approved', 'rejected', 'cancelled'), approved_by (string), approval_date (timestamp), remaining_balance (decimal), created_at (timestamp), updated_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# Policy:
HR Payroll Policy & SOPs
Introduction
This document defines the operational guide for an HR Payroll automation agent. It is designed for single-turn execution: each procedure must be self-contained and completed in one interaction.
Validation first: All inputs must be validated. If any required element is missing or invalid, the process halts with a clear error message.
Halt conditions: If approvals are missing, compliance not satisfied, or external systems fail, the process halts with explicit instructions.
Logging: All steps must be logged. Every create, update, approve, reject, delete, or execute action must generate an audit log entry.
Role-based permissions: Only the defined roles can perform specified actions.
The elevated roles are: HR director, payroll_administrator, finance_officer, it_administrator, compliance_officer
Roles & Responsibilities
HR Director
Approve HR policies and major structural changes (departments, job levels).
Own role definitions and segregation of duties.
Escalation owner for compliance-critical HR actions.
Create and update department records
Create and update benefits plans
Create job positions
Post and close job openings
HR Manager
Oversee daily HR operations across recruitment, onboarding, leave, and employee records.
Ensure SOP adherence and timely approvals where required.
Process employee onboarding
Process employee offboarding and terminations
Manage performance review cycles
Update employee profiles
Create and manage training programs
Process leave requests
Create and update department records
Create job positions
Manage skills managements and job position skill requirements
Post and close job openings
Hiring Manager
Raise requisitions, participate in interviews, provide hiring decisions.
Cannot access payroll or benefits data unless explicitly granted.
Participate in interview scheduling and outcome recording
Manage application stage transitions per workflow
Create job positions
Associate skills with job positions
Post and close job openings
Schedule interviews and record outcomes
Can approve timesheet entries
Recruiter
Manage candidates and applications, schedule interviews, record outcomes.
Cannot approve compensation, payroll, or benefits.
Create and manage candidate records
Create job applications and manage application stages
Schedule interviews and record interview outcomes
Manage application stage transitions per workflow
Add candidate records to the system
Create job positions
Post and close job openings
Payroll Administrator
Create, update, and process payroll records, bonuses, and deductions.
Cannot approve their own payroll runs.
Submit and manage timesheet entries
Process payroll runs and calculations
Process payroll corrections
Aggregate hours and compute gross pay, deductions, and net pay
Process timesheet submissions and corrections
Finance Officer
Validate payroll accuracy and statutory deductions; approve or reject payroll runs.
Reconcile payroll with finance ledgers; authorize reimbursements and payouts.
Process expense reimbursements
Validate payroll calculations and reconciliation
Create and update benefits plans
Update expense reimbursement records
Compliance Officer
Approve or reject compliance-sensitive actions (tax filings, terminations, incidents).
Halt operations if legal or regulatory violations are detected.
IT / System Administrator
Configure RBAC, MFA, encryption; manage backups and audit logs.
Provision/deprovision system access promptly upon status change.
Employee
Provide accurate personal information; submit timesheets promptly.
Acknowledge policies and participate in reviews and training as required.
Submit timesheet entries with accurate work dates and hours
Enroll in and complete training programs
Submit leave requests with proper documentation
Participate in performance review cycles
Submit expense reimbursement requests
Upload and manage personal documents
Standard Operating Procedures
User Provisioning
Input Validation
Validate that email is present, follows valid email format, and is unique in the system using discover_user_entities
Validate that role is one of the supported system roles (HR Director, HR Manager, Recruiter, Payroll Administrator, Hiring Manager, Finance Officer, IT Administrator, Compliance Officer, Employee)
Validate that first name and last name are provided and non-empty
Check that user with this email does not already exist in the system using discover_user_entities
Authorization Check
Check if HR Director or IT Administrator approval is required for elevated roles (administrative and financial access roles) using check_approval
If approval is missing for elevated roles, then output 'Halt: Approval missing for elevated role assignment'
Record Creation
Create new user with required information: first name, last name, email, role using manage_user
Set optional information if provided: phone number
Set system defaults: active status, multi-factor authentication enabled
Generate unique user identifier
Audit Logging
Log the user provisioning action as a creation event in the audit trail using manage_audit_logs
Create/Update Department
Input Validation
For creation:
Validate that department name is provided and non-empty
Validate that assigned manager exists in the employee system and has active status using discover_employee_entities
Validate that budget amount follows proper decimal format if provided
For updates: Validate that department exists and has active status using discover_department_entities
Authorization Check
Check that HR Director approval is obtained for department creation, updates, or manager changes using check_approval
If approval is missing, then output 'Halt: Approval missing for department operation'
Record Management
For creation:
Create department with required information: department name, assigned manager using manage_department
Set optional information if provided: budget allocation
Set system defaults: active status
For updates: Update specified information while maintaining organizational integrity using manage_department
Audit Logging
Log the department action as creation or update event in the audit trail using manage_audit_logs
Create/Update Job Position
Input Validation
For creation:
Validate that position title and department assignment are provided
Validate that assigned department exists and has active status using discover_department_entities
Validate that employment type is within supported categories (full-time, part-time, contract, intern, temporary)
Validate that minimum hourly rate does not exceed maximum rate if both provided
Validate that salary rates are positive monetary values
For updates: Validate that position exists in the system using discover_job_entities
Authorization Check
Check that HR Director or Hiring Manager approval is obtained for positions using check_approval
If approval is missing, then output 'Halt: Approval missing for publishable position'
Post Job Opening
Input Validation
Validate that position exists and currently has draft status using discover_job_entities
Validate that position contains all required information for publication
Status Update
Change job position status from draft to open for public visibility using manage_job_position
Update modification timestamp
Audit Logging
Log the job posting action as an update event in the audit trail using manage_audit_logs
Skills Management
Validate that the skill name is provided and valid. If skill name is missing or invalid, then output 'Halt: Invalid skill details: [list]'
Check that HR Director approval is obtained for skills catalog operations using check_approval. If approval is missing, then output 'Halt: Approval missing for skills operation'
For creation, check that skill name does not already exist using discover_job_entities. If duplicate exists, then output 'Halt: Skill name already exists'
Create or update the skill record with the status provided (active/inactive) using manage_skill
Log the skills catalog action in the audit log using manage_audit_logs
Job Position Skills Management
Validate that the position ID is valid and skill IDs are provided using discover_job_entities. If position ID is invalid or skill IDs missing, then output 'Halt: Invalid position skills details: [list]'
Check that HR Director or Hiring Manager approval is obtained for position skills changes using check_approval. If approval is missing, then output 'Halt: Approval missing for position skills operation'
Verify that the job position exists and all specified skills exist in the skills catalog using discover_job_entities
For adding skills, check that skills are not already associated with the position. For removing skills, check that skills are currently associated
Add or remove skill associations for the job position using manage_job_position_skills
Log the position skills management action in the audit log using manage_audit_logs
Close Job Opening
Input Validation
Validate that position exists and currently has open status using discover_job_entities
Status Update
Change job position status from open to closed using manage_job_position
Audit Logging
Log the job closing event as an update event in the audit trail using manage_audit_logs
Adding Candidate Record
Input Validation
Validate that first name, last name, and email are provided and non-empty
Validate that email is unique in the system using discover_recruitment_entities
Validate that source is within accepted recruitment channels (job board, referral, company website, recruiter, social media, career fair)
Record Creation
Create candidate with required information: first name, last name, email, recruitment source using manage_candidate
Set optional information if provided: phone number, address
Set the status of the candidate as new if the status is not specified. The allowed statuses are: 'new', 'screening','interviewing','offer','hired','rejected','withdrawn'
Audit Logging
Log the candidate creation as a creation event in the audit trail using manage_audit_logs
Create/Update Job Application
Input Validation
For creation:
Validate that candidate and position exist and are valid using discover_recruitment_entities and discover_job_entities
Validate that assigned recruiter exists and has recruiter role using discover_user_entities
Validate that application date is provided and not in future
For updates:
Validate that application exists using discover_recruitment_entities
Validate status transitions follow proper workflow. Applications follow a linear progression: submitted → under_review → screening (with AI scoring) → interviewing → offer_made → accepted. Applications can exit to 'rejected' or 'withdrawn' from any active stage but cannot move backward, transition from terminal states (accepted, rejected, withdrawn), or skip intermediate steps.
Record Management
For creation:
Create application with required information: candidate, position, application date, assigned recruiter using manage_job_applications
Set status of the application as submitted unless the state is specified. The allowed states are: 'submitted','under_review','screening','interviewing','offer_made','accepted','rejected','withdrawn'
For updates:
Update specified information, ensure status transitions are valid using manage_job_applications
Optional information that are not required to create the job application but preferred: AI screening score (percentage), final hiring decision, current status
Audit Logging
Log the application action as creation or update event in the audit trail using manage_audit_logs
Manage Application Stage
Input Validation
Validate that the application exists, and the stage transition is valid using discover_recruitment_entities. If application is not found or stage transition is invalid, then output 'Halt: Invalid application status change'
Validate that AI screening score is within acceptable percentage range (0-100) if provided
Validate that final decision is within accepted options (hire, reject, hold) if provided
Authorization Check
Check that Recruiter or Hiring Manager approval is obtained using check_approval
Record Update
Update job application status and AI screening score if provided using manage_job_applications
Set final hiring decision (hire, reject, hold) if provided
Audit Logging
Log the stage change as an update event in the audit trail using manage_audit_logs
Schedule Interview
Input Validation
Validate that the application and interviewer exist using discover_recruitment_entities and discover_user_entities. If application or interviewer is missing → output 'Halt: Invalid interview scheduling details'
Validate that interview type is within accepted categories (phone screening, technical, behavioral, panel, final)
Validate that scheduled date and time is in the future
Validate that duration is a positive time value with reasonable default
Record Creation
Create interview with required information: application, interviewer, interview type, scheduled date and time using manage_interviews
Set optional information if provided: duration
Set system defaults: scheduled status, standard duration
Generate unique interview identifier
Audit Logging
Log the interview scheduling as a creation event in the audit trail using manage_audit_logs
Record Interview Outcome
Input Validation
Validate that interview exists and has scheduled or completed status using discover_recruitment_entities
Validate that overall rating is within accepted scale (excellent through poor)
Validate that individual scores are within acceptable numeric range if provided (technical, communication, cultural fit)
Validate that recommendation is within accepted options (strong hire, hire, no hire, strong no hire)
Record Update
Update interview with outcome information: overall rating, individual scores, recommendation using manage_interviews
Change status to completed
Update related job application status based on interview outcome using manage_job_applications. The update for job application is as follows: positive recommendations ('strong_hire' or 'hire') advance 'interviewing' status to 'offer_made', while negative recommendations ('no_hire' or 'strong_no_hire') immediately set status to 'rejected'. When no recommendation is provided, applications with 'excellent' or 'good' ratings remain at 'interviewing' for potential additional interviews, while 'poor' or 'below_average' ratings trigger 'rejected' status. Final interviews with positive recommendations automatically advance to 'offer_made'.
Audit Logging
Log the interview outcome as an update event in the audit trail using manage_audit_logs
Employee Onboarding
Input Validation
Validate that all required information is provided: user account, position assignment, hire date
Validate that user account exists and is not already associated with an employee record using discover_user_entities and discover_employee_entities
Validate that assigned position exists and has active status using discover_job_entities
Validate that hire date is not in the past
Validate that hourly rate is positive monetary value, if provided
Validate optional information if provided: manager assignment (must exist in employee system using discover_employee_entities), date of birth, address
Authorization Check
Check that HR Manager approval is obtained and Compliance verification for eligibility documents is completed using check_approval
If approvals are missing, then output 'Halt: Approval or compliance verification missing'
Record Creation
Create employee record with required information: user account, position, hire date using manage_employee
Set optional information if provided: manager assignment, personal details, compensation rate
Set system defaults: active employment status
Update user account to active status using manage_user
Document Generation
Generate and store welcome documents in the document management system using manage_document_storage
Audit Logging
Log all onboarding actions as creation events in the audit trail using manage_audit_logs
Update Employee Profile
Input Validation
Validate that employee exists and has active status using discover_employee_entities
Validate that employment status is within accepted values (active, terminated, on leave, suspended)
Validate that hourly rate is positive monetary value if provided
Record Update
Update employee record information using manage_employee
Track before and after values for audit purposes
Audit Logging
Log before and after values as update events in the audit trail using manage_audit_logs
Employee Offboarding
Input Validation
Validate that employee exists and has active employment status using discover_employee_entities
Check for pending payroll records that have not been finalized using discover_payroll_entities
Check for active benefits enrollments using discover_benefits_entities
Check for incomplete training programs using discover_training_entities
Authorization Check
Check that HR Manager and Compliance Officer approvals are obtained using check_approval
If approvals are missing, then output 'Halt: Required approvals missing'
Record Updates
Set employee employment status to terminated using manage_employee
Update user account status to inactive using manage_user
Terminate active benefits enrollments using manage_employee_benefits
Cancel incomplete training enrollments using manage_employee_training
Audit Logging
Log all offboarding steps as update events in the audit trail using manage_audit_logs
Timesheet Submission
Input Validation
Validate that employee exists and has active status using discover_employee_entities
Validate that work date is provided and not in future
Validate that clock in and clock out times are provided and logical (clock in occurs before clock out)
Validate that break duration is non-negative time value with reasonable default
Record Creation
Create timesheet with required information: employee, work date, clock in time, clock out time using manage_timesheet_entries
Calculate total hours worked based on time difference minus break duration
Set optional information if provided: break duration, project assignment
Set system defaults: submitted status, zero break time
Audit Logging
Log the timesheet submission as a creation event in the audit trail using manage_audit_logs
Timesheet Approval/Correction
Input Validation
Validate that timesheet exists in the system using discover_timesheet_entities
Validate that approver has payroll administrator or hiring manager role using discover_user_entities
Validate status transitions follow proper workflow (draft or submitted to approved or rejected)
Authorization Check
Verify approver is authorized manager (Payroll Administrator or Hiring Manager) using check_approval
If unauthorized, then output 'Halt: Unauthorized access'
Record Update
Update timesheet with approver information and change status to approved or rejected using manage_timesheet_entries
Adjust time information if correction requested (total hours, break duration)
Audit Logging
Log approval and corrections as update events in the audit trail using manage_audit_logs
Process Payroll Run
Input Validation
Validate that all required information is provided: employee, pay period dates
Validate that pay period dates are logical (start date before end date)
Validate that hourly rate is positive monetary value
Aggregate approved timesheet hours for the specified pay period using discover_timesheet_entities
Authorization Check
Check that Finance Officer approval is obtained using check_approval
If approval is missing, then output 'Halt: Finance Officer approval required'
Record Creation/Update
Create payroll record with required information: employee, pay period dates, hourly rate using manage_payroll_records
Calculate hours worked from approved timesheets
Audit Logging
Log all payroll transactions as creation events in the audit trail using manage_audit_logs
Payroll Correction
Input Validation
Validate that payroll record exists in the system using discover_payroll_entities
Validate that correction information is valid (hours worked and hourly rate must be positive)
Authorization Check
Check that Finance Officer approval is obtained using check_approval
If approval is missing, then output 'Halt: Finance Officer approval required'
Record Update
Adjust payroll record with correction details using manage_payroll_records
Update modification timestamp
Audit Logging
Log the payroll correction as an update event in the audit trail using manage_audit_logs
Create/Update Benefits Plan
Input Validation
For creation:
Validate that plan name and plan type are provided
Validate that plan type is within supported categories (health insurance, dental, vision, life insurance, disability, retirement, paid time off, flexible spending)
Validate that effective date is provided and expiration date occurs after effective date if provided
Validate that cost amounts are non-negative monetary values if provided
For updates: Validate that plan exists in the system using discover_benefits_entities
Authorization Check
Check that HR Director or Finance Officer approval is obtained using check_approval
If approval is missing, then output 'Halt: HR Director or Finance Officer approval required'
Record Management
For creation: Create plan with required information: plan name, plan type, effective date using manage_benefits_plans
Set optional information if provided: provider, employee cost, employer cost, expiration date
Set system defaults: active status
For updates: Update specified information while maintaining date consistency using manage_benefits_plans
Audit Logging
Log the benefits plan action as creation or update event in the audit trail using manage_audit_logs
Employee Benefits Enrollment & Update
Input Validation
For enrollment: Validate that employee and benefits plan exist and have active status using discover_employee_entities and discover_benefits_entities
Validate that enrollment date is provided and not in future
Validate that coverage level is within accepted options (employee only, employee plus spouse, employee plus children, family coverage)
Check that employee is not already enrolled in the same plan type using discover_benefits_entities
For updates: Validate that enrollment record exists using discover_benefits_entities
Record Management
For enrollment: Create benefits enrollment with required information: employee, plan, enrollment date, coverage level using manage_employee_benefits
Set optional information if provided: beneficiary name and relationship
Set system defaults: active enrollment status
For updates: Update specified information, validate status transitions using manage_employee_benefits
Audit Logging
Log the benefits enrollment change as creation or update event in the audit trail using manage_audit_logs
Performance Review Cycle
Input Validation
Validate that employee and reviewer exist and have active status using discover_employee_entities
Validate that review period dates are logical (start date before end date)
Validate that review type is within accepted categories (annual, quarterly, probationary, project-based)
Authorization Check
Check that HR Manager approval is obtained for final approval using check_approval
If approval is missing, then output 'Halt: HR Manager approval required'
Record Management
Create performance review with required information: employee, reviewer, review period dates, review type, overall rating using manage_performance_reviews
Set optional score information if provided for various competency areas
Update status through proper progression (draft to submitted to approved)
Audit Logging
Log all status transitions as creation or update events in the audit trail using manage_audit_logs
Creating Training Program
Validate that all program fields are provided and valid. If program fields are missing or invalid, then output 'Halt: Invalid training program details'
Create or update training programs with mandatory flag if the training is required and set status to 'active' using manage_training_programs
Log the training program action in the audit trail using manage_audit_logs
Employee Training Enrollment & Completion
Validate that the employee and training program are valid using discover_employee_entities and discover_training_entities. If employee or program is invalid, then output 'Halt: Invalid training enrollment'
Create or update employee training record with status progression (enrolled → completed) and set expiry date if applicable using manage_employee_training
Log the training enrollment and completion in the audit trail using manage_audit_logs
Document Upload & Management
Validate that the document type is supported and all required metadata is provided. If document type is unsupported or metadata is missing, then output 'Halt: Invalid document metadata: [list]'
Insert document into document storage system with confidentiality level and retention period in years, and store file pointer using manage_document_storage
Log the document creation in the audit trail using manage_audit_logs
Audit Trail Logging (Global)
Input Validation
Validate that all required information is provided: user, action type, reference type, reference identifier
Validate that user exists in the system using discover_user_entities
Validate that action type is within accepted values (create, read, update, delete, approve, reject)
For field-level changes, validate that field name, old value, and new value are provided
Record Creation
Create audit log entry with all provided information using manage_audit_logs
Set timestamp to current system time
For record-level operations (create or delete), set field-level change information to null
Error Handling
If audit log write fails, then output 'Halt: Audit trail failure'
Leave Request Processing
Input Validation
Validate that employee exists and has active status using discover_employee_entities
Validate that leave type is within accepted categories (annual, sick, family medical leave, personal, bereavement, jury duty)
Validate that start and end dates are provided and logical (start date on or before end date, not in past)
Calculate requested days from date range
Record Creation
Create leave request with required information: employee, leave type, start date, end date, requested days using manage_leave_requests
Calculate and set remaining balance after this request
Set the approval status as pending unless logging a leave request that has many changes incurred to it.
Audit Logging
Log the leave request submission as a creation event in the audit trail using manage_audit_logs
Create/Update Expense Reimbursement
Input Validation
For creation:
Validate that employee, expense date, amount, and expense type are provided
Validate that employee exists and has active status using discover_employee_entities
Validate that expense type is within accepted categories (travel, meals, equipment, training, other)
Validate that amount is positive monetary value
Validate that expense date is not in future
For updates: Validate that reimbursement record exists and has submitted status using discover_expense_entities
Record Management
For creation: Create reimbursement with required information: employee, expense date, amount, expense type using manage_expense_reimbursements
For updates: Update specified information (amount, receipt location) only if status allows modification using manage_expense_reimbursements
Audit Logging
Log the reimbursement action as creation or update event in the audit trail using manage_audit_logs
Process Expense Reimbursement
Input Validation
Validate that reimbursement record exists in the system using discover_expense_entities
Validate that approving user exists and has appropriate role using discover_user_entities
Validate that status is within accepted values (approved, rejected, paid)
Validate status transitions follow proper workflow (submitted to approved or rejected, approved to paid)
Record Update
Update reimbursement status to specified value using manage_expense_reimbursements
Set approver information to approving user if status is approved
Set payment date if status is paid and payment date is provided
Audit Logging
Log the reimbursement processing as an update event in the audit trail using manage_audit_logs
Payroll Deductions Management
Input Validation
Validate that payroll record exists in the system using discover_payroll_entities
Validate that deduction type is within accepted categories (tax, insurance, retirement, garnishment, equipment, other)
Validate that deduction amount is positive monetary value
Validate that creator exists in the user system using discover_user_entities
Record Creation
Create deduction with required information: payroll record, deduction type, amount, creator using manage_payroll_deductions
Generate unique deduction identifier
Audit Logging
Log the deduction creation as a creation event in the audit trail using manage_audit_logs



# Database Schema:
// Use DBML to define your database structure
// HR Management System Database Schema
// This schema represents a comprehensive database for managing human resources operations,
// including recruitment, payroll, employee management, compliance, and AI/LLM governance

Table users {
  user_id string [primary key]
  first_name varchar(100) [not null]
  last_name varchar(100) [not null]
  email varchar(320) [not null, unique]
  phone_number varchar(20)
  role enum('hr_director','hr_manager','recruiter','payroll_administrator','hiring_manager','finance_officer','it_administrator','compliance_officer','employee') [not null]
  status enum('active','inactive','suspended') [not null, default: 'active']
  // last_login timestamp
  mfa_enabled boolean [default: true]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table departments {
  department_id string [primary key]
  department_name varchar(255) [not null]
  manager_id string [not null]
  budget decimal(15,2)
  status enum('active','inactive') [not null, default: 'active']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table job_positions {
  position_id string [primary key]
  title varchar(255) [not null]
  department_id string [not null]
  job_level enum('entry','junior','mid','senior','lead','manager','director','executive') [not null]
  employment_type enum('full_time','part_time','contract','intern','temporary') [not null]
  hourly_rate_min  decimal(12,2)
  hourly_rate_max  decimal(12,2)
  // required_skills text
  status enum('open','closed','draft') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table skills {
  skill_id string [primary key]
  skill_name text [not null]
  status enum('active','inactive') [default: 'active']
}

Table job_position_skills {
  position_id string [not null]
  skill_id string [not null]
  primary key (position_id, skill_id)
}

Ref: job_position_skills.position_id > job_positions.position_id
Ref: job_position_skills.skill_id > skills.skill_id


Table employees {
  employee_id string [primary key]
  user_id string [not null, unique]
  position_id string [not null]
  hire_date date [not null]
  employment_status enum('active','terminated','on_leave','suspended') [not null, default: 'active']
  manager_id string
  date_of_birth date
  address text
  hourly_rate int
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table candidates {
  candidate_id string [primary key]
  first_name varchar(100) [not null]
  last_name varchar(100) [not null]
  email varchar(320) [not null]
  phone_number varchar(20)
  address text
  // resume_file_path varchar(500)
  // linkedin_profile varchar(500)
  source enum('job_board','referral','company_website','recruiter','social_media','career_fair') [not null]
  status enum('new','screening','interviewing','offer','hired','rejected','withdrawn') [not null, default: 'new']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table job_applications {
  application_id string [primary key]
  candidate_id string [not null]
  position_id string [not null]
  application_date date [not null]
  status enum('submitted','under_review','screening','interviewing','offer_made','accepted','rejected','withdrawn') [not null, default: 'submitted']
  recruiter_id string [not null]
  // cover_letter text
  ai_screening_score decimal(5,2)
  // ai_recommendations text
  final_decision enum('hire','reject','hold') 
  // decision_reason text
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table interviews {
  interview_id string [primary key]
  application_id string [not null]
  interviewer_id string [not null]
  interview_type enum('phone_screening','technical','behavioral','panel','final') [not null]
  scheduled_date timestamp [not null]
  duration_minutes integer [default: 60]
  status enum('scheduled','completed','cancelled','no_show') [not null, default: 'scheduled']
  overall_rating enum('excellent','good','average','below_average','poor')
  technical_score decimal(3,1)
  communication_score decimal(3,1)
  cultural_fit_score decimal(3,1)
  // notes text
  recommendation enum('strong_hire','hire','no_hire','strong_no_hire')
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table payroll_records {
  payroll_id string [primary key]
  employee_id string [not null]
  pay_period_start date [not null]
  pay_period_end date [not null]
  hours_worked decimal(6,2)
  // overtime_hours decimal(6,2)
  hourly_rate decimal(12,2) [not null]
  // overtime_pay decimal(12,2)
  // bonus decimal(12,2)
  // gross_pay decimal(12,2) [not null]
  // total_deductions decimal(12,2) [not null]   // 👈 single field
  // net_pay decimal(12,2) [not null]
  payment_date date
  status enum('draft','approved','paid','cancelled') [not null, default: 'draft']
  approved_by string
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table payroll_deductions {
  deduction_id string [primary key]
  payroll_id string [not null]
  deduction_type enum('tax','insurance','retirement','garnishment','equipment','other') [not null]
  // description varchar(255) [not null]
  amount decimal(10,2) [not null]
  // is_pre_tax boolean [default: false]
  created_by string [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table benefits_plans {
  plan_id string [primary key]
  plan_name varchar(255) [not null]
  plan_type enum('health_insurance','dental','vision','life_insurance','disability','retirement_401k','pto','flexible_spending') [not null]
  provider varchar(255)
  // description text
  employee_cost decimal(10,2)
  employer_cost decimal(10,2)
  status enum('active','inactive') [not null, default: 'active']
  effective_date date [not null]
  expiration_date date
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table employee_benefits {
  enrollment_id string [primary key]
  employee_id string [not null]
  plan_id string [not null]
  enrollment_date date [not null]
  status enum('active','terminated','pending') [not null, default: 'active']
  // employee_contribution decimal(10,2)
  coverage_level enum('employee_only','employee_spouse','employee_children','family') [not null]
  beneficiary_name varchar(255)
  beneficiary_relationship varchar(100)
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table performance_reviews {
  review_id string [primary key]
  employee_id string [not null]
  reviewer_id string [not null]
  review_period_start date [not null]
  review_period_end date [not null]
  review_type enum('annual','quarterly','probationary','project_based') [not null]
  overall_rating enum('exceeds_expectations','meets_expectations','below_expectations','unsatisfactory') [not null]
  goals_achievement_score decimal(3,1)
  communication_score decimal(3,1)
  teamwork_score decimal(3,1)
  leadership_score decimal(3,1)
  technical_skills_score decimal(3,1)
  // comments text
  // development_goals text
  status enum('draft','submitted','approved') [not null, default: 'draft']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

// Table leave_requests {
//   leave_id string [primary key]
//   employee_id string [not null]
//   leave_type enum('annual','sick','fmla','personal','bereavement','jury_duty') [not null]
//   start_date date [not null]
//   end_date date [not null]
//   days_requested decimal(3,1) [not null]
//   // reason text
//   status enum('pending','approved','rejected','cancelled') [not null, default: 'pending']
//   processed_by string
//   processing_date timestamp
//   remaining_balance decimal(5,1)
//   created_at timestamp [not null, default: `NOW()`]
//   updated_at timestamp [not null, default: `NOW()`]
// }

Table leave_requests {
  leave_id string [primary key]
  employee_id string [not null]
  leave_type enum('annual','sick','fmla','personal','bereavement','jury_duty') [not null]
  start_date date [not null]
  end_date date [not null]
  days_requested decimal(3,1) [not null]
  status enum('pending','approved','rejected','cancelled') [not null, default: 'pending']
  approved_by string
  approval_date timestamp
  remaining_balance decimal(5,1) // filled after approval
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}



Table expense_reimbursements {
  reimbursement_id string [primary key]
  employee_id string [not null]
  expense_date date [not null]
  amount decimal(10,2) [not null]
  expense_type enum('travel','meals','equipment','training','other') [not null]
  // description text [not null]
  receipt_file_path varchar(500)
  status enum('submitted','approved','rejected','paid') [not null, default: 'submitted']
  approved_by string
  payment_date date
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table training_programs {
  program_id string [primary key]
  program_name varchar(255) [not null]
  program_type enum('onboarding','compliance','technical','leadership','safety','diversity','ai_ethics') [not null]
  // description text
  duration_hours integer [not null]
  delivery_method enum('in_person','online','hybrid','self_paced') [not null]
  mandatory boolean [default: false]
  status enum('active','inactive','draft') [not null, default: 'active']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table employee_training {
  training_record_id string [primary key]
  employee_id string [not null]
  program_id string [not null]
  enrollment_date date [not null]
  completion_date date
  status enum('enrolled','in_progress','completed','failed','cancelled') [not null, default: 'enrolled']
  score decimal(5,2)
  certificate_issued boolean [default: false]
  expiry_date date
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table audit_logs {
  log_id string [primary key]
  user_id string [not null]
  action enum('create','read','update','delete','approve','reject') [not null]
  reference_type string [not null]
  reference_id string [not null]
  field_name varchar(100)
  old_value text
  new_value text
  timestamp timestamp [not null, default: `NOW()`]
}


// Table compliance_records {
//   compliance_id string [primary key]
//   record_type enum('eeoc_report','flsa_audit','ada_accommodation','fmla_leave','safety_incident','data_breach','ai_bias_test') [not null]
//   employee_id string
//   // description text [not null]
//   compliance_officer_id string [not null]
//   status enum('open','under_review','resolved','escalated') [not null, default: 'open']
//   severity enum('low','medium','high','critical') [not null]
//   due_date date
//   // resolution_notes text
//   created_at timestamp [not null, default: `NOW()`]
//   updated_at timestamp [not null, default: `NOW()`]
// }


Table document_storage {
  document_id string [primary key]
  document_name varchar(255) [not null]
  document_type enum('contract','policy','handbook','form','certificate','report','resume','offer_letter') [not null]
  employee_id string
  file_path varchar(500) [not null]
  // file_size_bytes bigint
  upload_date timestamp [not null]
  uploaded_by string [not null]
  confidentiality_level enum('public','internal','confidential','restricted') [not null, default: 'internal']
  retention_period_years integer [not null, default: 7]
  expiry_date date
  status enum('active','archived','deleted') [not null, default: 'active']
  created_at timestamp [not null, default: `NOW()`]
}

// RELATIONSHIPS

// User and Employee relationships
Ref: employees.user_id > users.user_id
Ref: employees.manager_id > employees.employee_id
Ref: employees.position_id > job_positions.position_id

// Department relationships
Ref: departments.manager_id > employees.employee_id
Ref: job_positions.department_id > departments.department_id

// Application and Interview relationships
Ref: job_applications.candidate_id > candidates.candidate_id
Ref: job_applications.position_id > job_positions.position_id
Ref: job_applications.recruiter_id > users.user_id
Ref: interviews.application_id > job_applications.application_id
Ref: interviews.interviewer_id > users.user_id

// Payroll relationships
Ref: payroll_records.employee_id > employees.employee_id
Ref: payroll_records.approved_by > users.user_id

// Benefits relationships
Ref: employee_benefits.employee_id > employees.employee_id
Ref: employee_benefits.plan_id > benefits_plans.plan_id

// Performance and Training relationships
Ref: performance_reviews.employee_id > employees.employee_id
Ref: performance_reviews.reviewer_id > users.user_id
Ref: employee_training.employee_id > employees.employee_id
Ref: employee_training.program_id > training_programs.program_id

Ref: audit_logs.user_id > users.user_id


// Compliance and Incident relationships
// Ref: compliance_records.employee_id > employees.employee_id
// Ref: compliance_records.compliance_officer_id > users.user_id

// Document relationships
Ref: document_storage.employee_id > employees.employee_id
Ref: document_storage.uploaded_by > users.user_id

Table employee_timesheets {
  timesheet_id string [primary key]
  employee_id string [not null]
  work_date date [not null]
  clock_in_time timestamp
  clock_out_time timestamp
  break_duration_minutes integer [default: 0]
  total_hours decimal(4,2)
  // overtime_hours decimal(4,2) [default: 0]
  project_code varchar(50)
  // notes text
  approved_by string
  status enum('draft','submitted','approved','rejected') [not null, default: 'draft']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

// Additional relationships for new tables
Ref: employee_timesheets.employee_id > employees.employee_id
Ref: employee_timesheets.approved_by > users.user_id

Ref: payroll_deductions.payroll_id > payroll_records.payroll_id
Ref: payroll_deductions.created_by > users.user_id

Ref: leave_requests.employee_id > employees.employee_id
Ref: leave_requests.approved_by > users.user_id

Ref: expense_reimbursements.employee_id > employees.employee_id
Ref: expense_reimbursements.approved_by > users.user_id


You have to provide the json file for each function separately including all the tests for that function in the actions part. You are going to provide the bash script that will create and populate those json files in a folder named tools_regression_tests/interface_5/.
