Assume you are an experienced tester. I am going to give you python functions and you are going to give me the inputs to test this function. The inputs are provided in the form of actions. You have to provide two tests for each function with the most number of parameters as possible (if applicable). However, you have to follow the format that I provide to you below.

# Format:
{
    "env": "incident_management_redos",
    "interface_num": 4,
    "task": {
        "actions": [
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            },
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            }
        ]
    }
}

where the name of action is the function name and the arguments are the parameters of the function. You have to provide multiple actions for a single file in a single test if applicable. 

# Functions:
import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageUsers(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        user_data: Optional[Dict[str, Any]] = None,
        user_id: Optional[str] = None
    ) -> str:
        """
        Create or update user records.
        
        Actions:
        - create: Create new user record (requires user_data with first_name, last_name, email, role, timezone)
        - update: Update existing user record (requires user_id and user_data with changes)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        timestamp = "2025-10-01T00:00:00"
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })
        
        users = data.get("users", {})
        clients = data.get("clients", {})
        
        if action == "create":
            if not user_data:
                return json.dumps({
                    "success": False,
                    "error": "user_data is required for create action"
                })
            
            # Validate required fields
            required_fields = ["first_name", "last_name", "email", "role", "timezone"]
            missing_fields = [field for field in required_fields if field not in user_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not user_data[field] or str(user_data[field]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
            
            # Validate allowed fields
            allowed_fields = ["first_name", "last_name", "email", "role", "timezone", "status", "client_id"]
            invalid_fields = [field for field in user_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields: {', '.join(invalid_fields)}"
                })
            
            # Validate role enum
            valid_roles = ["incident_manager", "technical_support", "account_manager", "executive", "system_administrator", "client_contact"]
            if user_data["role"] not in valid_roles:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid role '{user_data['role']}'. Must be one of: {', '.join(valid_roles)}"
                })
            
            # Validate status enum if provided (schema only has 'active' and 'inactive')
            if "status" in user_data:
                if user_data["status"] is not None and str(user_data["status"]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": "Field 'status' cannot be empty if provided"
                    })
                valid_status = ["active", "inactive"]
                if user_data["status"] not in valid_status:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status '{user_data['status']}'. Must be one of: {', '.join(valid_status)}"
                    })
            
            # Check email uniqueness
            for user in users.values():
                if user.get("email") == user_data["email"]:
                    return json.dumps({
                        "success": False,
                        "error": "Email already exists"
                    })
            
            # Validate client_id if role is client_contact
            if user_data["role"] == "client_contact":
                if "client_id" not in user_data:
                    return json.dumps({
                        "success": False,
                        "error": "client_id is required for client_contact role"
                    })
                if not user_data["client_id"] or str(user_data["client_id"]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": "Field 'client_id' cannot be empty"
                    })
                if str(user_data["client_id"]) not in clients:
                    return json.dumps({
                        "success": False,
                        "error": "Client not found"
                    })
            
            # Validate optional fields are not empty if provided
            if "client_id" in user_data and user_data["client_id"] is not None:
                if str(user_data["client_id"]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": "Field 'client_id' cannot be empty if provided"
                    })
            
            # Create new user
            new_id = str(generate_id(users))
            new_user = {
                "user_id": new_id,
                "first_name": user_data["first_name"],
                "last_name": user_data["last_name"],
                "email": user_data["email"],
                "role": user_data["role"],
                "timezone": user_data["timezone"],
                "status": user_data.get("status", "active"),
                "client_id": str(user_data["client_id"]) if user_data.get("client_id") not in (None, "") else None,
                "created_at": timestamp,
                "updated_at": timestamp
            }
            users[new_id] = new_user
            
            return json.dumps({
                "success": True,
                "action": "create",
                "user_id": new_id,
                "user_data": new_user
            })
        
        elif action == "update":
            if not user_id:
                return json.dumps({
                    "success": False,
                    "error": "user_id is required for update action"
                })
            
            if str(user_id) not in users:
                return json.dumps({
                    "success": False,
                    "error": f"User {user_id} not found"
                })
            
            if not user_data:
                return json.dumps({
                    "success": False,
                    "error": "user_data is required for update action"
                })
            
            # Validate allowed fields
            allowed_fields = ["first_name", "last_name", "email", "role", "timezone", "status", "client_id"]
            invalid_fields = [field for field in user_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields
            for field, value in user_data.items():
                if field in ["client_id", "status"] and value is not None and str(value).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty if provided"
                    })
                elif field not in ["client_id", "status"] and value is not None and str(value).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
            
            # Validate role enum if provided
            if "role" in user_data:
                valid_roles = ["incident_manager", "technical_support", "account_manager", "executive", "system_administrator", "client_contact"]
                if user_data["role"] not in valid_roles:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid role. Must be one of: {', '.join(valid_roles)}"
                    })
            
            # Validate status enum if provided (schema only has 'active' and 'inactive')
            if "status" in user_data:
                valid_status = ["active", "inactive"]
                if user_data["status"] not in valid_status:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status. Must be one of: {', '.join(valid_status)}"
                    })
            
            # Check email uniqueness if being updated
            if "email" in user_data:
                for uid, user in users.items():
                    if uid != str(user_id) and user.get("email") == user_data["email"]:
                        return json.dumps({
                            "success": False,
                            "error": "New email already exists"
                        })
            
            # Get current user to check role
            current_user = users[str(user_id)]
            current_role = user_data.get("role", current_user.get("role"))
            
            # Validate client_id if role is client_contact
            if current_role == "client_contact" and "client_id" in user_data:
                if user_data["client_id"] and str(user_data["client_id"]) not in clients:
                    return json.dumps({
                        "success": False,
                        "error": "Client not found"
                    })
            
            # Update user
            updated_user = users[str(user_id)].copy()
            for key, value in user_data.items():
                if key == "client_id" and value:
                    updated_user[key] = str(value)
                elif key == "client_id" and value in (None, ""):
                    updated_user[key] = None
                else:
                    updated_user[key] = value
            updated_user["updated_at"] = timestamp
            users[str(user_id)] = updated_user
            
            return json.dumps({
                "success": True,
                "action": "update",
                "user_id": str(user_id),
                "user_data": updated_user
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_users",
                "description": "Create or update user records in the incident management system. Manages user lifecycle including role-based access control, client associations, and status management. Validates user roles, email uniqueness, and enforces role-specific requirements for client contacts.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new user record, 'update' to modify existing user record"
                        },
                        "user_data": {
                            "type": "object",
                            "description": "User data object containing fields for creating or updating users",
                            "properties": {
                                "first_name": {
                                    "type": "string",
                                    "description": "User's first name (required for create, cannot be empty)"
                                },
                                "last_name": {
                                    "type": "string",
                                    "description": "User's last name (required for create, cannot be empty)"
                                },
                                "email": {
                                    "type": "string",
                                    "description": "User's email address (required for create, cannot be empty, must be unique across all users)"
                                },
                                "role": {
                                    "type": "string",
                                    "description": "User's role in the system (required for create). Must be one of: incident_manager, technical_support, account_manager, executive, system_administrator, client_contact"
                                },
                                "timezone": {
                                    "type": "string",
                                    "description": "User's timezone (required for create, cannot be empty)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "User's status (optional, defaults to 'active'). Must be one of: active, inactive"
                                },
                                "client_id": {
                                    "type": "string",
                                    "description": "Associated client identifier (required for client_contact role, optional for others, must exist if provided)"
                                }
                            }
                        },
                        "user_id": {
                            "type": "string",
                            "description": "Unique identifier of the user record. Required for update action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageWorkNotes(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        note_data: Optional[Dict[str, Any]] = None,
        note_id: Optional[str] = None
    ) -> str:
        """
        Create or update work note records.

        Actions:
        - create: Create a new work note record (requires note_data)
        - update: Update an existing work note record (requires note_id and note_data)
        """

        def generate_id(table: Dict[str, Any], prefix: str) -> str:
            if not table:
                return f"{prefix}1"
            max_id = 0
            for k in table.keys():
                try:
                    num = int(k[len(prefix):])
                    if num > max_id:
                        max_id = num
                except ValueError:
                    continue
            return f"{prefix}{max_id + 1}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        work_notes = data.get("work_notes", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        # Define valid enums based on DBML schema
        valid_note_types = ["progress_update", "troubleshooting", "resolution"]

        if action == "create":
            if not note_data:
                return json.dumps({
                    "success": False,
                    "error": "note_data is required for create action"
                })

            # Validate required fields as per DBML schema
            required_fields = [
                "incident_id", "note_text", "note_type", "created_by"
            ]
            missing_fields = [field for field in required_fields if field not in note_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not note_data[field] or (isinstance(note_data[field], str) and str(note_data[field]).strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate note_type enum
            if note_data["note_type"] not in valid_note_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid note_type '{note_data['note_type']}'. Must be one of: {', '.join(valid_note_types)}"
                })

            # Validate incident_id FK
            incident_id = str(note_data["incident_id"]).strip().strip('"')
            if incident_id not in incidents:
                return json.dumps({
                    "success": False,
                    "error": f"Incident '{incident_id}' not found"
                })

            # Validate created_by FK
            created_by = str(note_data["created_by"]).strip().strip('"')
            if created_by not in users:
                return json.dumps({
                    "success": False,
                    "error": f"User '{created_by}' not found"
                })
            if users[created_by]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"User '{created_by}' is not active"
                })

            new_id = generate_id(work_notes, "")
            new_note = {
                "note_id": new_id,
                "incident_id": incident_id,
                "note_text": note_data["note_text"],
                "note_type": note_data["note_type"],
                "created_by": created_by,
                "created_at": timestamp
            }
            work_notes[new_id] = new_note
            return json.dumps({
                "success": True,
                "action": "create",
                "note_id": new_id,
                "note_data": new_note
            })

        elif action == "update":
            if not note_id:
                return json.dumps({
                    "success": False,
                    "error": "note_id is required for update action"
                })
            note_id = str(note_id).strip().strip('"')
            if note_id not in work_notes:
                return json.dumps({
                    "success": False,
                    "error": f"Work note '{note_id}' not found"
                })

            if not note_data:
                return json.dumps({
                    "success": False,
                    "error": "note_data is required for update action"
                })

            # Allowed fields for update (note_text and note_type can be updated)
            allowed_fields = ["note_text", "note_type"]
            invalid_fields = [field for field in note_data if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for update: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields
            for field, value in note_data.items():
                if value is None or (isinstance(value, str) and str(value).strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate note_type enum if provided
            if "note_type" in note_data and note_data["note_type"] not in valid_note_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid note_type '{note_data['note_type']}'. Must be one of: {', '.join(valid_note_types)}"
                })

            updated_note = work_notes[note_id].copy()
            for key, value in note_data.items():
                updated_note[key] = value
            
            work_notes[note_id] = updated_note
            return json.dumps({
                "success": True,
                "action": "update",
                "note_id": note_id,
                "note_data": updated_note
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_work_notes",
                "description": "Create or update work note records in the system. Work notes document incident progress, troubleshooting steps, and resolutions.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to add a new work note, 'update' to modify an existing work note."
                        },
                        "note_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating or updating a work note.",
                            "properties": {
                                "incident_id": {
                                    "type": "string",
                                    "description": "The ID of the incident this note is associated with (required for create, cannot be empty). Must refer to an existing incident."
                                },
                                "note_text": {
                                    "type": "string",
                                    "description": "The content of the work note (required for create, cannot be empty). Updatable."
                                },
                                "note_type": {
                                    "type": "string",
                                    "description": "The type/category of the work note (required for create). Must be one of: progress_update, troubleshooting, resolution. Updatable.",
                                    "enum": ["progress_update", "troubleshooting", "resolution"]
                                },
                                "created_by": {
                                    "type": "string",
                                    "description": "The user ID of the person who created the note (required for create). Must refer to an existing active user."
                                }
                            }
                        },
                        "note_id": {
                            "type": "string",
                            "description": "The unique identifier of the work note to update. Required for 'update' action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageProblemTickets(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        problem_data: Optional[Dict[str, Any]] = None,
        problem_id: Optional[str] = None
    ) -> str:
        """
        Create or update problem ticket records.

        Actions:
        - create: Create a new problem ticket record (requires problem_data)
        - update: Update an existing problem ticket record (requires problem_id and problem_data)
        """

        def generate_id(table: Dict[str, Any], prefix: str) -> str:
            if not table:
                return f"{prefix}1"
            max_id = 0
            for k in table.keys():
                try:
                    num = int(k[len(prefix):])
                    if num > max_id:
                        max_id = num
                except ValueError:
                    continue
            return f"{prefix}{max_id + 1}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        problem_tickets = data.get("problem_tickets", {})
        users = data.get("users", {})

        # Define valid enums based on DBML schema
        valid_categories = ["software", "hardware", "network", "database", "security"]
        valid_statuses = ["open", "investigating", "resolved", "closed"]

        if action == "create":
            if not problem_data:
                return json.dumps({
                    "success": False,
                    "error": "problem_data is required for create action"
                })

            # Validate required fields as per DBML schema
            required_fields = [
                "problem_number", "title", "description", "category",
                "reported_by", "assigned_to", "detected_at"
            ]
            missing_fields = [field for field in required_fields if field not in problem_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not problem_data[field] or (isinstance(problem_data[field], str) and str(problem_data[field]).strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate problem_number uniqueness
            problem_number = str(problem_data["problem_number"]).strip()
            for problem in problem_tickets.values():
                if problem["problem_number"].lower() == problem_number.lower():
                    return json.dumps({
                        "success": False,
                        "error": f"Problem with number '{problem_number}' already exists."
                    })

            # Validate enums
            if problem_data["category"] not in valid_categories:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid category '{problem_data['category']}'. Must be one of: {', '.join(valid_categories)}"
                })
            
            # Status is 'open' by default, if provided, must be valid
            status = problem_data.get("status", "open")
            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{status}'. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate reported_by FK
            reported_by = str(problem_data["reported_by"]).strip().strip('"')
            if reported_by not in users:
                return json.dumps({
                    "success": False,
                    "error": f"Reported by user '{reported_by}' not found"
                })
            if users[reported_by]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"Reported by user '{reported_by}' is not active"
                })

            # Validate assigned_to FK
            assigned_to = str(problem_data["assigned_to"]).strip().strip('"')
            if assigned_to not in users:
                return json.dumps({
                    "success": False,
                    "error": f"Assigned to user '{assigned_to}' not found"
                })
            if users[assigned_to]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"Assigned to user '{assigned_to}' is not active"
                })

            new_id = generate_id(problem_tickets, "PRB")
            new_problem = {
                "problem_id": new_id,
                "problem_number": problem_number,
                "title": problem_data["title"],
                "description": problem_data["description"],
                "category": problem_data["category"],
                "status": status,
                "reported_by": reported_by,
                "assigned_to": assigned_to,
                "detected_at": problem_data["detected_at"],
                "resolved_at": problem_data.get("resolved_at"),  # Nullable
                "closed_at": problem_data.get("closed_at"),  # Nullable
                "created_at": timestamp,
                "updated_at": timestamp
            }
            problem_tickets[new_id] = new_problem
            return json.dumps({
                "success": True,
                "action": "create",
                "problem_id": new_id,
                "problem_data": new_problem
            })

        elif action == "update":
            if not problem_id:
                return json.dumps({
                    "success": False,
                    "error": "problem_id is required for update action"
                })
            problem_id = str(problem_id).strip().strip('"')
            if problem_id not in problem_tickets:
                return json.dumps({
                    "success": False,
                    "error": f"Problem ticket '{problem_id}' not found"
                })

            if not problem_data:
                return json.dumps({
                    "success": False,
                    "error": "problem_data is required for update action"
                })

            # Allowed fields for update (all except problem_id, created_at)
            allowed_fields = [
                "problem_number", "title", "description", "category",
                "status", "reported_by", "assigned_to",
                "detected_at", "resolved_at", "closed_at"
            ]
            invalid_fields = [field for field in problem_data if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for update: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields (nullable fields can be None)
            # NOT NULL fields: problem_number, title, description, category, reported_by, assigned_to, detected_at
            nullable_fields = ["resolved_at", "closed_at"]
            for field, value in problem_data.items():
                if field not in nullable_fields and (value is None or (isinstance(value, str) and str(value).strip() == "")):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
                elif field in nullable_fields and (isinstance(value, str) and str(value).strip() == ""):
                    problem_data[field] = None  # Treat empty string as null for nullable fields

            # Validate problem_number uniqueness if updated
            if "problem_number" in problem_data:
                updated_problem_number = str(problem_data["problem_number"]).strip()
                for existing_problem_id, problem in problem_tickets.items():
                    if existing_problem_id != problem_id and problem["problem_number"].lower() == updated_problem_number.lower():
                        return json.dumps({
                            "success": False,
                            "error": f"Problem with number '{updated_problem_number}' already exists."
                        })
                problem_data["problem_number"] = updated_problem_number

            # Validate enums if provided
            if "category" in problem_data and problem_data["category"] not in valid_categories:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid category '{problem_data['category']}'. Must be one of: {', '.join(valid_categories)}"
                })
            if "status" in problem_data and problem_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{problem_data['status']}'. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate reported_by FK if provided
            if "reported_by" in problem_data:
                reported_by = str(problem_data["reported_by"]).strip().strip('"')
                if reported_by not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Reported by user '{reported_by}' not found"
                    })
                if users[reported_by]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Reported by user '{reported_by}' is not active"
                    })
                problem_data["reported_by"] = reported_by

            # Validate assigned_to FK if provided
            if "assigned_to" in problem_data:
                assigned_to = str(problem_data["assigned_to"]).strip().strip('"')
                if assigned_to not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Assigned to user '{assigned_to}' not found"
                    })
                if users[assigned_to]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Assigned to user '{assigned_to}' is not active"
                    })
                problem_data["assigned_to"] = assigned_to

            updated_problem = problem_tickets[problem_id].copy()
            for key, value in problem_data.items():
                updated_problem[key] = value
            updated_problem["updated_at"] = timestamp
            problem_tickets[problem_id] = updated_problem
            return json.dumps({
                "success": True,
                "action": "update",
                "problem_id": problem_id,
                "problem_data": updated_problem
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_problem_tickets",
                "description": "Create or update problem ticket records in the system. Problem tickets represent underlying issues that may cause multiple incidents.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to add a new problem ticket, 'update' to modify an existing problem ticket."
                        },
                        "problem_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating or updating a problem ticket.",
                            "properties": {
                                "problem_number": {
                                    "type": "string",
                                    "description": "A unique identifier for the problem ticket (required for create, must be unique, cannot be empty). Updatable."
                                },
                                "title": {
                                    "type": "string",
                                    "description": "A brief, descriptive title for the problem (required for create, cannot be empty). Updatable."
                                },
                                "description": {
                                    "type": "string",
                                    "description": "A detailed description of the problem, including its symptoms and potential impact (required for create, cannot be empty). Updatable."
                                },
                                "category": {
                                    "type": "string",
                                    "description": "The category of the problem (required for create). Must be one of: software, hardware, network, database, security. Updatable.",
                                    "enum": ["software", "hardware", "network", "database", "security"]
                                },
                                "status": {
                                    "type": "string",
                                    "description": "The current status of the problem (optional for create, defaults to 'open'). Must be one of: open, investigating, resolved, closed. Updatable.",
                                    "enum": ["open", "investigating", "resolved", "closed"]
                                },
                                "reported_by": {
                                    "type": "string",
                                    "description": "The user ID of the person who reported the problem (required for create). Must refer to an existing active user. Updatable."
                                },
                                "assigned_to": {
                                    "type": "string",
                                    "description": "The user ID of the person assigned to resolve the problem (required for create). Must refer to an existing active user. Updatable."
                                },
                                "detected_at": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the problem was detected (required for create, cannot be empty). Updatable."
                                },
                                "resolved_at": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the problem was resolved (optional). Updatable, can be set to null."
                                },
                                "closed_at": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the problem ticket was closed (optional). Updatable, can be set to null."
                                }
                            }
                        },
                        "problem_id": {
                            "type": "string",
                            "description": "The unique identifier of the problem ticket to update. Required for 'update' action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageEscalations(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, escalation_data: Dict[str, Any] = None, escalation_id: str = None) -> str:
        """
        Create or update escalation records.
        
        Actions:
        - create: Create new escalation (requires incident_id, escalated_from, escalated_to, escalation_reason, approver)
        - update: Update existing escalation (requires escalation_id and fields to update)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for escalations"
            })
        
        # get existing data tables
        escalations = data.get("escalations", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        # allowed enums
        valid_statuses = ["pending", "approved", "denied", "cancelled"]

        # allowed values
        required_user_status = ["active"]

        # for create action
        if action == "create":
            if not escalation_data:
                return json.dumps({
                    "success": False,
                    "error": "escalation_data is required for create action"
                })

            # Validate required fields for create (approver is optional as it's set during approval)
            required_fields = ["incident_id", "escalated_to", "escalation_reason", "escalated_from"]
            
            missing_fields = [field for field in required_fields if field not in escalation_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Missing required fields for create action: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not escalation_data[field] or str(escalation_data[field]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
            
            # Allowed fields
            allowed_fields = ["incident_id", "escalated_to", "escalation_reason", "escalated_from", "approver", "status"]

            escalation_fields = [field for field in escalation_data if field not in allowed_fields]
            if escalation_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Unrecognized fields in escalation_data: {', '.join(escalation_fields)}"
                })
            
            # Validate that incident exists
            if str(escalation_data["incident_id"]) not in incidents:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Incident not found"
                })
            
            # Validate that escalated_from user exists
            if str(escalation_data["escalated_from"]) not in users:
                return json.dumps({
                    "success": False,
                    "error": "Halt: User escalated_from not found"
                })
            
            # Validate that escalated_to user exists
            if str(escalation_data["escalated_to"]) not in users:
                return json.dumps({
                    "success": False,
                    "error": "Halt: User escalated_to not found"
                })
            
            # Validate that escalated_to and escalated_from users are active
            for key in ["escalated_to", "escalated_from"]:
                user_id = str(escalation_data[key])
                if users[user_id]["status"] not in required_user_status:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: User {key} must be active"
                    })
            
            # Validate optional approver if provided
            if escalation_data.get("approver"):
                if not str(escalation_data["approver"]).strip():
                    return json.dumps({
                        "success": False,
                        "error": "Field 'approver' cannot be empty if provided"
                    })
                
                if str(escalation_data["approver"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Approver user not found"
                    })
                
                # Validate that approver user is active
                if users[str(escalation_data["approver"])]["status"] not in required_user_status:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User 'approver' must be active"
                    })
            
            # Validate status
            status = escalation_data.get("status", "pending")
            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid status - must be one of: {', '.join(valid_statuses)}"
                })
            
            # Generate new escalation ID
            new_escalation_id = generate_id(escalations)
            
            # Create new escalation record
            new_escalation = {
                "escalation_id": str(new_escalation_id),
                "incident_id": str(escalation_data["incident_id"]),
                "escalated_to": str(escalation_data["escalated_to"]),
                "escalation_reason": escalation_data["escalation_reason"],
                "approver": str(escalation_data["approver"]) if escalation_data.get("approver") not in (None, "") else None,
                "status": status,
                "escalated_from": str(escalation_data["escalated_from"]),
                "requested_at": "2025-10-07T00:00:00",
                "responded_at": None
            }
            
            escalations[str(new_escalation_id)] = new_escalation
            
            return json.dumps({
                "success": True,
                "action": "create",
                "escalation_id": str(new_escalation_id),
                "message": f"Escalation {new_escalation_id} created successfully",
                "escalation_data": new_escalation
            })
        
        # for update action
        elif action == "update":
            if not escalation_id:
                return json.dumps({
                    "success": False,
                    "error": "escalation_id is required for update action"
                })
            
            if str(escalation_id) not in escalations:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Escalation not found"
                })
            
            if not escalation_data:
                return json.dumps({
                    "success": False,
                    "error": "escalation_data is required for update action"
                })
            
            # Validate at least one optional field is provided (added escalation_reason and approver)
            update_fields = ["status", "escalated_to", "escalation_reason", "approver", "responded_at"]
            provided_fields = [field for field in update_fields if field in escalation_data]
            if not provided_fields:
                return json.dumps({
                    "success": False,
                    "error": f"At least one optional field must be provided for updates {', '.join(update_fields)}"
                })
            
            # Validate only allowed fields for updates
            invalid_fields = [field for field in escalation_data.keys() if field not in update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for escalation updating: {', '.join(invalid_fields)}"
                })

            # Validate non-empty fields
            for field, value in escalation_data.items():
                if field not in ["responded_at", "approver"] and value is not None and str(value).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate user to reassign the escalation to exists if provided
            if "escalated_to" in escalation_data: 
                if str(escalation_data["escalated_to"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User escalated_to not found"
                    })
            
                # Validate that reassign escalated_to user is active
                if users[str(escalation_data["escalated_to"])]["status"] not in required_user_status: 
                    return json.dumps({ 
                        "success": False, 
                        "error": "Halt: User escalated_to must be active" 
                    })
            
            # Validate approver if provided
            if "approver" in escalation_data:
                if escalation_data["approver"] is not None and str(escalation_data["approver"]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": "Field 'approver' cannot be empty if provided"
                    })
                
                if escalation_data["approver"] is not None:
                    if str(escalation_data["approver"]) not in users:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: Approver user not found"
                        })
                    
                    # Validate that approver user is active
                    if users[str(escalation_data["approver"])]["status"] not in required_user_status:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: User 'approver' must be active"
                        })
            
            # Validate status if provided
            if "status" in escalation_data and escalation_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid status. Must be one of: {', '.join(valid_statuses)}"
                })
            
            # Validate responded_at is not empty if provided
            if "responded_at" in escalation_data:
                if escalation_data["responded_at"] is not None and str(escalation_data["responded_at"]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": "Field 'responded_at' cannot be empty if provided"
                    })

            # Get current escalation record
            current_escalation = escalations[str(escalation_id)]
            # Update escalation record with modified information
            updated_escalation = current_escalation.copy()
            for key, value in escalation_data.items():
                if key in ["responded_at", "approver"]:
                    updated_escalation[key] = str(value) if value not in (None, "") else None
                elif key == "escalated_to":
                    updated_escalation[key] = str(value)
                else:
                    updated_escalation[key] = value
            
            escalations[str(escalation_id)] = updated_escalation
            
            return json.dumps({
                "success": True,
                "action": "update",
                "escalation_id": str(escalation_id),
                "message": f"Escalation {escalation_id} updated successfully",
                "escalation_data": updated_escalation
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_escalations",
                "description": "Create or update escalation records in the incident management system. This tool manages escalation workflows with comprehensive validation of users, incidents, and status transitions. For creation, establishes new escalations with proper validation of incident existence, user roles, and escalation paths. For updates, modifies existing escalation records including status changes, escalation reason updates, and response timestamps.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to create new escalation, 'update' to modify existing escalation"
                        },
                        "escalation_data": {
                            "type": "object",
                            "description": "Escalation data object containing fields for creating or updating escalations",
                            "properties": {
                                "incident_id": {
                                    "type": "string",
                                    "description": "Related incident identifier (required for create, cannot be empty, must exist in system)"
                                },
                                "escalated_from": {
                                    "type": "string",
                                    "description": "User identifier who requested the escalation (required for create, cannot be empty, must be active user)"
                                },
                                "escalated_to": {
                                    "type": "string",
                                    "description": "User identifier receiving the escalation (required for create, cannot be empty, must be active user). Updatable."
                                },
                                "escalation_reason": {
                                    "type": "string",
                                    "description": "Reason for escalation (required for create, cannot be empty). Updatable."
                                },
                                "approver": {
                                    "type": "string",
                                    "description": "User identifier who approved/denied the escalation (optional, typically set during approval process, cannot be empty if provided, must be active user). Updatable."
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Escalation status (optional for create, defaults to 'pending'). Must be one of: pending, approved, denied, cancelled. Updatable."
                                },
                                "responded_at": {
                                    "type": "string",
                                    "description": "Response timestamp in YYYY-MM-DDTHH:MM:SS format (optional, cannot be empty if provided). Updatable."
                                }
                            }
                        },
                        "escalation_id": {
                            "type": "string",
                            "description": "Unique identifier of the escalation. Required for update action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageIncidents(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        incident_data: Optional[Dict[str, Any]] = None,
        incident_id: Optional[str] = None
    ) -> str:
        """
        Create or update incident records.

        Actions:
        - create: Create a new incident record (requires incident_data)
        - update: Update an existing incident record (requires incident_id and incident_data)
        """

        def generate_id(table: Dict[str, Any], prefix: str) -> str:
            if not table:
                return f"{prefix}1"
            max_id = 0
            for k in table.keys():
                try:
                    num = int(k[len(prefix):])
                    if num > max_id:
                        max_id = num
                except ValueError:
                    continue
            return f"{prefix}{max_id + 1}"

        def generate_incident_number(table: Dict[str, Any]) -> str:
            if not table:
                return "INC0000001"
            max_num = 0
            for incident in table.values():
                incident_num = incident.get("incident_number", "")
                if incident_num.startswith("INC"):
                    try:
                        num = int(incident_num[3:])
                        if num > max_num:
                            max_num = num
                    except ValueError:
                        continue
            return f"INC{max_num + 1:07d}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        incidents = data.get("incidents", {})
        users = data.get("users", {})
        problem_tickets = data.get("problem_tickets", {})

        # Define valid enums based on DBML schema
        valid_categories = ["inquiry/help", "software", "hardware", "Network", "Database"]
        valid_severities = ["P1", "P2", "P3", "P4"]
        valid_impacts = ["low", "medium", "high", "critical"]
        valid_urgencies = ["low", "medium", "high", "critical"]
        valid_statuses = ["open", "in_progress", "monitoring", "resolved", "closed"]

        if action == "create":
            if not incident_data:
                return json.dumps({
                    "success": False,
                    "error": "incident_data is required for create action"
                })

            # Validate required fields as per DBML (incident_number is auto-generated)
            required_fields = [
                "title", "description", "category",
                "severity", "impact", "urgency", "reported_by", "detection_time"
            ]
            missing_fields = [field for field in required_fields if field not in incident_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not incident_data[field] or (isinstance(incident_data[field], str) and str(incident_data[field]).strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate enums
            if incident_data["category"] not in valid_categories:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid category '{incident_data['category']}'. Must be one of: {', '.join(valid_categories)}"
                })
            if incident_data["severity"] not in valid_severities:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid severity '{incident_data['severity']}'. Must be one of: {', '.join(valid_severities)}"
                })
            if incident_data["impact"] not in valid_impacts:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid impact '{incident_data['impact']}'. Must be one of: {', '.join(valid_impacts)}"
                })
            if incident_data["urgency"] not in valid_urgencies:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid urgency '{incident_data['urgency']}'. Must be one of: {', '.join(valid_urgencies)}"
                })
            
            # Status is 'open' by default, if provided, must be valid
            status = incident_data.get("status", "open")
            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{status}'. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate reported_by FK
            reported_by = str(incident_data["reported_by"]).strip().strip('"')
            if reported_by not in users:
                return json.dumps({
                    "success": False,
                    "error": f"Reported by user '{reported_by}' not found"
                })
            if users[reported_by]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"Reported by user '{reported_by}' is not active"
                })

            # Validate assigned_to FK if provided
            assigned_to = incident_data.get("assigned_to")
            if assigned_to:
                assigned_to = str(assigned_to).strip().strip('"')
                if assigned_to not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Assigned to user '{assigned_to}' not found"
                    })
                if users[assigned_to]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Assigned to user '{assigned_to}' is not active"
                    })
            
            # Validate problem_id FK if provided
            problem_id = incident_data.get("problem_id")
            if problem_id:
                problem_id = str(problem_id).strip().strip('"')
                if problem_id not in problem_tickets:
                    return json.dumps({
                        "success": False,
                        "error": f"Problem ticket '{problem_id}' not found"
                    })

            new_id = generate_id(incidents, "")
            incident_number = generate_incident_number(incidents)
            
            new_incident = {
                "incident_id": new_id,
                "problem_id": problem_id if problem_id else None,
                "incident_number": incident_number,
                "title": incident_data["title"],
                "description": incident_data["description"],
                "category": incident_data["category"],
                "severity": incident_data["severity"],
                "impact": incident_data["impact"],
                "urgency": incident_data["urgency"],
                "status": status,
                "reported_by": reported_by,
                "assigned_to": assigned_to if assigned_to else None,
                "detection_time": incident_data["detection_time"],
                "acknowledged_at": incident_data.get("acknowledged_at"), # Nullable
                "resolved_at": incident_data.get("resolved_at"), # Nullable
                "closed_at": incident_data.get("closed_at"), # Nullable
                "created_at": timestamp,
                "updated_at": timestamp
            }
            incidents[new_id] = new_incident
            return json.dumps({
                "success": True,
                "action": "create",
                "incident_id": new_id,
                "incident_data": new_incident
            })

        elif action == "update":
            if not incident_id:
                return json.dumps({
                    "success": False,
                    "error": "incident_id is required for update action"
                })
            incident_id = str(incident_id).strip().strip('"')
            if incident_id not in incidents:
                return json.dumps({
                    "success": False,
                    "error": f"Incident '{incident_id}' not found"
                })

            if not incident_data:
                return json.dumps({
                    "success": False,
                    "error": "incident_data is required for update action"
                })

            # Allowed fields for update (incident_id, incident_number, created_at are not updatable)
            allowed_fields = [
                "problem_id", "title", "description", "category",
                "severity", "impact", "urgency", "status", "reported_by",
                "assigned_to", "detection_time", "acknowledged_at", "resolved_at", "closed_at"
            ]
            invalid_fields = [field for field in incident_data if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for update: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields (if provided, they shouldn't be empty strings, but nullable fields can be None)
            # Note: title, description, category, severity, impact, urgency, reported_by, detection_time are NOT NULL
            nullable_fields = [
                "problem_id", "assigned_to", "acknowledged_at", "resolved_at", "closed_at"
            ]
            for field, value in incident_data.items():
                if field not in nullable_fields and (value is None or (isinstance(value, str) and str(value).strip() == "")):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
                elif field in nullable_fields and (isinstance(value, str) and str(value).strip() == ""):
                    incident_data[field] = None # Treat empty string as null for nullable fields

            # Validate enums if provided
            if "category" in incident_data and incident_data["category"] not in valid_categories:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid category '{incident_data['category']}'. Must be one of: {', '.join(valid_categories)}"
                })
            if "severity" in incident_data and incident_data["severity"] not in valid_severities:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid severity '{incident_data['severity']}'. Must be one of: {', '.join(valid_severities)}"
                })
            if "impact" in incident_data and incident_data["impact"] not in valid_impacts:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid impact '{incident_data['impact']}'. Must be one of: {', '.join(valid_impacts)}"
                })
            if "urgency" in incident_data and incident_data["urgency"] not in valid_urgencies:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid urgency '{incident_data['urgency']}'. Must be one of: {', '.join(valid_urgencies)}"
                })
            if "status" in incident_data and incident_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{incident_data['status']}'. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate reported_by FK if provided
            if "reported_by" in incident_data:
                reported_by = str(incident_data["reported_by"]).strip().strip('"')
                if reported_by not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Reported by user '{reported_by}' not found"
                    })
                if users[reported_by]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Reported by user '{reported_by}' is not active"
                    })
                incident_data["reported_by"] = reported_by

            # Validate assigned_to FK if provided
            if "assigned_to" in incident_data and incident_data["assigned_to"] is not None:
                assigned_to = str(incident_data["assigned_to"]).strip().strip('"')
                if assigned_to not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Assigned to user '{assigned_to}' not found"
                    })
                if users[assigned_to]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Assigned to user '{assigned_to}' is not active"
                    })
                incident_data["assigned_to"] = assigned_to
            elif "assigned_to" in incident_data and incident_data["assigned_to"] is None:
                incident_data["assigned_to"] = None # Allow setting to null

            # Validate problem_id FK if provided
            if "problem_id" in incident_data and incident_data["problem_id"] is not None:
                problem_id = str(incident_data["problem_id"]).strip().strip('"')
                if problem_id not in problem_tickets:
                    return json.dumps({
                        "success": False,
                        "error": f"Problem ticket '{problem_id}' not found"
                    })
                incident_data["problem_id"] = problem_id
            elif "problem_id" in incident_data and incident_data["problem_id"] is None:
                incident_data["problem_id"] = None # Allow setting to null

            updated_incident = incidents[incident_id].copy()
            for key, value in incident_data.items():
                updated_incident[key] = value
            updated_incident["updated_at"] = timestamp
            incidents[incident_id] = updated_incident
            return json.dumps({
                "success": True,
                "action": "update",
                "incident_id": incident_id,
                "incident_data": updated_incident
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_incidents",
                "description": "Create or update incident records in the system. This tool allows for managing incident details, including linking to problem tickets, assigning to users, and tracking status. Incident numbers are automatically generated.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to add a new incident, 'update' to modify an existing incident."
                        },
                        "incident_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating or updating an incident.",
                            "properties": {
                                "problem_id": {
                                    "type": "string",
                                    "description": "The ID of the associated problem ticket (optional). Must refer to an existing problem ticket. Updatable, can be set to null."
                                },
                                "title": {
                                    "type": "string",
                                    "description": "A brief, descriptive title for the incident (required for create, cannot be empty). Updatable."
                                },
                                "description": {
                                    "type": "string",
                                    "description": "A detailed description of the incident, including symptoms and impact (required for create, cannot be empty). Updatable."
                                },
                                "category": {
                                    "type": "string",
                                    "description": "The category of the incident (required for create). Must be one of: inquiry/help, software, hardware, Network, Database. Updatable.",
                                    "enum": ["inquiry/help", "software", "hardware", "Network", "Database"]
                                },
                                "severity": {
                                    "type": "string",
                                    "description": "The severity level of the incident (required for create). Must be one of: P1, P2, P3, P4. Updatable.",
                                    "enum": ["P1", "P2", "P3", "P4"]
                                },
                                "impact": {
                                    "type": "string",
                                    "description": "The impact of the incident on services or users (required for create). Must be one of: low, medium, high, critical. Updatable.",
                                    "enum": ["low", "medium", "high", "critical"]
                                },
                                "urgency": {
                                    "type": "string",
                                    "description": "The urgency of resolving the incident (required for create). Must be one of: low, medium, high, critical. Updatable.",
                                    "enum": ["low", "medium", "high", "critical"]
                                },
                                "status": {
                                    "type": "string",
                                    "description": "The current status of the incident (optional for create, defaults to 'open'). Must be one of: open, in_progress, monitoring, resolved, closed. Updatable.",
                                    "enum": ["open", "in_progress", "monitoring", "resolved", "closed"]
                                },
                                "reported_by": {
                                    "type": "string",
                                    "description": "The user ID of the person who reported the incident (required for create). Must refer to an existing active user. Updatable."
                                },
                                "assigned_to": {
                                    "type": "string",
                                    "description": "The user ID of the person assigned to resolve the incident (optional). Must refer to an existing active user. Updatable, can be set to null."
                                },
                                "detection_time": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the incident was detected (required for create, cannot be empty). Updatable."
                                },
                                "acknowledged_at": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the incident was acknowledged (optional). Updatable, can be set to null."
                                },
                                "resolved_at": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the incident was resolved (optional). Updatable, can be set to null."
                                },
                                "closed_at": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the incident was closed (optional). Updatable, can be set to null."
                                }
                            }
                        },
                        "incident_id": {
                            "type": "string",
                            "description": "The unique identifier of the incident to update. Required for 'update' action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageIncidentsProblemsConfigurationItems(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        entity_type: str,
        association_data: Optional[Dict[str, Any]] = None,
        association_id: Optional[str] = None
    ) -> str:
        """
        Create or update incident-CI and problem-CI association records.

        Actions:
        - create: Create a new association record (requires entity_type and association_data)
        - update: Update an existing association record (requires entity_type, association_id and association_data)
        
        Entity Types:
        - incident_ci: For incident_configuration_items associations
        - problem_ci: For problem_configuration_items associations
        """

        def generate_id(table: Dict[str, Any], prefix: str) -> str:
            if not table:
                return f"{prefix}1"
            max_id = 0
            for k in table.keys():
                try:
                    num = int(k[len(prefix):])
                    if num > max_id:
                        max_id = num
                except ValueError:
                    continue
            return f"{prefix}{max_id + 1}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if entity_type not in ["incident_ci", "problem_ci"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'incident_ci' or 'problem_ci'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        configuration_items = data.get("configuration_items", {})

        if entity_type == "incident_ci":
            associations = data.get("incident_configuration_items", {})
            incidents = data.get("incidents", {})
            parent_key = "incident_id"
            parent_table = incidents
            parent_name = "Incident"
            id_field = "incident_ci_id"
            prefix = ""
        else:  # problem_ci
            associations = data.get("problem_configuration_items", {})
            problem_tickets = data.get("problem_tickets", {})
            parent_key = "problem_id"
            parent_table = problem_tickets
            parent_name = "Problem"
            id_field = "problem_ci_id"
            prefix = ""

        if action == "create":
            if not association_data:
                return json.dumps({
                    "success": False,
                    "error": "association_data is required for create action"
                })

            # Validate required fields
            required_fields = [parent_key, "ci_id"]
            missing_fields = [field for field in required_fields if field not in association_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not association_data[field] or (isinstance(association_data[field], str) and str(association_data[field]).strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate parent FK (incident_id or problem_id)
            parent_id = str(association_data[parent_key]).strip().strip('"')
            if parent_id not in parent_table:
                return json.dumps({
                    "success": False,
                    "error": f"{parent_name} '{parent_id}' not found"
                })

            # Validate ci_id FK
            ci_id = str(association_data["ci_id"]).strip().strip('"')
            if ci_id not in configuration_items:
                return json.dumps({
                    "success": False,
                    "error": f"Configuration item '{ci_id}' not found"
                })

            # Check for duplicate association (unique constraint on parent_id + ci_id)
            for assoc in associations.values():
                if assoc[parent_key] == parent_id and assoc["ci_id"] == ci_id:
                    return json.dumps({
                        "success": False,
                        "error": f"Association between {parent_name.lower()} '{parent_id}' and CI '{ci_id}' already exists"
                    })

            new_id = generate_id(associations, prefix)
            new_association = {
                id_field: new_id,
                parent_key: parent_id,
                "ci_id": ci_id,
                "created_at": timestamp
            }
            associations[new_id] = new_association
            return json.dumps({
                "success": True,
                "action": "create",
                "association_id": new_id,
                "association_data": new_association
            })

        elif action == "update":
            if not association_id:
                return json.dumps({
                    "success": False,
                    "error": "association_id is required for update action"
                })
            association_id = str(association_id).strip().strip('"')
            if association_id not in associations:
                return json.dumps({
                    "success": False,
                    "error": f"Association '{association_id}' not found"
                })

            if not association_data:
                return json.dumps({
                    "success": False,
                    "error": "association_data is required for update action"
                })

            # Allowed fields for update (only parent_id and ci_id can be updated)
            allowed_fields = [parent_key, "ci_id"]
            invalid_fields = [field for field in association_data if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for update: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields
            for field, value in association_data.items():
                if value is None or (isinstance(value, str) and str(value).strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate parent FK if provided
            if parent_key in association_data:
                parent_id = str(association_data[parent_key]).strip().strip('"')
                if parent_id not in parent_table:
                    return json.dumps({
                        "success": False,
                        "error": f"{parent_name} '{parent_id}' not found"
                    })
                association_data[parent_key] = parent_id

            # Validate ci_id FK if provided
            if "ci_id" in association_data:
                ci_id = str(association_data["ci_id"]).strip().strip('"')
                if ci_id not in configuration_items:
                    return json.dumps({
                        "success": False,
                        "error": f"Configuration item '{ci_id}' not found"
                    })
                association_data["ci_id"] = ci_id

            # Check for duplicate association if updating
            updated_parent_id = association_data.get(parent_key, associations[association_id][parent_key])
            updated_ci_id = association_data.get("ci_id", associations[association_id]["ci_id"])
            
            for existing_id, assoc in associations.items():
                if existing_id != association_id and assoc[parent_key] == updated_parent_id and assoc["ci_id"] == updated_ci_id:
                    return json.dumps({
                        "success": False,
                        "error": f"Association between {parent_name.lower()} '{updated_parent_id}' and CI '{updated_ci_id}' already exists"
                    })

            updated_association = associations[association_id].copy()
            for key, value in association_data.items():
                updated_association[key] = value
            
            associations[association_id] = updated_association
            return json.dumps({
                "success": True,
                "action": "update",
                "association_id": association_id,
                "association_data": updated_association
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_incidents_problems_configuration_items",
                "description": "Create or update associations between incidents/problems and configuration items. Links incidents or problems to the CIs they affect or are related to. Enforces unique constraints to prevent duplicate associations.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to add a new association, 'update' to modify an existing association."
                        },
                        "entity_type": {
                            "type": "string",
                            "description": "Type of association to manage: 'incident_ci' for incident-CI associations, 'problem_ci' for problem-CI associations.",
                            "enum": ["incident_ci", "problem_ci"]
                        },
                        "association_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating or updating an association.",
                            "properties": {
                                "incident_id": {
                                    "type": "string",
                                    "description": "The ID of the incident (required for create when entity_type is 'incident_ci', cannot be empty). Must refer to an existing incident. Updatable."
                                },
                                "problem_id": {
                                    "type": "string",
                                    "description": "The ID of the problem (required for create when entity_type is 'problem_ci', cannot be empty). Must refer to an existing problem. Updatable."
                                },
                                "ci_id": {
                                    "type": "string",
                                    "description": "The ID of the configuration item (required for create, cannot be empty). Must refer to an existing CI. Updatable."
                                }
                            }
                        },
                        "association_id": {
                            "type": "string",
                            "description": "The unique identifier of the association to update. Required for 'update' action only."
                        }
                    },
                    "required": ["action", "entity_type"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageImprovement(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, action: str, improvement_data: Dict[str, Any] = None, rca_id: str = None, review_id: str = None) -> str:
        """
        Create or update root cause analysis records or post incident review records.

        Entity Types:
        - root_cause_analyses
        - post_incident_reviews
        
        Actions:
        - create: Create new RCA or new PIR
        - update: Update existing RCA (requires rca_id and fields to update) or PIR (requires review_id and fields to update)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        def generate_rca_number(rca_id: int) -> str:
            return f"RCA{str(rca_id).zfill(7)}"
        
        if entity_type not in ["root_cause_analyses", "post_incident_reviews"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'root_cause_analyses' or 'post_incident_reviews'"
            })
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })
        
        # get existing data tables
        root_cause_analyses = data.get("root_cause_analyses", {})
        post_incident_reviews = data.get("post_incident_reviews", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        # allowed enums
        valid_methods = ["5_whys", "fishbone", "timeline", "fault_tree", "kepner_tregoe"]
        valid_statuses = ["assigned", "in_progress", "completed", "approved"]
        valid_pir_statuses = ["scheduled", "completed", "cancelled"]

        # valid values
        required_incident_statuses = ["resolved", "closed"]
        required_incident_statuses_pir = ["closed"]
        required_incident_severity = ["P1", "P2"]
        required_user_status = ["active"]
        

        # Handle root_cause_analyses
        if entity_type == "root_cause_analyses":
            # for create action
            if action == "create":
                if not improvement_data:
                    return json.dumps({
                        "success": False,
                        "error": "improvement_data is required for create action"
                    })

                # Validate required fields
                required_fields = ["associated_incident_id", "rca_title", "assigned_to", "due_date", "reported_by"]

                missing_fields = [field for field in required_fields if field not in improvement_data]
                if missing_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Missing required fields for create action: {', '.join(missing_fields)}"
                    })
                
                # Validate non-empty required fields
                for field in required_fields:
                    if not improvement_data[field] or str(improvement_data[field]).strip() == "":
                        return json.dumps({
                            "success": False,
                            "error": f"Field '{field}' cannot be empty"
                        })
                
                # Allowed fields
                allowed_fields = ["associated_incident_id", "rca_title", "assigned_to", "due_date", "reported_by", "analysis_method", "root_cause_summary", "status"]

                rca_fields = [field for field in improvement_data if field not in allowed_fields]
                if rca_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Unrecognized fields in improvement_data: {', '.join(rca_fields)}"
                    })
                
                # Validate that associated_incident exists
                if str(improvement_data["associated_incident_id"]) not in incidents:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Incident not found"
                    })
                
                # Validate that associated_incident status is resolved or closed
                incident_status = incidents[str(improvement_data["associated_incident_id"])]["status"]
                if incident_status not in required_incident_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Incident status must be one of: {', '.join(required_incident_statuses)}"
                    })
                
                # Validate that associated_incident severity is P1 or P2
                incident_severity = incidents[str(improvement_data["associated_incident_id"])]["severity"]
                if incident_severity not in required_incident_severity:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Incident severity must be one of: {', '.join(required_incident_severity)}"
                    })
                
                # Validate that assigned_to user exists
                if str(improvement_data["assigned_to"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User assigned_to not found"
                    })
                
                # Validate that assigned_to user is active
                if users[str(improvement_data["assigned_to"])]["status"] not in required_user_status: 
                    return json.dumps({ 
                        "success": False, 
                        "error": "Halt: User assigned_to must be active" 
                    })
                
                # Validate that reported_by user exists
                if str(improvement_data["reported_by"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User reported_by not found"
                    })
                
                # Validate that reported_by user is active
                if users[str(improvement_data["reported_by"])]["status"] not in required_user_status: 
                    return json.dumps({ 
                        "success": False, 
                        "error": "Halt: User reported_by must be active" 
                    })
                
                # Validate analysis_method if provided
                analysis_method = improvement_data.get("analysis_method")
                if analysis_method and analysis_method not in valid_methods:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid analysis method - must be one of: {', '.join(valid_methods)}"
                    })
                
                # Validate optional fields are not empty if provided
                optional_fields = ["root_cause_summary"]
                for field in optional_fields:
                    if field in improvement_data and improvement_data[field] is not None:
                        if str(improvement_data[field]).strip() == "":
                            return json.dumps({
                                "success": False,
                                "error": f"Field '{field}' cannot be empty if provided"
                            })
                
                # Validate status
                status = improvement_data.get("status", "assigned")
                if status not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid status - must be one of: {', '.join(valid_statuses)}"
                    })
                
                # Generate new RCA ID
                new_rca_id = generate_id(root_cause_analyses)
                rca_number = generate_rca_number(new_rca_id)
                
                # Create new RCA record
                new_rca = {
                    "rca_id": str(new_rca_id),
                    "rca_number": str(rca_number),
                    "associated_incident_id": str(improvement_data["associated_incident_id"]),
                    "rca_title": improvement_data["rca_title"],
                    "assigned_to": str(improvement_data["assigned_to"]),
                    "due_date": improvement_data["due_date"],
                    "analysis_method": analysis_method if analysis_method else None,
                    "root_cause_summary": improvement_data["root_cause_summary"] if improvement_data.get("root_cause_summary") not in (None, "") else None,
                    "status": status,
                    "completed_at": None,
                    "approved_by": None,
                    "reported_by": str(improvement_data["reported_by"]),
                    "created_at": "2025-10-07T00:00:00",
                    "updated_at": "2025-10-07T00:00:00"
                }
                
                root_cause_analyses[str(new_rca_id)] = new_rca
                
                return json.dumps({
                    "success": True,
                    "action": "create",
                    "rca_id": str(new_rca_id),
                    "message": f"RCA {new_rca_id} created successfully",
                    "improvement_data": new_rca
                })
            
            # for update action
            elif action == "update":
                if not rca_id:
                    return json.dumps({
                        "success": False,
                        "error": "rca_id is required for update action"
                    })
                
                if str(rca_id) not in root_cause_analyses:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: RCA not found"
                    })
                
                if not improvement_data:
                    return json.dumps({
                        "success": False,
                        "error": "improvement_data is required for update action"
                    })
                
                # Validate at least one optional field is provided
                update_fields = ["rca_title", "assigned_to", "analysis_method", "root_cause_summary", "status", "due_date", "completed_at", "approved_by"]

                provided_fields = [field for field in update_fields if field in improvement_data]
                if not provided_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"At least one optional field must be provided for updates {', '.join(update_fields)}"
                    })
                
                # Validate only allowed fields for updates
                invalid_fields = [field for field in improvement_data.keys() if field not in update_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields for RCA updating: {', '.join(invalid_fields)}"
                    })
                
                # Validate non-empty fields
                for field, value in improvement_data.items():
                    if field not in ["analysis_method", "root_cause_summary", "completed_at", "approved_by"] and value is not None and str(value).strip() == "":
                        return json.dumps({
                            "success": False,
                            "error": f"Field '{field}' cannot be empty"
                        })
                    elif field in ["analysis_method", "root_cause_summary", "completed_at", "approved_by"] and value is not None and str(value).strip() == "":
                        return json.dumps({
                            "success": False,
                            "error": f"Field '{field}' cannot be empty if provided"
                        })
                    
                if "assigned_to" in improvement_data:
                    # Validate that assigned_to user exists if provided
                    if str(improvement_data["assigned_to"]) not in users:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: User assigned_to not found"
                        })

                    # Validate that assigned_to user is active if provided
                    if users[str(improvement_data["assigned_to"])]["status"] not in required_user_status: 
                        return json.dumps({ 
                            "success": False, 
                            "error": "Halt: User assigned_to must be active" 
                        })
                    
                # Validate analysis_method if provided
                analysis_method = improvement_data.get("analysis_method")
                if analysis_method and analysis_method not in valid_methods:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid analysis method - must be one of: {', '.join(valid_methods)}"
                    })
                
                # Validate status if provided
                status = improvement_data.get("status")
                if status and status not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid status - must be one of: {', '.join(valid_statuses)}"
                    })
                
                approved_by = improvement_data.get("approved_by")
                if approved_by:  
                    # Validate that approved_by user exists if provided
                    if str(approved_by) not in users:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: User approved_by not found"
                        })
                
                    # Validate that approved_by user is active if provided
                    if users[str(approved_by)]["status"] not in required_user_status: 
                        return json.dumps({ 
                            "success": False, 
                            "error": "Halt: User approved_by must be active" 
                        })
                
                # If status is approved, approved_by is required
                if status == "approved" and not approved_by:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: approved_by is required when status is approved"
                    })
                
                # Get current RCA record
                current_rca = root_cause_analyses[str(rca_id)]
                # Update RCA record with modified information
                updated_rca = current_rca.copy()
                for key, value in improvement_data.items():
                    if key in ["analysis_method", "root_cause_summary", "completed_at", "approved_by"]:
                        updated_rca[key] = str(value) if value not in (None, "") else None
                    elif key == "assigned_to":
                        updated_rca[key] = str(value)
                    else:
                        updated_rca[key] = value
                
                updated_rca["updated_at"] = "2025-10-07T00:00:00"

                root_cause_analyses[str(rca_id)] = updated_rca
                
                return json.dumps({
                    "success": True,
                    "action": "update",
                    "rca_id": str(rca_id),
                    "message": f"RCA {rca_id} updated successfully",
                    "improvement_data": updated_rca
                })
        
        # Handle post_incident_reviews
        elif entity_type == "post_incident_reviews":
            # for create action
            if action == "create":
                if not improvement_data:
                    return json.dumps({
                        "success": False,
                        "error": "improvement_data is required for create action"
                    })
                
                # Validate required fields for create
                required_fields = ["incident_id", "scheduled_date", "facilitator", "review_notes", "lessons_learned", "action_items", "created_by"]
                
                missing_fields = [field for field in required_fields if field not in improvement_data]
                if missing_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Missing required fields for create action: {', '.join(missing_fields)}"
                    })
                
                # Validate non-empty required fields
                for field in required_fields:
                    if not improvement_data[field] or str(improvement_data[field]).strip() == "":
                        return json.dumps({
                            "success": False,
                            "error": f"Field '{field}' cannot be empty"
                        })
                
                # Allowed fields
                allowed_fields = ["incident_id", "scheduled_date", "facilitator", "review_notes", "lessons_learned", "action_items", "status", "created_by"]

                pir_fields = [field for field in improvement_data if field not in allowed_fields]
                if pir_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Unrecognized fields in improvement_data: {', '.join(pir_fields)}"
                    })
                
                # Validate that incident exists
                if str(improvement_data["incident_id"]) not in incidents:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: Incident not found"
                        })
                
                # Validate that incident status is closed
                incident_status = incidents[str(improvement_data["incident_id"])]["status"]
                if incident_status not in required_incident_statuses_pir:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Incident status must be closed"
                    })
                
                # Validate facilitator user exists
                if str(improvement_data["facilitator"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User 'facilitator' not found"
                    })
                
                # Validate that facilitator user is active
                if users[str(improvement_data["facilitator"])]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User 'facilitator' must be active"
                    })
                
                # Validate status enum
                status = improvement_data.get("status", "scheduled")
                if status not in valid_pir_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid pir status - must be one of: {', '.join(valid_pir_statuses)}"
                    })
                
                # Validate created_by user exists
                if str(improvement_data["created_by"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User 'created_by' not found"
                    })
                
                # Validate that created_by user is active
                if users[str(improvement_data["created_by"])]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User 'created_by' must be active"
                    })
                
                # Generate new PIR ID
                new_pir_id = generate_id(post_incident_reviews)

                # Create new pir record
                new_pir = {
                    "review_id": str(new_pir_id),
                    "incident_id": str(improvement_data["incident_id"]),
                    "scheduled_date": improvement_data["scheduled_date"],
                    "facilitator": str(improvement_data["facilitator"]),
                    "review_notes": improvement_data["review_notes"],
                    "lessons_learned": improvement_data["lessons_learned"],
                    "action_items": improvement_data["action_items"],
                    "status": status,
                    "created_by": str(improvement_data["created_by"]),
                    "created_at": "2025-10-07T00:00:00"
                }

                post_incident_reviews[str(new_pir_id)] = new_pir

                return json.dumps({
                    "success": True,
                    "action": "create",
                    "review_id": str(new_pir_id),
                    "message": f"Post incident review {new_pir_id} created successfully",
                    "improvement_data": new_pir
                })
            
            # for update action
            elif action == "update":
                if not review_id:
                    return json.dumps({
                        "success": False,
                        "error": "review_id is required for update action"
                    })
                
                if str(review_id) not in post_incident_reviews:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Post incident review not found"
                    })
                
                if not improvement_data:
                    return json.dumps({
                        "success": False,
                        "error": "improvement_data is required for update action"
                    })
                
                # Validate at least one optional field is provided
                update_fields = ["incident_id", "scheduled_date", "facilitator", "review_notes", "lessons_learned", "action_items", "status"]

                provided_fields = [field for field in update_fields if field in improvement_data]
                if not provided_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"At least one optional field must be provided for updates {', '.join(update_fields)}"
                    })
                
                # Validate only allowed fields for updates
                invalid_fields = [field for field in improvement_data.keys() if field not in update_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields for pir updating: {', '.join(invalid_fields)}"
                    })
                
                # Validate non-empty fields
                for field, value in improvement_data.items():
                    if value is not None and str(value).strip() == "":
                        return json.dumps({
                            "success": False,
                            "error": f"Field '{field}' cannot be empty"
                        })
                    
                if "facilitator" in improvement_data:
                    if str(improvement_data["facilitator"]) not in users:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: User 'facilitator' not found"
                        })
                    
                    if users[str(improvement_data["facilitator"])]["status"] != "active":
                        return json.dumps({
                            "success": False,
                            "error": "Halt: User 'facilitator' must be active"
                        })
                    
                if "status" in improvement_data:
                    if improvement_data["status"] not in valid_pir_statuses:
                        return json.dumps({
                            "success": False,
                            "error": f"Halt: Invalid status. Must be one of: {', '.join(valid_pir_statuses)}"
                        })
                    
                # Get current PIR record
                current_pir = post_incident_reviews[str(review_id)]
                # Update PIR record with modified information
                updated_pir = current_pir.copy()
                for key, value in improvement_data.items():
                    if key == "facilitator":
                        updated_pir[key] = str(value)
                    else:
                        updated_pir[key] = value

                post_incident_reviews[str(review_id)] = updated_pir

                return json.dumps({
                    "success": True,
                    "action": "update",
                    "review_id": str(review_id),
                    "message": f"Post incident review {review_id} updated successfully",
                    "improvement_data": updated_pir
                })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_improvement",
                "description": "Create or update root cause analysis or post incident review records in the incident management system. For root cause analyses, manages RCA workflow including assignment, analysis methods, and approval processes. For post incident reviews, handles review scheduling, facilitation, and documentation of lessons learned.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Entity type to manage: 'root_cause_analyses' for root cause analyses, 'post_incident_reviews' for post incident reviews"
                        },
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to create new record, 'update' to modify existing record"
                        },
                        "improvement_data": {
                            "type": "object",
                            "description": "Improvement data object containing fields for creating or updating RCA or PIR records",
                            "properties": {
                                "associated_incident_id": {
                                    "type": "string",
                                    "description": "Related incident identifier for RCA (required for RCA create, cannot be empty, must exist and be resolved/closed with P1/P2 severity)"
                                },
                                "rca_title": {
                                    "type": "string",
                                    "description": "Title of the root cause analysis (required for RCA create, cannot be empty)"
                                },
                                "assigned_to": {
                                    "type": "string",
                                    "description": "User identifier assigned to conduct the analysis (required for RCA create, cannot be empty, must be active user)"
                                },
                                "due_date": {
                                    "type": "string",
                                    "description": "Date by which analysis should be completed (required for RCA create, cannot be empty)"
                                },
                                "reported_by": {
                                    "type": "string",
                                    "description": "User identifier who reported the need for RCA (required for RCA create, cannot be empty, must be active user)"
                                },
                                "analysis_method": {
                                    "type": "string",
                                    "description": "Analysis methodology used (optional for RCA). Must be one of: 5_whys, fishbone, timeline, fault_tree, kepner_tregoe"
                                },
                                "root_cause_summary": {
                                    "type": "string",
                                    "description": "Summary of identified root cause (optional for RCA, cannot be empty if provided)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status (optional, defaults based on entity type). For RCA: assigned, in_progress, completed, approved. For PIR: scheduled, completed, cancelled"
                                },
                                "completed_at": {
                                    "type": "string",
                                    "description": "Timestamp when analysis was completed (optional for RCA, cannot be empty if provided)"
                                },
                                "approved_by": {
                                    "type": "string",
                                    "description": "User identifier who approved the analysis (optional for RCA, required when status is approved, must be active user)"
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "Related incident identifier for PIR (required for PIR create, cannot be empty, must exist and be closed)"
                                },
                                "scheduled_date": {
                                    "type": "string",
                                    "description": "Date for the post-incident review (required for PIR create, cannot be empty)"
                                },
                                "facilitator": {
                                    "type": "string",
                                    "description": "User who will facilitate the review (required for PIR create, cannot be empty, must be active user)"
                                },
                                "review_notes": {
                                    "type": "string",
                                    "description": "Notes for the review (required for PIR create, cannot be empty)"
                                },
                                "lessons_learned": {
                                    "type": "string",
                                    "description": "Lessons learned from the incident (required for PIR create, cannot be empty)"
                                },
                                "action_items": {
                                    "type": "string",
                                    "description": "Action items identified (required for PIR create, cannot be empty)"
                                },
                                "created_by": {
                                    "type": "string",
                                    "description": "User identifier who created the post incident review (required for PIR create, cannot be empty, must be active user)"
                                }
                            }
                        },
                        "rca_id": {
                            "type": "string",
                            "description": "Unique identifier of the RCA. Required for RCA update action only."
                        },
                        "review_id": {
                            "type": "string",
                            "description": "Unique identifier of the PIR. Required for PIR update action only."
                        }
                    },
                    "required": ["entity_type", "action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageWorkOrders(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        work_order_data: Optional[Dict[str, Any]] = None,
        work_order_id: Optional[str] = None
    ) -> str:
        """
        Create or update work order records.

        Actions:
        - create: Create a new work order record (requires work_order_data)
        - update: Update an existing work order record (requires work_order_id and work_order_data)
        """

        def generate_id(table: Dict[str, Any], prefix: str) -> str:
            if not table:
                return f"{prefix}1"
            max_id = 0
            for k in table.keys():
                try:
                    num = int(k[len(prefix):])
                    if num > max_id:
                        max_id = num
                except ValueError:
                    continue
            return f"{prefix}{max_id + 1}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        work_orders = data.get("work_orders", {})
        users = data.get("users", {})
        change_requests = data.get("change_requests", {})
        incidents = data.get("incidents", {})

        # Define valid enums based on DBML schema
        valid_statuses = ["pending", "in_progress", "completed", "cancelled"]

        if action == "create":
            if not work_order_data:
                return json.dumps({
                    "success": False,
                    "error": "work_order_data is required for create action"
                })

            # Validate required fields as per DBML schema
            required_fields = [
                "work_order_number", "title", "description", "assigned_to", "scheduled_date"
            ]
            missing_fields = [field for field in required_fields if field not in work_order_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not work_order_data[field] or (isinstance(work_order_data[field], str) and str(work_order_data[field]).strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate work_order_number uniqueness
            work_order_number = str(work_order_data["work_order_number"]).strip()
            for work_order in work_orders.values():
                if work_order["work_order_number"].lower() == work_order_number.lower():
                    return json.dumps({
                        "success": False,
                        "error": f"Work order with number '{work_order_number}' already exists."
                    })

            # Status is 'pending' by default, if provided, must be valid
            status = work_order_data.get("status", "pending")
            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{status}'. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate assigned_to FK
            assigned_to = str(work_order_data["assigned_to"]).strip().strip('"')
            if assigned_to not in users:
                return json.dumps({
                    "success": False,
                    "error": f"Assigned to user '{assigned_to}' not found"
                })
            if users[assigned_to]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"Assigned to user '{assigned_to}' is not active"
                })

            # Validate change_id FK if provided (nullable)
            change_id = work_order_data.get("change_id")
            if change_id:
                change_id = str(change_id).strip().strip('"')
                if change_id not in change_requests:
                    return json.dumps({
                        "success": False,
                        "error": f"Change request '{change_id}' not found"
                    })

            # Validate incident_id FK if provided (nullable)
            incident_id = work_order_data.get("incident_id")
            if incident_id:
                incident_id = str(incident_id).strip().strip('"')
                if incident_id not in incidents:
                    return json.dumps({
                        "success": False,
                        "error": f"Incident '{incident_id}' not found"
                    })

            new_id = generate_id(work_orders, "WO")
            new_work_order = {
                "work_order_id": new_id,
                "work_order_number": work_order_number,
                "change_id": change_id if change_id else None,
                "incident_id": incident_id if incident_id else None,
                "title": work_order_data["title"],
                "description": work_order_data["description"],
                "assigned_to": assigned_to,
                "status": status,
                "scheduled_date": work_order_data["scheduled_date"],
                "completed_at": work_order_data.get("completed_at"),  # Nullable
                "created_at": timestamp
            }
            work_orders[new_id] = new_work_order
            return json.dumps({
                "success": True,
                "action": "create",
                "work_order_id": new_id,
                "work_order_data": new_work_order
            })

        elif action == "update":
            if not work_order_id:
                return json.dumps({
                    "success": False,
                    "error": "work_order_id is required for update action"
                })
            work_order_id = str(work_order_id).strip().strip('"')
            if work_order_id not in work_orders:
                return json.dumps({
                    "success": False,
                    "error": f"Work order '{work_order_id}' not found"
                })

            if not work_order_data:
                return json.dumps({
                    "success": False,
                    "error": "work_order_data is required for update action"
                })

            # Allowed fields for update (all except work_order_id, created_at)
            allowed_fields = [
                "work_order_number", "change_id", "incident_id", "title", 
                "description", "assigned_to", "status", "scheduled_date", "completed_at"
            ]
            invalid_fields = [field for field in work_order_data if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for update: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields (nullable fields can be None)
            # NOT NULL fields: work_order_number, title, description, assigned_to, scheduled_date
            nullable_fields = ["change_id", "incident_id", "completed_at"]
            for field, value in work_order_data.items():
                if field not in nullable_fields and (value is None or (isinstance(value, str) and str(value).strip() == "")):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
                elif field in nullable_fields and (isinstance(value, str) and str(value).strip() == ""):
                    work_order_data[field] = None  # Treat empty string as null for nullable fields

            # Validate work_order_number uniqueness if updated
            if "work_order_number" in work_order_data:
                updated_work_order_number = str(work_order_data["work_order_number"]).strip()
                for existing_work_order_id, work_order in work_orders.items():
                    if existing_work_order_id != work_order_id and work_order["work_order_number"].lower() == updated_work_order_number.lower():
                        return json.dumps({
                            "success": False,
                            "error": f"Work order with number '{updated_work_order_number}' already exists."
                        })
                work_order_data["work_order_number"] = updated_work_order_number

            # Validate status enum if provided
            if "status" in work_order_data and work_order_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{work_order_data['status']}'. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate assigned_to FK if provided
            if "assigned_to" in work_order_data:
                assigned_to = str(work_order_data["assigned_to"]).strip().strip('"')
                if assigned_to not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Assigned to user '{assigned_to}' not found"
                    })
                if users[assigned_to]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Assigned to user '{assigned_to}' is not active"
                    })
                work_order_data["assigned_to"] = assigned_to

            # Validate change_id FK if provided
            if "change_id" in work_order_data and work_order_data["change_id"] is not None:
                change_id = str(work_order_data["change_id"]).strip().strip('"')
                if change_id not in change_requests:
                    return json.dumps({
                        "success": False,
                        "error": f"Change request '{change_id}' not found"
                    })
                work_order_data["change_id"] = change_id

            # Validate incident_id FK if provided
            if "incident_id" in work_order_data and work_order_data["incident_id"] is not None:
                incident_id = str(work_order_data["incident_id"]).strip().strip('"')
                if incident_id not in incidents:
                    return json.dumps({
                        "success": False,
                        "error": f"Incident '{incident_id}' not found"
                    })
                work_order_data["incident_id"] = incident_id

            updated_work_order = work_orders[work_order_id].copy()
            for key, value in work_order_data.items():
                updated_work_order[key] = value
            
            work_orders[work_order_id] = updated_work_order
            return json.dumps({
                "success": True,
                "action": "update",
                "work_order_id": work_order_id,
                "work_order_data": updated_work_order
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_work_orders",
                "description": "Create or update work order records in the system. Work orders represent scheduled tasks or maintenance activities that may be related to change requests or incidents.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to add a new work order, 'update' to modify an existing work order."
                        },
                        "work_order_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating or updating a work order.",
                            "properties": {
                                "work_order_number": {
                                    "type": "string",
                                    "description": "A unique identifier for the work order (required for create, must be unique, cannot be empty). Updatable."
                                },
                                "change_id": {
                                    "type": "string",
                                    "description": "The ID of the related change request (optional). Must refer to an existing change request if provided. Updatable, can be set to null."
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "The ID of the related incident (optional). Must refer to an existing incident if provided. Updatable, can be set to null."
                                },
                                "title": {
                                    "type": "string",
                                    "description": "A brief, descriptive title for the work order (required for create, cannot be empty). Updatable."
                                },
                                "description": {
                                    "type": "string",
                                    "description": "A detailed description of the work order (required for create, cannot be empty). Updatable."
                                },
                                "assigned_to": {
                                    "type": "string",
                                    "description": "The user ID of the person assigned to complete the work order (required for create). Must refer to an existing active user. Updatable."
                                },
                                "status": {
                                    "type": "string",
                                    "description": "The current status of the work order (optional for create, defaults to 'pending'). Must be one of: pending, in_progress, completed, cancelled. Updatable.",
                                    "enum": ["pending", "in_progress", "completed", "cancelled"]
                                },
                                "scheduled_date": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the work order is scheduled to be executed (required for create, cannot be empty). Updatable."
                                },
                                "completed_at": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the work order was completed (optional). Updatable, can be set to null."
                                }
                            }
                        },
                        "work_order_id": {
                            "type": "string",
                            "description": "The unique identifier of the work order to update. Required for 'update' action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageIncidentReports(Tool):
    """
    Create and update incident reports for tracking and documenting incidents.
    """
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        report_id: Optional[str] = None,
        incident_id: Optional[str] = None,
        report_title: Optional[str] = None,
        report_type: Optional[str] = None,
        report_content: Optional[str] = None,
        generated_by: Optional[str] = None,
        report_status: Optional[str] = None
    ) -> str:
        """
        Create or update incident report records.

        Actions:
        - create: Create new incident report (requires incident_id, report_title, report_type, report_content, generated_by)
        - update: Update existing incident report (requires report_id and at least one field to update)
        """
        def generate_id(table: Dict[str, Any]) -> str:
            """Generates a new unique ID for a record."""
            if not table:
                return "1"
            return str(max(int(k) for k in table.keys()) + 1)

        def generate_report_number(report_id: str) -> str:
            """Generate a formatted report number."""
            return f"RPT{report_id.zfill(7)}"

        timestamp = "2025-10-01T12:00:00"
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })
        
        reports = data.get("incident_reports", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        valid_report_types = ["post_incident_review", "client_impact", "compliance"]
        valid_statuses = ["draft", "completed", "approved", "archived"]
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": "Invalid action. Must be 'create' or 'update'"
            })

        if action == "create":
            # Validate required fields are provided
            if not all([incident_id, report_title, report_type, report_content, generated_by]):
                missing_fields = []
                if not incident_id: missing_fields.append("incident_id")
                if not report_title: missing_fields.append("report_title")
                if not report_type: missing_fields.append("report_type")
                if not report_content: missing_fields.append("report_content")
                if not generated_by: missing_fields.append("generated_by")
                
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })

            # Validate non-empty required fields
            if not str(incident_id).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'incident_id' cannot be empty"
                })
            
            if not str(report_title).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'report_title' cannot be empty"
                })
            
            if not str(report_type).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'report_type' cannot be empty"
                })
            
            if not str(report_content).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'report_content' cannot be empty"
                })
            
            if not str(generated_by).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'generated_by' cannot be empty"
                })

            # Validate incident exists
            if str(incident_id) not in incidents:
                return json.dumps({
                    "success": False,
                    "error": f"Incident with ID {incident_id} not found"
                })

            # Validate user exists and is active
            if str(generated_by) not in users:
                return json.dumps({
                    "success": False,
                    "error": f"User with ID {generated_by} not found"
                })
            if users[str(generated_by)]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"User with ID {generated_by} is not active"
                })

            if report_type not in valid_report_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid report_type. Must be one of: {', '.join(valid_report_types)}"
                })

            new_id = generate_id(reports)
            report_number = generate_report_number(new_id)
            new_report = {
                "report_id": new_id,
                "report_number": report_number,
                "report_title": report_title,
                "incident_id": str(incident_id),
                "report_type": report_type,
                "report_content": report_content,
                "generated_by": str(generated_by),
                "generation_date": timestamp,
                "report_status": "draft"
            }
            reports[new_id] = new_report

            return json.dumps({
                "success": True,
                "action": "create",
                "report_id": new_id,
                "report_number": report_number,
                "report_data": new_report
            })

        elif action == "update":
            if not report_id:
                return json.dumps({
                    "success": False,
                    "error": "report_id is required for update action"
                })

            if str(report_id) not in reports:
                return json.dumps({
                    "success": False,
                    "error": f"Report with ID {report_id} not found"
                })

            # Validate at least one field is being updated
            if all(v is None for v in [report_title, report_type, report_content, report_status]):
                return json.dumps({
                    "success": False,
                    "error": "At least one field must be provided for update"
                })

            existing_report = reports[str(report_id)]

            # Validate non-empty fields
            if report_title is not None and not str(report_title).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'report_title' cannot be empty"
                })

            if report_type is not None and not str(report_type).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'report_type' cannot be empty"
                })

            if report_content is not None and not str(report_content).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'report_content' cannot be empty"
                })

            if report_status is not None and not str(report_status).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'report_status' cannot be empty"
                })

            if report_type is not None:
                if report_type not in valid_report_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid report_type. Must be one of: {', '.join(valid_report_types)}"
                    })
                existing_report["report_type"] = report_type

            if report_title is not None:
                existing_report["report_title"] = report_title

            if report_content is not None:
                existing_report["report_content"] = report_content

            if report_status is not None:
                if report_status not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid report_status. Must be one of: {', '.join(valid_statuses)}"
                    })
                existing_report["report_status"] = report_status

            return json.dumps({
                "success": True,
                "action": "update",
                "report_id": str(report_id),
                "report_number": existing_report["report_number"],
                "report_data": existing_report
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_incident_reports",
                "description": "Create or update incident reports for formal documentation and tracking. Manages comprehensive incident reporting including post-incident reviews, client impact assessments, and compliance documentation. Validates report types, user permissions, and maintains report status workflow.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to create new report or 'update' to modify existing report"
                        },
                        "report_id": {
                            "type": "string",
                            "description": "Unique identifier of the report. Required for update action only."
                        },
                        "incident_id": {
                            "type": "string",
                            "description": "Identifier of the incident this report belongs to (required for create, cannot be empty, must exist in system)"
                        },
                        "report_title": {
                            "type": "string",
                            "description": "Title or summary of the report (required for create, cannot be empty)"
                        },
                        "report_type": {
                            "type": "string",
                            "description": "Type of incident report (required for create). Must be one of: post_incident_review, client_impact, compliance"
                        },
                        "report_content": {
                            "type": "string",
                            "description": "Detailed content of the report (required for create, cannot be empty)"
                        },
                        "generated_by": {
                            "type": "string",
                            "description": "User identifier who created the report (required for create, cannot be empty, must be active user)"
                        },
                        "report_status": {
                            "type": "string",
                            "description": "Status of the report (optional for update). Must be one of: draft, completed, approved, archived"
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# Policy:
# **Incident Management Policy & SOPs**

The current time is 2025-10-04 12:00:00 UTC

## **Introduction**

This document defines the operational guide for an Incident Management automation agent. It is designed for single-turn execution: each procedure must be self-contained and completed in one interaction.

**Validation first**: All inputs must be validated. If any required element is missing or invalid, the process halts with a clear error message.

**Logging**: Every INSERT, UPDATE, or DELETE operation must generate an audit_log entry with entity_type, entity_id, operation_type, changed_by_id, field_name, old_value, and new_value. .

**Role-based permissions**: Only designated roles may perform an action; other roles may do so only with explicit approval from a role authorized to perform it.

### **What is "Halt"?**

When a process halts, the agent immediately stops execution of the current SOP and returns a message to the user that says "cannot continue the process" \- therefore no further steps within that SOP are performed. The agent will use the **transfer_to_human** tool to transfer the request to a human agent.

## **Standard Operating Procedures**

### **Entities Lookup / Discovery**

Use this whenever you need to find, search, or verify entities; fetch details for validation or reporting; or when another SOP needs entity information first.

1. **Obtain:**  
* **Required**: entity_type  
* **Optional**: Include any filters for that entity (e.g., ID, status, dates) used to narrow the search.  
2. **Pick one discovery tool that matches the entity type:**  
* For clients, call **discover_clients** (filter by client_id, client_name, client_type, industry, country, status)  
* For **vendors**, call **discover_vendors** (filter by vendor_id, vendor_name, vendor_type, status)  
* For **users**, call **discover_users**  (filter by user_id, email, role, client_id, vendor_id, status)  
* For **products**, call **discover_products**  (filter by product_id, product_name, product_type, version, vendor_support_id, status)  
* For **infrastructure components**, call **discover_components** (filter by component_id, product_id, component_name, component_type, environment, location, port_number, status)  
* For **client subscriptions,** **sla agreements** call **discover_subscription_agreements** (filter by subscription_id, client_id, product_id, subscription_type, start_date, end_date, sla_tier, rto_hours, status, sla_id, subscription_id, severity_level, response_time_minutes, resolution_time_hours, availability_percentage).  
* For **incidents, post incident reviews** call **discover_incident_entities** (filter by incident_id, incident_code, client_id, component_id, reporter_id, assigned_manager_id, severity, status, category, detection_source, detected_at, impact, urgency).  
* For **workarounds**, call **discover_workaround_entities** (filter by workaround_id, incident_id, implemented_by_id, effectiveness, status, implemented_at)  
* For **root cause analysis**, call **discover_rca_entities** (filter by rca_id, incident_id, analysis_method, conducted_by_id, completed_at, status)  
* For **escalations**, call **discover_escalation_entities** (filter by escalation_id, escalation_code, incident_id, escalated_by_id, escalated_to_id, escalation_reason, escalation_level, escalated_at, acknowledged_at, resolved_at, status)  
* For **change requests, rollback requests**, call **discover_change_entities** (filter by change_id, change_code, rollback_id, incident_id, requested_by_id, approved_by_id, change_type, status)  
* For **metrics**, call **discover_metrics_entities** (filter by metric_id, incident_id, metric_type, value_minutes, target_minutes, recorded_at)  
* For **incident reports**, call **discover_incident_entities** (filter by report_id, incident_id, report_type, generated_by_id, generated_at, status)  
* For communications, call **discover_communication_entities** (filter by communication_id, incident_id, sender_id, recipient_id, recipient_type, communication_type, sent_at, delivery_status, pir_id, incident_id, facilitator_id, scheduled_date, timeline_accuracy_rating, communication_effectiveness_rating, technical_response_rating)  
* For **knowledge base articles**, call **discover_kb_article_entities** (filter by article_id, incident_id, created_by_id, reviewed_by_id, article_type, category, view_count, status)  
3. **Run the selected discovery tool and wait for the results.**  
4. **Acquire the result** \- whether it is a single match, multiple matches, or none.

**Halt, and use transfer_to_human if any of these occur:**

* The entity_type is missing or invalid  
* The requester is not authorized  
* The discovery tool fails to execute

---

## **Client Management Operations**

### **Create Client Record**

1. **Obtain:**  
* **Required**: client_name, client_type (enterprise, mid_market, small_business, startup), country  
* **Optional**: registration_number, contact_email, industry, status (active, inactive, suspended)  
* **Validate** that client_name and registration_number (if provided) are unique using **discover_clients**.  
2. **Create** the client record using **manage_clients**.  
3. **Create** an audit entry for client creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Client name or registration number already exists  
* Invalid client_type or country  
* Client creation failed  
* Audit trail logging failure

---

### **Update Client Information**

**1.   Obtain:**

* **Required**: client_id  
* **Optional**: client_name, registration_number, contact_email, client_type (enterprise, mid_market, small_business, startup), industry, country, status (active, inactive, suspended) (at least one must be provided)  
* **Validate** that client exists and is accessible to the user using **discover_clients**.

2**. Verify** that the approval to conduct the action is present using **check_approval**    (system_administrator or incident_manager or account_manager approval required). 

**3. If updating** client_name or registration_number, validate uniqueness using **discover_clients**.

**4. Update** the client record using **manage_clients**.

**5. Create** an audit entry for client update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Client not found  
* User not authorized for client updates  
* New client_name or registration_number already exists  
* Invalid client_type or status  
* Client update failed  
* Audit trail logging failure

---

**User Management Operations**

### **Create User Account**

1. **Obtain:**  
* **Required**: first_name, last_name, email, role (incident_manager, technical_support, account_manager, executive, vendor_contact, system_administrator, client_contact), timezone  
* **Optional**: phone, department, client_id, vendor_id, status (active, inactive, on_leave)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager approval required).  
3. **Validate** that email is unique using **discover_users**.  
4. **If client_id provided**, validate that client exists and has active status using **discover_clients**.  
5. **If vendor_id provided**, validate that vendor exists and has active status using **discover_vendors**.  
6. **Create** the user account using **manage_users**.  
7. **Create** an audit entry for user creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Email already exists  
* Client or vendor not found or inactive  
* Invalid role or timezone  
* Approval missing for elevated role creation  
* User creation failed  
* Audit trail logging failure

---

### **Update User Information**

1. **Obtain:**  
* **Required**: user_id  
* **Optional**: first_name, last_name, email, phone, role (incident_manager, technical_support, account_manager, executive, vendor_contact, system_administrator, client_contact), department, client_id, vendor_id, timezone, status (active, inactive, on_leave) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager approval required).  
3. **Validate** that user exists using **discover_users**.  
4. **If updating email**, validate uniqueness using **discover_users**.  
5. **Update** the user record using **manage_users**.  
6. **Create** an audit entry for user update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing approval for updating user information  
* User not found  
* New email already exists  
* Invalid role or status  
* Approval missing for role elevation  
* User update failed  
* Audit trail logging failure

---

## **Vendor Management Operations**

### **Create Vendor Record**

1. **Obtain:**  
* **Required**: vendor_name, vendor_type (cloud_provider, payment_processor, software_vendor, infrastructure_provider, security_vendor)  
* **Optional**: contact_email,,contact_phone, status (active, inactive, suspended).  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager or executive approval required)  
3. **Validate** that vendor_name is unique using **discover_vendors**.  
4. **Create** the vendor record using **manage_vendors**.  
5. **Create** an audit entry for vendor creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for vendor creation  
* Missing or invalid inputs  
* Vendor name already exists  
* Invalid vendor_type  
* Vendor creation failed  
* Audit trail logging failure

---

### **Update Vendor Information**

1. **Obtain:**  
* **Required**: vendor_id  
* **Optional**: vendor_name, vendor_type (cloud_provider, payment_processor, software_vendor, infrastructure_provider, security_vendor), contact_email, contact_phone, status (active, inactive, suspended) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager or executive approval required).  
3. **Validate** that vendor exists using **discover_vendors**.  
4. **If updating vendor_name**, validate uniqueness using **discover_vendors**.  
5. **Update** the vendor record using **manage_vendors**.  
6. **Create** an audit entry for vendor update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for vendor update  
* Vendor not found  
* New vendor_name already exists  
* Invalid vendor_type or status  
* Vendor update failed  
* Audit trail logging failure

---

## **Product and Infrastructure Operations**

### **Create Product Record**

1. **Obtain:**  
* **Required**: product_name, product_type (payment_processing, banking_system, api_gateway, data_integration, reporting_platform, security_service, backup_service, monitoring_tool)  
* **Optional**: version, vendor_support_id, status (active, deprecated, maintenance)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager or executive approval required)  
3. **Validate** that product_name is unique using **discover_products**.  
4. **If vendor_support_id provided**, validate that vendor exists and has active status using **discover_vendors**.  
5. **Create** the product record using **manage_products**.  
6. **Create** an audit entry for product creation using **log_audit_records**

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Product name already exists  
* Vendor not found or inactive  
* Invalid product_type  
* Product creation failed  
* Audit trail logging failure

## **Update Product Record**

1. **Obtain:**  
* **Required**: product_id  
* **Optional**: product_name, product_type (payment_processing, banking_system, api_gateway, data_integration, reporting_platform, security_service, backup_service, monitoring_tool), version, vendor_support_id, status (active, deprecated, maintenance) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager or executive approval required).  
3. **Validate** that product exists using **discover_products**.  
4. **If updating product_name**, validate uniqueness using **discover_products**.  
5. **If updating vendor_support_id**, validate that vendor exists and has active status using **discover_vendors**.  
6. **Update** the product record using **manage_products**.  
7. **Create** an audit entry for product update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for product update  
* Product not found  
* New product_name already exists  
* Vendor not found or inactive (if updating vendor_support_id)  
* Invalid product_type or status  
* Product update failed  
* Audit trail logging failure

---

## **Create Infrastructure Component**

1. **Obtain:**  
* **Required**: component_name, component_type (sftp_server, api_endpoint, database, load_balancer, firewall, authentication_service, payment_gateway, file_storage, monitoring_system), environment (production, staging, development, test)  
* **Optional**: product_id, location, port_number, status (online, offline, maintenance, degraded)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or technical_support or incident_manager approval required).  
3. **Validate** that component_name is unique within the specified product using **discover_components**.  
4. **If product_id provided**, validate that product exists and has active status using **discover_products**.  
5. **Create** the infrastructure component using **manage_components**.  
6. **Create** an audit entry for component creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for component creation  
* Missing or invalid inputs  
* Product not found or inactive (if product_id specified)  
* Component name already exists within product  
* Invalid component_type, environment, or status  
* Component creation failed  
* Audit trail logging failure

## **Update Infrastructure Component**

1. **Obtain:**  
* **Required**: component_id  
* **Optional**: component_name, component_type (sftp_server, api_endpoint, database, load_balancer, firewall, authentication_service, payment_gateway, file_storage, monitoring_system), product_id, environment (production, staging, development, test), location, port_number, status (online, offline, maintenance, degraded) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or technical_support or incident_manager approval required).  
3. **Validate** that component exists using **discover_components**.  
4. **If updating component_name**, validate uniqueness within the specified product using **discover_components**.  
5. **If updating product_id**, validate that product exists and has active status using **discover_products**.  
6. **Update** the infrastructure component using **manage_components**.  
7. **Create** an audit entry for component update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for component update  
* Component not found  
* Product not found or inactive (if updating product_id)  
* New component_name already exists within product  
* Invalid component_type, environment, or status  
* Component update failed  
* Audit trail logging failure

---

## **Subscription and Service Level Management**

### **Create Client Subscription**

1. **Obtain:**  
* **Required**: client_id, product_id, subscription_type (full_service, limited_service, trial, custom), start_date, sla_tier (premium, standard, basic), rto_hours  
* **Optional**: end_date, status (active, expired, cancelled, suspended)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (account_manager or incident_manager or executive approval required).  
3. **Validate** that client exists and has active status using **discover_clients**.  
4. **Validate** that product exists and has active status using **discover_products**.  
5. **Create** the subscription record using **manage_client_subscriptions**.  
6. **Create** an audit entry for subscription creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for subscription creation  
* Missing or invalid inputs  
* Client not found or inactive  
* Product not found or inactive  
* Invalid subscription_type, sla_tier, or rto_hours  
* Subscription creation failed  
* Audit trail logging failure

---

### **Update Client Subscription**

1. **Obtain:**  
* **Required**: subscription_id  
* **Optional**: subscription_type (full_service, limited_service, trial, custom), start_date, end_date, sla_tier (premium, standard, basic), rto_hours, status (active, expired, cancelled, suspended) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (account_manager or incident_manager or executive approval required).  
3. **Validate** that subscription exists using **discover_subscription_agreements**.  
4. **Update** the subscription record using **manage_client_subscriptions**.  
5. **Create** an audit entry for subscription update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for subscription update  
* Subscription not found  
* Invalid subscription_type, sla_tier, status, or dates  
* Subscription update failed  
* Audit trail logging failure

---

### **Create SLA Agreement**

1. **Obtain:**  
* **Required**: subscription_id, severity_level (P1, P2, P3, P4), response_time_minutes, resolution_time_hours  
* **Optional**: availability_percentage  
2. **Verify** that the approval to conduct the action is present using **check_approval** (account_manager or system_administrator or executive approval required).  
3. **Validate** that subscription exists and has active status using **discover_subscription_agreements**.  
4. **Validate** that response and resolution times align with subscription tier using the following guidelines:  
* **Premium tier**: P1: 15-30 min response, 2-4 hrs resolution; P2: 1-2 hrs response, 8-24 hrs resolution; P3: 4-8 hrs response, 48-72 hrs resolution; P4: 24-48 hrs response, 128 hrs resolution  
* **Standard tier**: P1: 1-2 hrs response, 8-24 hrs resolution; P2: 4-8 hrs response, 24-48 hrs resolution; P3: 24 hrs response, 72-120 hrs resolution; P4: 48-72 hrs response, 168 hrs resolution  
* **Basic tier**: P1: 4-8 hrs response, 24-48 hrs resolution; P2: 24 hrs response, 72-120 hrs resolution; P3: 48-72 hrs response, 5-10 days resolution; P4: 5-7 days response, 2 weeks resolution  
5. **Create** the SLA agreement using **manage_sla_agreements**.  
6. **Create** an audit entry for SLA creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for SLA creation  
* Missing or invalid inputs  
* Subscription not found or inactive  
* Response/resolution times don't align with subscription tier  
* Invalid severity_level or availability_percentage  
* SLA creation failed  
* Audit trail logging failure

### **Update SLA Agreement**

1. **Obtain:**  
* **Required**: sla_id  
* **Optional**: severity_level (P1, P2, P3, P4), response_time_minutes, resolution_time_hours, availability_percentage (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (account_manager or system_administrator or executive approval required).  
3. **Validate** that SLA agreement exists using **discover_subscription_agreements**.  
4. **Retrieve** the associated subscription to determine subscription tier.  
5. **If updating response_time_minutes or resolution_time_hours**, validate that new times align with subscription tier using the following guidelines:  
* **Premium tier**: P1: 15-30 min response, 2-4 hrs resolution; P2: 1-2 hrs response, 8-24 hrs resolution; P3: 4-8 hrs response, 48-72 hrs resolution; P4: 24-48 hrs response, 128 hrs resolution  
* **Standard tier**: P1: 1-2 hrs response, 8-24 hrs resolution; P2: 4-8 hrs response, 24-48 hrs resolution; P3: 24 hrs response, 72-120 hrs resolution; P4: 48-72 hrs response, 168 hrs resolution  
* **Basic tier**: P1: 4-8 hrs response, 24-48 hrs resolution; P2: 24 hrs response, 72-120 hrs resolution; P3: 48-72 hrs response, 5-10 days resolution; P4: 5-7 days response, 2 weeks resolution  
6. **Update** the SLA agreement using **manage_sla_agreements**.  
7. **Create** an audit entry for SLA update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for SLA update  
* SLA agreement not found  
* Response/resolution times don't align with subscription tier  
* Invalid severity_level or availability_percentage  
* SLA update failed  
* Audit trail logging failure

---

## **Incident Operations**

### **Create Incident**

1. **Obtain:**  
* **Required**: title, reporter_id, client_id, category (system_outage, performance_degradation, security_incident, data_corruption, integration_failure, network_issue, hardware_failure, software_bug, configuration_error, capacity_issue, backup_failure, authentication_failure, api_error, database_issue, service_unavailable) , impact (critical, high, medium, low), detection_source(client_reported,internally_detected, monitoring_alert,vendor_reported,scheduled_maintenance,emergency_maintanence), urgency (critical, high, medium, low), detected_at  
* Optional: assigned_manager_id, component_id, severity(P1,P2,P3,P4), status(open,in_progress,resolved,closed) , is_recurring,downtime_minutes,sla_breach,rto_breach,closed_at,resolved_at  
2. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or technical_support or system_administrator or executive approval required).  
3. **Validate** that reporter exists and has active status using **discover_users**.  
4. **Validate** that client exists and has active status using **discover_clients**.  
5. **If component_id provided**, validate that component exists using **discover_products**.  
6. **If assigned_manager_id provided**, validate that user exists using **discover_users**.  
7. **Create** the incident record using **manage_incidents.**  
8. **Create** an audit entry for incident creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for creating an incident  
* Missing or invalid inputs  
* Reporter not found or inactive  
* Client not found or inactive  
* Component not found  
* Assigned manager not found  
* Invalid category, impact, urgency, or severity  
* Incident creation failed  
* Audit trail logging failure

---

### **Update Incident**

1. **Obtain:**  
* **Required**: incident_id  
2. **Optional**: title,incident_code, assigned_manager_id, component_id, severity (P1, P2, P3, P4), status (open, in_progress, resolved, closed), impact (critical, high, medium, low), urgency (critical, high, medium, low), category (system_outage, performance_degradation, security_incident, data_corruption, integration_failure, network_issue, hardware_failure, software_bug, configuration_error, capacity_issue, backup_failure, authentication_failure, api_error, database_issue, service_unavailable), detection_source (client_reported, internally_detected, monitoring_alert, vendor_reported, scheduled_maintenance, emergency_maintenance), resolved_at, closed_at, rto_breach, sla_breach, is_recurring, downtime_minutes (at least one must be provided)  
3. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or technical_support or system_administrator or executive approval required)  
4. **Validate** that incident exists using **discover_incident_entities**.  
5. **If updating assigned_manager_id**, validate that user exists using **discover_users**.  
6. **Update** the incident record using **manage_incidents**.  
7. **Create** an audit entry for incident update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing to update incident  
* Incident not found  
* Assigned manager not found or has invalid role  
* Invalid severity, impact, urgency, category, or timestamps  
* Incident update failed  
* Audit trail logging failure

---

### **Resolve Incident**

1. **Obtain:**  
* **Required**: incident_id  
2. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or technical_support or executive approval required)  
3. **Validate** that incident exists and has status of in_progress or open using **discover_incident_entities**.  
4. **Update** incident status to resolved and set resolved_at timestamp using **manage_incidents**.  
5. **Create** an audit entry for incident resolution using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing approval to resolve incident  
* Incident not found or invalid status  
* Report generation failed  
* Incident resolution update failed  
* Audit trail logging failure

---

### **Close Incident**

1. **Obtain:**  
* **Required**: incident_id  
2. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or executive approval required).  
3. **Validate** that incident exists and has status of resolved using **discover_incident_entities**.  
4. **Update** incident status to closed and set closed_at timestamp using **manage_incidents**.  
5. **Create** an audit entry for incident closure using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing to close incident  
* Incident not found or status not resolved  
* Incident closure failed  
* Audit trail logging failure

---

## **Communication Management**

### **Create Communication**

1. **Obtain:**  
* **Required**: incident_id, sender_id, recipient_id, recipient_type (client, internal_team, executive, vendor, regulatory), communication_type (email, sms, phone_call, status_page, portal_update)  
* **Optional**: delivery_status (sent, delivered, failed, pending), sent_at  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( incident_manager or technical_support or system_administrator or account_manager approval required).  
3. **Validate** that incident exists using **discover_incident_entities**.  
4. **Validate** that sender and recipient exists and has active status using **discover_users**.  
5. **Create** the communication record using **manage_communications**.  
6. **Create** an audit entry for communication using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing approval  for creating communication record  
* Missing or invalid inputs  
* Incident not found  
* Sender not found or inactive  
* Recipient not found (if specified)  
* Invalid recipient_type or communication_type  
* Communication recording failed  
* Audit trail logging failure

## **Update Communication**

1. **Obtain:**  
* **Required**: communication_id  
* **Optional**: incident_id, sender_id, recipient_id, recipient_type (client, internal_team, executive, vendor, regulatory), communication_type (email, sms, phone_call, status_page, portal_update), delivery_status (sent, delivered, failed, pending), sent_at (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( incident_manager or technical_support or system_administrator or account_manager approval required).  
3. **Validate** that communication record exists using **discover_communication_entities**.  
4. If updating incident_id, sender_id, or recipient_id, validate that the communication record has delivery_status of "pending" using **discover_communication_entities**. These fields can only be updated when delivery_status is "pending".  
5. **If updating incident_id**, validate that incident exists using **discover_incident_entities**.  
6. **If updating sender_id**, validate that sender exists and has active status using **discover_users**.  
7. **If updating recipient_id**, validate that recipient exists using **discover_users**.  
8. **Update** the communication record using **manage_communications**.  
9. **Create** an audit entry for communication update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing to update communication record  
* Communication record not found  
* Incident not found (if updating incident_id)  
* Sender not found or inactive (if updating sender_id)  
* Recipient not found (if updating recipient_id)  
* Invalid recipient_type, communication_type, or delivery_status  
* Communication update failed  
* Audit trail logging failure

---

## **Workaround and Resolution Management**

### **Create Workaround**

1. **Obtain:**  
* **Required**: incident_id, implemented_by_id, effectiveness (complete, partial, minimal),implemented_at  
* **Optional**: status (active, inactive, replaced)   
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that incident exists and has status of open or in_progress using **discover_incident_entities**.  
4. **Create** the workaround record using **manage_work_arounds**.  
5. **Create** an audit entry for workaround implementation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Incident not found or invalid status  
* Implementing user not found or has invalid role  
* Invalid effectiveness level  
* Workaround creation failed  
* Audit trail logging failure

---

## **Update Workaround**

1. **Obtain:**  
* **Required**: workaround_id  
* **Optional**: effectiveness (complete, partial, minimal), status (active, inactive, replaced) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that workaround record exists using **discover_workaround_entities**.  
4. **Update** the workaround record using **manage_work_arounds**.  
5. **Create** an audit entry for workaround update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for workaround update  
* Workaround not found  
* Invalid effectiveness level or status  
* Workaround update failed  
* Audit trail logging failure

---

### **Conduct Root Cause Analysis**

1. **Obtain:**  
* **Required**: incident_id, conducted_by_id, analysis_method (five_whys, fishbone, timeline_analysis, fault_tree)  
* **Optional**: completed_at, status (in_progress, completed, approved)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that incident exists and has status of resolved or closed using **discover_incident_entities**.  
4. **Create** the root cause analysis record using **manage_root_cause_analysis**.  
5. **Create** an audit entry for RCA initiation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for conduct root cause analysis  
* Missing or invalid inputs  
* Incident not found or invalid status  
* Invalid analysis_method  
* RCA creation failed  
* Audit trail logging failure

---

### **Update Root Cause Analysis**

1. **Obtain:**  
* **Required**: rca_id  
* **Optional**: analysis_method (five_whys, fishbone, timeline_analysis, fault_tree), completed_at, status (in_progress, completed, approved) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that RCA record exists using **discover_rca_entities**.  
4. **Update** the RCA record using **manage_root_cause_analysis**.  
5. **Create** an audit entry for RCA update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for updating rca  
* RCA not found  
* Invalid analysis_method or status  
* RCA update failed  
* Audit trail logging failure

---

## **Escalation Management**

### **Create Escalation**

1. **Obtain:**  
* **Required**: incident_id, escalated_by_id, escalated_to_id, escalation_reason (sla_breach, severity_increase, resource_unavailable, executive_request, client_demand), escalated_at ,escalation_level (technical, management, executive, vendor)  
* **Optional**: acknowledged_at, resolved_at, status (open, acknowledged, resolved)  
2. **Validate** that incident exists and has status of open or in_progress using **discover_incident_entities**.  
3. **Validate** that escalated_by and escalated_to  user exists and has active status using **discover_users**.  
4. **Create** the escalation record using **manage_escalations**.  
5. **Create** an audit entry for escalation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Incident not found or invalid status  
* Escalating user not found or inactive  
* Escalation target user not found or has invalid role for level  
* Invalid escalation_reason or escalation_level  
* Escalation creation failed  
* Audit trail logging failure

---

### **Update Escalation Status**

1. **Obtain:**  
* **Required**: escalation_id  
* **Optional**: escalation_code, acknowledged_at, resolved_at, status (open, acknowledged, resolved) (at least one must be provided)  
2. **Validate** that escalation exists using **discover_escalation_entities**.  
3. **Update** the escalation record using **manage_escalations**.  
4. **Create** an audit entry for escalation update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Escalation not found  
* User not authorized to update escalation  
* Invalid status or timestamps  
* Escalation update failed  
* Audit trail logging failure

---

## **Change Management Operations**

### **Create Change Request**

1. **Obtain:**  
* **Required**: title, change_type (emergency, standard, normal), requested_by_id, risk_level (high, medium, low)  
* **Optional**: incident_id, approved_by_id, scheduled_start, scheduled_end, actual_start, actual_end, status (requested, approved, scheduled, in_progress, completed, failed, rolled_back)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required)..  
3. **If incident_id provided**, validate that incident exists using **discover_incident_entities**  
4. **Create** the change request record using **manage_change_requests**.  
5. **Create** an audit entry for change request using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing Approval for creating a change request  
* Missing or invalid inputs  
* Incident not found (if specified)  
* Invalid change_type, risk_level, or status  
* Change request creation failed  
* Audit trail logging failure

---

### **Update Change Request**

1. **Obtain:**  
* **Required**: change_id  
* **Optional**: title,change_code, change_type (emergency, standard, normal), approved_by_id, risk_level (high, medium, low), scheduled_start, scheduled_end, actual_start, actual_end, status (requested, approved, scheduled, in_progress, completed, failed, rolled_back) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that change request exists using **discover_change_entities**.  
4. **Update** the change request using **manage_change_requests**.  
5. **Create** an audit entry for change update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for update change request  
* Change request not found  
* User not authorized  
* Invalid change_type, risk_level, status, or timestamps  
* Change request update failed  
* Audit trail logging failure

---

### **Create Rollback Request**

1. **Obtain:**  
* **Required**: change_id, requested_by_id  
* **Optional**: incident_id, approved_by_id, executed_at, validation_completed, status (requested, approved, in_progress, completed, failed).  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or executive approval required)  
3. **Validate** that change request exists using **discover_change_entities**.  
4. **If incident_id provided**, validate that incident exists using **discover_incident_entities**.  
5. **Create** the rollback request using **manage_rollback_requests**.  
6. **Create** an audit entry for rollback request using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for rollback request  
* Missing or invalid inputs  
* Change request not found  
* Requesting user not found or has invalid role  
* Incident not found (if specified)  
* Rollback request creation failed  
* Audit trail logging failure

---

### **Update Rollback Request**

1. **Obtain:**  
* **Required**: rollback_id  
* **Optional**: rollback_code , approved_by_id, executed_at, validation_completed, status (requested, approved, in_progress, completed, failed) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (  incident_manager or system_administrator or executive approval required).  
3. **Validate** that rollback request exists using **discover_change_entities**.  
4. **Update** the rollback request using **manage_rollback_requests**.  
5. **Create** an audit entry for rollback update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing Approval for rollback request  
* Rollback request not found  
* User not authorized  
* Invalid status or timestamps  
* Rollback update failed  
* Audit trail logging failure

---

## **Metrics and Reporting Operations**

### **Record Performance Metrics**

1. **Obtain:**  
* **Required**: incident_id, metric_type (MTTA, MTTD, MTTR, MTTM, FTR), value_minutes  
* **Optional**: target_minutes, recorded_at  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( incident_manager or system_administrator approval required).  
3. **Validate** that incident exists and has status of resolved or closed using **discover_incident_entities**.  
4. **Create** the metrics record using **manage_metrics**.  
5. **Create** an audit entry for metrics recording using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Incident not found or invalid status  
* User not authorized  
* Invalid metric_type or value_minutes  
* Metrics recording failed  
* Audit trail logging failure

---

### **Generate Incident Report**

1. **Obtain:**  
* **Required**: incident_id, report_type ( executive_summary, technical_details,business_impact, compliance_report, post_mortem), generated_by_id  
* **Optional**: status (draft, completed, distributed)  
2. **Validate** that generating user exists and has appropriate role (incident_manager, executive) using **discover_users**..  
3. **Generate** the report using **manage_incident_reports**.  
4. **Create** an audit entry for report generation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing approval for generating report  
* Missing or invalid inputs  
* Invalid report_type or status  
* Incident not resolved/closed for post_mortem  
* Report generation failed  
* Audit trail logging failure

---

## **Knowledge Management Operations**

### **Create Knowledge Base Article**

1. **Obtain:**  
* **Required**: title, article_type (troubleshooting, resolution_steps, prevention_guide, faq), created_by_id, category(authentication_issues, payment_processing, api_integration, data_synchronization, system_outages, performance_degradation, security_incidents, backup_recovery, user_management, billing_issues, compliance_procedures, vendor_escalations, configuration_changes, monitoring_alerts, network_connectivity, database_issues, file_transfer_problems, reporting_errors, mobile_app_issues, browser_compatibility, third_party_integrations, scheduled_maintenance, emergency_procedures, client_onboarding, account_provisioning, sla_management, incident_response, change_management, capacity_planning, disaster_recovery)  
* **Optional**: incident_id, reviewed_by_id, view_count, status (draft, published, archived)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager approval required).  
3. **If incident_id provided**, validate that incident exists and is resolved or closed using **discover_incident_entities**.  
4. **If reviewed_by_id provided**, validate that reviewer exists and has appropriate role using **discover_users**.  
5. **Create** the knowledge base article using **manage_kb_articles**.  
6. **Create** an audit entry for article creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Creating user not found or has invalid role  
* Incident not found or invalid status (if specified)  
* Reviewer not found (if specified)  
* Invalid article_type, category, or status  
* Knowledge article creation failed  
* Audit trail logging failure

---

### **Update Knowledge Base Article**

1. **Obtain:**  
* **Required**: article_id  
* **Optional**: title, article_type (troubleshooting, resolution_steps, prevention_guide, faq), incident_id, reviewed_by_id, category, view_count, status (draft, published, archived) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager approval required).  
3. **Validate** that article exists using **discover_kb_article_entities**.  
4. **If updating reviewed_by_id**, validate that reviewer exists using **discover_users**.  
5. **Update** the knowledge article using **manage_kb_articles**.  
6. **Create** an audit entry for article update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Article not found  
* User not authorized  
* Reviewer not found (if specified)  
* Invalid article_type, category, or status  
* Article update failed  
* Audit trail logging failure

---

### **Create Post-Incident Review**

1. **Obtain:**  
* **Required**: incident_id, scheduled_date, facilitator_id  
* **Optional**: timeline_accuracy_rating, communication_effectiveness_rating, technical_response_rating, status (scheduled, completed, cancelled)   
2. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or executive approval required).  
3. **Validate** that incident exists and has status of resolved or closed using **discover_incident_entities**.  
4. **Validate** that facilitator exists and has an appropriate role (incident_manager, executive) using **discover_users**.  
5. **Create** the post-incident review record using **manage_post_incident_reviews**.  
6. **Create** an audit entry for PIR creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for PIR creation  
* Missing or invalid inputs  
* Incident not found or invalid status  
* Facilitator not found or has invalid role  
* Invalid scheduled_date or ratings  
* PIR creation failed  
* Audit trail logging failure

---

### **Update Post-Incident Review**

1. **Obtain:**  
* **Required**: pir_id  
* **Optional**: scheduled_date, facilitator_id, timeline_accuracy_rating, communication_effectiveness_rating, technical_response_rating, status (scheduled, completed, cancelled) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( incident_manager or executive approval required).  
3. **Validate** that PIR exists using **discover_incident_entities**..  
4. **Update** the post-incident review using **manage_post_incident_review**.  
5. **Create** an audit entry for PIR update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing  
* PIR not found  
* User not authorized  
* Invalid scheduled_date, ratings, or status  
* PIR update failed  
* Audit trail logging failure

---

## **Authority and Access Controls**

**Permission Validation**

All operations verify user authority based on:

* **role** field (incident_manager, technical_support, account_manager, executive, vendor_contact, system_administrator, client_contact)  
* **client_id** association through client_id field in users table  
* **vendor_id** association through vendor_id field in users table  
* **status** field must be active in users table

Operations requiring elevated permissions use a check_approval tool to verify proper authorization before proceeding.

# Database Schema:
// Use DBML to define your database structure
// Docs: https://dbml.dbdiagram.io/docs

// B2B Incident Management Database Schema
// This schema represents a comprehensive database for managing incidents,
// clients, products, infrastructure, and operational processes

Table clients {
  client_id string [primary key]
  client_name varchar(100) [not null]
  registration_number varchar(100)
  contact_email string
  client_type enum('enterprise','mid_market','small_business','startup') [not null]
  industry varchar(100)
  country varchar(100)
  status enum('active','inactive','suspended') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table vendors {
  vendor_id string [primary key]
  vendor_name varchar(100) [not null]
  vendor_type enum('cloud_provider','payment_processor','software_vendor','infrastructure_provider','security_vendor') [not null]
  contact_email varchar(100)
  contact_phone varchar(20)
  // escalation_contact varchar(100)
  status enum('active','inactive','suspended') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table users {
  user_id string [primary key]
  client_id string
  vendor_id string
  first_name varchar(100) [not null]
  last_name varchar(100) [not null]
  email varchar(320) [not null, unique]
  phone varchar(20)
  role enum('incident_manager','technical_support', 'account_manager','executive','vendor_contact','system_administrator', 'client_contact') [not null]
  department varchar(100)
  timezone varchar(50) [not null]
  status enum('active','inactive','on_leave') [not null, default: 'active']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table products {
  product_id string [primary key]
  product_name varchar(100) [not null]
  product_type enum('payment_processing','banking_system','api_gateway','data_integration','reporting_platform','security_service','backup_service','monitoring_tool') [not null]
  version varchar(50)
  vendor_support_id string // references vendors.vendor_id
  // internal_team_lead_id string // references users.user_id
  status enum('active','deprecated','maintenance') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table infrastructure_components {
  component_id string [primary key]
  product_id string
  component_name varchar(100) [not null]
  component_type enum('sftp_server','api_endpoint','database','load_balancer','firewall','authentication_service','payment_gateway','file_storage','monitoring_system') [not null]
  environment enum('production','staging','development','test') [not null]
  location varchar(100)
  port_number int
  status enum('online','offline','maintenance','degraded') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table client_subscriptions {
  subscription_id string [primary key]
  client_id string [not null]
  product_id string [not null]
  subscription_type enum('full_service','limited_service','trial','custom') [not null]
  start_date date [not null]
  end_date date
  sla_tier enum('premium','standard','basic') [not null]
  rto_hours int [not null] // Recovery Time Objective
  status enum('active','expired','cancelled','suspended') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table sla_agreements {
  sla_id string [primary key]
  subscription_id string [not null]
  severity_level enum('P1','P2','P3','P4') [not null]
  response_time_minutes int [not null]
  resolution_time_hours int [not null]
  availability_percentage decimal(5,2)
  created_at timestamp [not null, default: `NOW()`]
}

Table incidents {
  incident_id string [primary key]
  incident_code varchar(50) [unique, not null] // e.g., 'INC-2024-00123', 'INCIDENT-001234'
  title varchar(100) [not null]
  reporter_id string [not null]
  assigned_manager_id string
  client_id string [not null]
  component_id string
  // vendor_id string // For vendor-related incidents
  // vendor_ticket_id varchar(100) // Vendor's ticket reference
  // vendor_status varchar(100) // Status from vendor side
  // vendor_estimated_resolution timestamp // Vendor's ETA
  severity enum('P1','P2','P3','P4') [not null]
  status enum('open','in_progress','resolved','closed') [not null]
  impact enum('critical','high','medium','low') [not null]
  urgency enum('critical','high','medium','low') [not null]
  // category enum('client_onboarding','client_support','client_escalation','data_update','system_outage','security_breach','performance_issue','integration_failure','vendor_issue') [not null]
  
  // Technical categories - WHAT went wrong
  category enum(
    'system_outage',
    'performance_degradation',
    'security_incident',
    'data_corruption',
    'integration_failure',
    'network_issue',
    'hardware_failure',
    'software_bug',
    'configuration_error',
    'capacity_issue',
    'backup_failure',
    'authentication_failure',
    'api_error',
    'database_issue',
    'service_unavailable'
  ) [not null]
  
  // Business/operational context - WHO is affected and WHY it matters
  detection_source enum(
    'client_reported',
    'internally_detected',
    'monitoring_alert',
    'vendor_reported',
    'scheduled_maintenance',
    'emergency_maintenance'
  ) [not null]
  
  detected_at timestamp [not null]
  resolved_at timestamp
  closed_at timestamp
  rto_breach boolean [default: false]
  sla_breach boolean [default: false]
  is_recurring boolean [default: false]
  downtime_minutes int
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

// Table incident_updates {
//   update_id string [primary key]
//   incident_id string [not null]
//   updated_by_id string [not null]
//   update_type enum('status_change','severity_change','assignment','workaround','resolution','communication') [not null]
//   field_name varchar(50) [not null]
//   old_value varchar(100)
//   new_value varchar(100)
//   created_at timestamp [not null, default: `NOW()`]
// }

Table audit_log {
  audit_id string [primary key]
  entity_type varchar(100) [not null] // Which table was modified (e.g., 'incidents', 'clients', 'users')
  entity_id string [not null] // ID of the record that changed
  operation_type enum('INSERT','UPDATE','DELETE') [not null]
  changed_by_id string [not null] // User who made the change
  field_name varchar(100) // Specific field that changed (can be null for multi-field updates)
  old_value text // Previous value
  new_value text // New value
  created_at timestamp [not null, default: `NOW()`]
}

Table workarounds {
  workaround_id string [primary key]
  incident_id string [not null]
  implemented_by_id string [not null]
  effectiveness enum('complete','partial','minimal') [not null]
  status enum('active','inactive','replaced') [not null]
  implemented_at timestamp [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table root_cause_analysis {
  rca_id string [primary key]
  incident_id string [not null]
  analysis_method enum('five_whys','fishbone','timeline_analysis','fault_tree') [not null]
  conducted_by_id string [not null]
  completed_at timestamp
  status enum('in_progress','completed','approved') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table communications {
  communication_id string [primary key]
  incident_id string [not null]
  sender_id string [not null]
  recipient_id string
  recipient_type enum('client','internal_team','executive','vendor','regulatory') [not null]
  communication_type enum('email','sms','phone_call','status_page','portal_update') [not null]
  sent_at timestamp [not null]
  delivery_status enum('sent','delivered','failed','pending') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table escalations {
  escalation_id string [primary key]
  escalation_code varchar(50) [unique, not null] // e.g., 'ESC-2024-00789', 'ESCALATION-001234'
  incident_id string [not null]
  escalated_by_id string [not null]
  escalated_to_id string [not null]
  escalation_reason enum('sla_breach','severity_increase','resource_unavailable','executive_request','client_demand') [not null]
  escalation_level enum('technical','management','executive','vendor') [not null]
  escalated_at timestamp [not null]
  acknowledged_at timestamp
  resolved_at timestamp
  status enum('open','acknowledged','resolved') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table change_requests {
  change_id string [primary key]
  change_code varchar(50) [unique, not null] // e.g., 'CHG-2024-00456', 'CR-001234'
  incident_id string
  title varchar(100) [not null]
  change_type enum('emergency','standard','normal') [not null]
  requested_by_id string [not null]
  approved_by_id string
  risk_level enum('high','medium','low') [not null]
  scheduled_start timestamp
  scheduled_end timestamp
  actual_start timestamp
  actual_end timestamp
  status enum('requested','approved','scheduled','in_progress','completed','failed','rolled_back') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table rollback_requests {
  rollback_id string [primary key]
  rollback_code varchar(50) [unique, not null] // e.g., 'RBK-2024-00321', 'ROLLBACK-001234'
  change_id string [not null]
  incident_id string
  requested_by_id string [not null]
  approved_by_id string
  executed_at timestamp
  validation_completed boolean [default: false]
  status enum('requested','approved','in_progress','completed','failed') [not null]
  created_at timestamp [not null, default: `NOW()`]
}



// Vendor incidents are now handled directly in the incidents table
// with vendor_id and vendor_ticket_id fields

Table metrics {
  metric_id string [primary key]
  incident_id string [not null]
  metric_type enum('MTTA','MTTD','MTTR','MTTM','FTR') [not null]
  value_minutes int [not null]
  target_minutes int
  recorded_at timestamp [not null]
  created_at timestamp [not null, default: `NOW()`]
}

// Table compliance_events {
//   compliance_id string [primary key]
//   incident_id string [not null]
//   regulation_type enum('GDPR','HIPAA','SOX','PCI_DSS','FFIEC','CCPA','FCC','NERC') [not null]
//   event_type enum('breach_assessment','notification_required','reporting_deadline','audit_trigger') [not null]
//   deadline timestamp
//   completed_at timestamp
//   responsible_party_id string [not null]
//   status enum('pending','in_progress','completed','overdue') [not null]
//   created_at timestamp [not null, default: `NOW()`]
// }

Table incident_reports {
  report_id string [primary key]
  incident_id string [not null]
  report_type enum('executive_summary','technical_details','business_impact','compliance_report','post_mortem') [not null]
  generated_by_id string [not null]
  generated_at timestamp [not null]
  status enum('draft','completed','distributed') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table knowledge_base_articles {
  article_id string [primary key]
  // article_code varchar(50) [unique, not null] // e.g., 'KB-00741'
  incident_id string
  title varchar(100) [not null]
  article_type enum('troubleshooting','resolution_steps','prevention_guide','faq') [not null]
  created_by_id string [not null]
  reviewed_by_id string
  category enum(
    'authentication_issues',
    'payment_processing', 
    'api_integration',
    'data_synchronization',
    'system_outages',
    'performance_degradation',
    'security_incidents',
    'backup_recovery',
    'user_management',
    'billing_issues',
    'compliance_procedures',
    'vendor_escalations',
    'configuration_changes',
    'monitoring_alerts',
    'network_connectivity',
    'database_issues',
    'file_transfer_problems',
    'reporting_errors',
    'mobile_app_issues',
    'browser_compatibility',
    'third_party_integrations',
    'scheduled_maintenance',
    'emergency_procedures',
    'client_onboarding',
    'account_provisioning',
    'sla_management',
    'incident_response',
    'change_management',
    'capacity_planning',
    'disaster_recovery'
  )
  view_count int [default: 0]
  status enum('draft','published','archived') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table post_incident_reviews {
  pir_id string [primary key]
  incident_id string [not null]
  scheduled_date timestamp [not null]
  facilitator_id string [not null]
  timeline_accuracy_rating int
  communication_effectiveness_rating int
  technical_response_rating int
  status enum('scheduled','completed','cancelled') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

// Relationships
Ref: users.client_id > clients.client_id
Ref: users.vendor_id > vendors.vendor_id
// Ref: products.internal_team_lead_id > users.user_id
Ref: products.vendor_support_id > vendors.vendor_id
Ref: client_subscriptions.client_id > clients.client_id
Ref: client_subscriptions.product_id > products.product_id
Ref: sla_agreements.subscription_id > client_subscriptions.subscription_id
Ref: incidents.reporter_id > users.user_id
Ref: incidents.assigned_manager_id > users.user_id
Ref: incidents.client_id > clients.client_id
Ref: incidents.component_id > infrastructure_components.component_id
// Ref: incidents.vendor_id > vendors.vendor_id
// Ref: incident_updates.incident_id > incidents.incident_id
// Ref: incident_updates.updated_by_id > users.user_id
Ref: workarounds.incident_id > incidents.incident_id
Ref: workarounds.implemented_by_id > users.user_id
Ref: root_cause_analysis.incident_id > incidents.incident_id
Ref: root_cause_analysis.conducted_by_id > users.user_id
Ref: communications.incident_id > incidents.incident_id
Ref: communications.sender_id > users.user_id
Ref: escalations.incident_id > incidents.incident_id
Ref: escalations.escalated_by_id > users.user_id
Ref: escalations.escalated_to_id > users.user_id
Ref: change_requests.incident_id > incidents.incident_id
Ref: change_requests.requested_by_id > users.user_id
Ref: change_requests.approved_by_id > users.user_id
Ref: rollback_requests.change_id > change_requests.change_id
Ref: rollback_requests.incident_id > incidents.incident_id
Ref: rollback_requests.requested_by_id > users.user_id
Ref: rollback_requests.approved_by_id > users.user_id
Ref: metrics.incident_id > incidents.incident_id
// Ref: compliance_events.incident_id > incidents.incident_id
// Ref: compliance_events.responsible_party_id > users.user_id
Ref: incident_reports.incident_id > incidents.incident_id
Ref: incident_reports.generated_by_id > users.user_id
Ref: knowledge_base_articles.incident_id > incidents.incident_id
Ref: knowledge_base_articles.created_by_id > users.user_id
Ref: knowledge_base_articles.reviewed_by_id > users.user_id
Ref: post_incident_reviews.incident_id > incidents.incident_id
Ref: post_incident_reviews.facilitator_id > users.user_id
Ref: infrastructure_components.product_id > products.product_id

You have to provide the json file for each function separately including all the tests for that function in the actions part. You are going to provide the bash script that will create and populate those json files in a folder named tools_regression_tests/interface_4/.

Note: ids are just numeric strings "1", "2", ...
