Assume you are an experienced tester. I am going to give you python functions and you are going to give me the inputs to test this function. The inputs are provided in the form of actions. You have to provide three tests for each function within the same file with the most number of parameters as possible (if applicable). However, you have to follow the format that I provide to you below.

# Format:
{
    "env": "wiki_pages",
    "interface_num": 4,
    "task": {
        "actions": [
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            },
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            }
        ]
    }
}

where the name of action is the function name and the arguments are the parameters of the function. You have to provide multiple actions for a single file in a single test if applicable. 

# Functions:
ALL_TOOLS_INTERFACE_4 = []


# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class AttainUser(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        user_id: Optional[str] = None,
        email: Optional[str] = None,
        status: Optional[str] = None,
        display_name: Optional[str] = None
    ) -> str:
        """
        Attain user(s) based on filter criteria (ClickUp logic).
        """
        users = data.get("users", {})
        results = []
        
        for uid, user in users.items():
            match = True
            
            if user_id and uid != user_id:
                match = False
            if email and user.get("email") != email:
                match = False
            if status and user.get("status") != status:
                match = False
            if display_name and user.get("display_name") != display_name:
                match = False
            
            if match:
                results.append(user)
        
        return json.dumps({
            "success": True,
            "count": len(results),
            "users": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "attain_user", 
                "description": "Attain user details based on filter criteria. Returns all users that match the specified filters.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "user_id": {
                            "type": "string",
                            "description": "Filter by user ID (optional)"
                        },
                        "email": {
                            "type": "string",
                            "description": "Filter by email address (optional)"
                        },
                        "status": {
                            "type": "string",
                            "description": "Filter by status: active, inactive, deactivated (optional)",
                            "enum": ["active", "inactive", "deactivated"]
                        },
                        "display_name": {
                            "type": "string",
                            "description": "Filter by display name (optional)"
                        }
                    },
                    "required": []
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class FindDoc(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        doc_id: Optional[str] = None,
        space_id: Optional[str] = None,
        title: Optional[str] = None,
        status: Optional[str] = None,
        created_by: Optional[str] = None,
        updated_by: Optional[str] = None
    ) -> str:
        """
        Find doc(s) based on filter criteria (ClickUp logic).
        """
        pages = data.get("pages", {})
        results = []
        
        for page_id, page in pages.items():
            match = True
            
            if doc_id and page_id != doc_id:
                match = False
            if space_id and page.get("space_id") != space_id:
                match = False
            if title and page.get("title") != title:
                match = False
            if status and page.get("status") != status:
                match = False
            if created_by and page.get("created_by") != created_by:
                match = False
            if updated_by and page.get("updated_by") != updated_by:
                match = False
            
            if match:
                results.append(page)
        
        return json.dumps({
            "success": True,
            "count": len(results),
            "docs": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "find_doc", # RENAMED from get_doc
                "description": "Find doc(s) based on filter criteria. Returns all docs that match the specified filters.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "doc_id": {
                            "type": "string",
                            "description": "Filter by doc ID (optional)"
                        },
                        "space_id": {
                            "type": "string",
                            "description": "Filter by space ID (optional)"
                        },
                        "title": {
                            "type": "string",
                            "description": "Filter by title (optional)"
                        },
                        "status": {
                            "type": "string",
                            "description": "Filter by status: current, draft, locked, archived, deleted (optional)",
                            "enum": ["current", "draft", "locked", "archived", "deleted"]
                        },
                        "created_by": {
                            "type": "string",
                            "description": "Filter by creator user ID (optional)"
                        },
                        "updated_by": {
                            "type": "string",
                            "description": "Filter by updater user ID (optional)"
                        }
                    },
                    "required": []
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class LocateSpace(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        space_id: Optional[str] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        type: Optional[str] = None,
        status: Optional[str] = None,
        space_key: Optional[str] = None
    ) -> str:
        """
        Locate space(s) based on filter criteria.
        """
        spaces = data.get("spaces", {})
        results = []
        
        for sid, space in spaces.items():
            match = True
            
            if space_id and sid != space_id:
                match = False
            if space_key and space.get("space_key") != space_key:
                match = False
            if name and space.get("name") != name:
                match = False
            if description and space.get("description") != description:
                match = False
            if type and space.get("type") != type:
                match = False
            if status and space.get("status") != status:
                match = False
            
            if match:
                results.append(space)
        
        return json.dumps({
            "success": True,
            "count": len(results),
            "spaces": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "locate_space",
                "description": "Locate space(s) based on filter criteria. Returns all spaces that match the specified filters.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "space_id": {
                            "type": "string",
                            "description": "Filter by space ID (optional)"
                        },
                        "space_key": {
                            "type": "string",
                            "description": "Filter by space key (optional)"
                        },
                        "name": {
                            "type": "string",
                            "description": "Filter by space name (optional)"
                        },
                        "description": {
                            "type": "string",
                            "description": "Filter by description (optional)"
                        },
                        "type": {
                            "type": "string",
                            "description": "Filter by type: global, personal (optional)",
                            "enum": ["global", "personal"]
                        },
                        "status": {
                            "type": "string",
                            "description": "Filter by status: current, archived (optional)",
                            "enum": ["current", "archived"]
                        }
                    },
                    "required": []
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class GrantAdminOnDoc(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        user_id: str,
        doc_id: str
    ) -> str:
        """
        Grant admin permission to a user on a doc.
        """
        def generate_id(table: Dict[str, Any]) -> str:
            if not table:
                return "1"
            return str(max(int(k) for k in table.keys()) + 1)
        
        timestamp = "2025-10-01T00:00:00"
        permissions_table = data.get("permissions", {})
        pages = data.get("pages", {})
        users = data.get("users", {})
        
        # Validate required parameters
        if not all([doc_id, user_id]):
            return json.dumps({
                "success": False,
                "error": "Missing required parameters: doc_id and user_id are required"
            })
        
        # Validate doc exists
        if doc_id not in pages:
            return json.dumps({
                "success": False,
                "error": f"Doc with ID '{doc_id}' not found"
            })
        
        # Validate user exists
        if user_id not in users:
            return json.dumps({
                "success": False,
                "error": f"User with ID '{user_id}' not found"
            })
        
        # Create permission entry
        new_perm_id = generate_id(permissions_table)
        
        new_permission = {
            "permission_id": new_perm_id,
            "content_id": doc_id,
            "content_type": "page",
            "user_id": user_id,
            "operation": "admin",
            "granted_by": "system", # simplified for tool
            "granted_at": timestamp
        }
        
        permissions_table[new_perm_id] = new_permission
        
        return json.dumps(new_permission)
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "grant_admin_on_doc",
                "description": "Grant admin permission to a user on a doc. Admin permission includes all other permissions.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "doc_id": {
                            "type": "string",
                            "description": "ID of the doc"
                        },
                        "user_id": {
                            "type": "string",
                            "description": "ID of the user to grant permission to"
                        }
                    },
                    "required": ["doc_id", "user_id"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool


class LocateUserPermissions(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        filter: Dict[str, Any]
    ) -> str:
        """
        Locate user permissions (ClickUp logic).
        Uses a 'filter' dictionary as per documentation.
        """
        user_id = filter.get("user_id")
        doc_id = filter.get("doc_id")
        space_id = filter.get("space_id")
        
        permissions_table = data.get("permissions", {})
        results = []
        
        for perm in permissions_table.values():
            match = True
            if user_id and perm.get("user_id") != user_id: match = False
            
            # Match doc_id to content_id if type is page
            if doc_id:
                if perm.get("content_type") != "page" or perm.get("content_id") != doc_id:
                    match = False
                    
            # Match space_id to content_id if type is space
            if space_id:
                if perm.get("content_type") != "space" or perm.get("content_id") != space_id:
                    match = False
            
            if match:
                results.append(perm)
                
        return json.dumps({
            "success": True, 
            "count": len(results), 
            "permissions": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "locate_user_permissions", # RENAMED from get_user_permissions
                "description": "Locate user permissions using a filter object. Returns all permission entries matching the filter.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "filter": {
                            "type": "object",
                            "properties": {
                                "user_id": {
                                    "type": "string", 
                                    "description": "ID of the user (required)"
                                },
                                "doc_id": {
                                    "type": "string", 
                                    "description": "ID of the document (optional)"
                                },
                                "space_id": {
                                    "type": "string", 
                                    "description": "ID of the space (optional)"
                                }
                            },
                            "required": ["user_id"]
                        }
                    },
                    "required": ["filter"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ConstructDoc(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        fields: Dict[str, Any]
    ) -> str:
        """
        Construct a new doc in the specified space (ClickUp logic).
        Wraps arguments in a 'fields' dictionary as per documentation.
        """
        # Unwrap fields
        space_id = fields.get("space_id")
        title = fields.get("title")
        body_storage = fields.get("body_storage")
        status = fields.get("status")
        created_by = fields.get("created_by")

        def generate_id(table: Dict[str, Any]) -> str:
            if not table:
                return "1"
            return str(max(int(k) for k in table.keys()) + 1)
        
        timestamp = "2025-10-01T00:00:00"
        pages = data.get("pages", {})
        spaces = data.get("spaces", {})
        users = data.get("users", {})
        
        # Validate required parameters
        if not all([space_id, title, created_by]):
            return json.dumps({
                "success": False,
                "error": "Missing required fields in 'fields' dict: space_id, title, and created_by are required"
            })
        
        # Validate space exists
        if space_id not in spaces:
            return json.dumps({
                "success": False,
                "error": f"Space with ID '{space_id}' not found"
            })
        
        # Validate user exists
        if created_by not in users:
            return json.dumps({
                "success": False,
                "error": f"User with ID '{created_by}' not found"
            })
        
        user = users[created_by]
        if user.get("status") != "active":
            return json.dumps({
                "success": False,
                "error": f"User with ID '{created_by}' is not active"
            })
        
        # Validate status if provided
        valid_statuses = ["current", "draft", "locked", "archived", "deleted"]
        if status and status not in valid_statuses:
            return json.dumps({
                "success": False,
                "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
            })
        
        # Generate new page ID
        new_page_id = generate_id(pages)
        
        # Create new page (doc)
        new_page = {
            "page_id": new_page_id,
            "title": title,
            "space_id": space_id,
            "parent_page_id": None,
            "body_storage": body_storage,
            "status": status if status else "current",
            "created_by": created_by,
            "created_at": timestamp,
            "updated_by": created_by,
            "updated_at": timestamp
        }
        
        pages[new_page_id] = new_page
        
        return json.dumps(new_page)
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "construct_doc", # RENAMED from create_doc
                "description": "Construct a new doc in a specified space. Requires a 'fields' object containing space_id, title, and created_by.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fields": {
                            "type": "object",
                            "properties": {
                                "space_id": {
                                    "type": "string",
                                    "description": "ID of the space where the doc will be created"
                                },
                                "title": {
                                    "type": "string",
                                    "description": "Title of the doc"
                                },
                                "body_storage": {
                                    "type": "string",
                                    "description": "Content of the doc in storage format (optional)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status of the doc: current, draft, locked, archived, deleted (optional, defaults to current)",
                                    "enum": ["current", "draft", "locked", "archived", "deleted"]
                                },
                                "created_by": {
                                    "type": "string",
                                    "description": "User ID of the doc creator"
                                }
                            },
                            "required": ["space_id", "title", "created_by"]
                        }
                    },
                    "required": ["fields"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class DestroyDoc(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        doc_id: str
    ) -> str:
        """
        Destroy a doc (ClickUp logic).
        """
        pages = data.get("pages", {})
        
        # Validate required parameters
        if not doc_id:
            return json.dumps({
                "success": False,
                "error": "Missing required parameter: doc_id"
            })
        
        # Validate doc exists
        if doc_id not in pages:
            return json.dumps({
                "success": False,
                "error": f"Doc with ID '{doc_id}' not found"
            })
        
        # Delete the page
        deleted_page = pages.pop(doc_id)
        
        return json.dumps({
            "success": True,
            "message": f"Doc with ID '{doc_id}' has been destroyed",
            "deleted_doc": deleted_page
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "destroy_doc", # RENAMED from delete_doc
                "description": "Destroy a doc from the system. Permanently removes the document.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "doc_id": {
                            "type": "string",
                            "description": "ID of the doc to destroy"
                        }
                    },
                    "required": ["doc_id"]
                }
            }
        }


# Policy:
CLICKUP WIKI TECHNICAL POLICY
As a Clickup Wiki Management Agent, you are responsible for executing space and Document management processes, including Doc Management, White board management, Embed link management and label management.
General Operating Principles
You must not provide any information, knowledge, procedures, subjective recommendations, or comments that are not supplied by the user or available through tools.
You must deny user requests that violate this policy.
All Standard Operating Procedures (SOPs) are designed for single-turn execution. Each procedure is self-contained and must be completed in one interaction. Each SOP provides clear steps for proceeding when conditions are met and explicit halt instructions with error reporting when conditions are not met.


Permission Structure
Admin permissions encompass all other permissions. Users with "admin" permission level automatically have all permissions for the given entity.
User who creates a Doc gets admin permission on that Doc.


Critical Halt and Transfer Conditions
You must halt the procedure and immediately initiate a delegate_to_human if you encounter any of the following critical conditions:

The user is unauthorized or lacks the necessary privileges/permissions.
Missing or invalid credentials are provided.
Any required entity lookup (find_doc, obtain_list , etc.) raises an error or the entity is not found.
A failure occurs during the procedure that prevents the request from being fulfilled.
If any external integration (e.g., database or API) fails, you must halt and provide appropriate error messaging.

Only when none of these conditions occur should you proceed to complete the SOP.


Standard Operating Procedures (SOPs)
Authorization
Before performing any SOP, Verify the acting user exists and have “active” status using attain_user.
1. Create Doc
Steps:
get the target space using locate_space.
Verify the acting user has “create”, “edit” or “admin” permission on the space using locate_user_permissions.
Create the new Doc using construct_doc.
Grant administrative permission to the user for the Doc using grant_admin_on_doc.
Verify by retrieving the newly created Doc using find_doc to confirm it was created successfully.
2. Update Doc
Steps:
Retrieve the target Doc using find_doc.
Verify the acting user has “edit” or “admin” permission on the doc using locate_user_permissions.
Update the Doc using adjust_doc.
Verify by retrieving the Doc again using find_doc to confirm the changes were applied successfully.
3. Remove Doc
Steps:
Retrieve the target Doc using find_doc.
Verify the acting user has “delete” or “admin” permission on the doc using locate_user_permissions.
Delete the Doc using destroy_doc.
Verify by retrieving the Doc again using find_doc to confirm it no longer exists.
4. Modify Doc Permissions
Steps:
Retrieve the target Doc using find_doc.
Verify the acting user has “edit” or “admin” permission on the doc using locate_user_permissions.
Retrieve the details of the target user whose permissions will be modified using attain_user. 
If granting admin permission on Doc Use grant_admin_on_doc.
If changing the admin role or  revoking admin permission on Doc Use update_admin_permission_on_doc.
If granting editor permission on Doc Use grant_editor_on_doc.
If changing editor role or revoking editor permission on Doc Use modify_editor_permission_on_doc.
If granting viewer permission on Doc Use grant_viewer_on_doc.
If revoking viewer permission on Do Use edit_viewer_permission_on_doc.
If resetting the user’s doc permission to inherit the user’s space permission:
Retrieve the space where the doc is located using locate_space.
Retrieve the user permission on the space using locate_user_permissions. 
If Resetting to the space permission for admin use reset_inheritance_on_doc
5. Create Whiteboard
Steps:
Retrieve the target Doc where the Whiteboard will be created using find_doc.
Verify the acting user has “create”, “edit” or “admin” permission on the doc using locate_user_permissions.
Create the Whiteboard using add_whiteboard.
Verify by retrieving the Whiteboard using fetch_whiteboard to confirm it was created successfully.
6. Update Whiteboard
Steps:
Retrieve the target Whiteboard using fetch_whiteboard.
Retrieve the host doc for the whiteboard using find_doc.
Verify the acting user has “edit” or “admin” permission on the doc using locate_user_permissions.
Update the Whiteboard using modify_whiteboard.
Retrieve the Whiteboard using fetch_whiteboard to verify the changes were applied.
7. Remove Whiteboard
Steps:
Retrieve the target Whiteboard using fetch_whiteboard.
Retrieve the target doc where the whiteboard is located using find_doc.
Verify the acting user has “delete” or “admin” permission on the doc using locate_user_permissions.
Delete the Whiteboard using erase_whiteboard.
Retrieve the Whiteboard again using fetch_whiteboard to confirm the removal.
8. Create Embedded Link
Steps:
Retrieve the target Doc where the embedded link will be added using find_doc.
Verify the acting user has “create”, “edit” or “admin” permission on the doc using locate_user_permissions.
Add the embedded link using set_links_field.
Verify by retrieving the Doc again using find_doc to confirm the embedded link was added successfully.
9. Remove Embedded Link
Steps:
Retrieve the target Doc where the embedded link exists using find_doc.
Verify the acting user has “edit” or “admin” permission on the doc using locate_user_permissions.
Remove the embedded link using remove_links_field.
Verify by retrieving the Doc again using find_doc to confirm the embedded link was successfully removed.
10. Update Embedded Link
Steps:
Retrieve the target Doc where the embedded link exists using find_doc.
Verify the acting user has “edit” or “admin” permission on the doc using locate_user_permissions.
Update the embedded link using replace_links_field.
Verify by retrieving the Doc again using find_doc to confirm the embedded link was updated successfully.
11. Create List
Steps:
Retrieve the space where the List will be associated using locate_space.
Verify the acting user has “create”, “edit” or “admin” permission on the space using locate_user_permissions.
Create the List using add_list.
Verify by retrieving the newly created List using obtain_list to confirm it was created successfully.
12. Remove List
Steps:
Retrieve the space where the List is associated using locate_space.
Verify the acting user has “delete” or “admin” permission on the space using locate_user_permissions.
Retrieve the target List using obtain_list.
Delete the List using remove_list.
Verify the List is deleted using obtain_list to confirm it no longer exists.
13. Update List
Steps:
Retrieve the space where the List is  associated using locate_space
Verify the acting user has “edit” or “admin” permission on the space using locate_user_permissions.
Retrieve the target List using obtain_list.
Update the List using edit_list.
Verify the List is updated using obtain_list to confirm the updates were applied successfully.
14. Add Label
Steps:
Retrieve the target Doc using find_doc.
Verify the acting user has “create”, “edit” or “admin” permission on the doc using locate_user_permissions.
Create the label using add_labels_custom_field.
Verify by retrieving the Doc again using find_doc to confirm the label appears correctly.
15. Remove Label
Steps:
Retrieve the target Doc using find_doc.
Verify the acting user has “edit” or “admin” permission on the doc using locate_user_permissions.
Retrieve the label using find_label.
Remove the label using delete_labels_custom_field.
Verify by retrieving the Doc again using find_doc to confirm the label no longer appears.
16. Update Label
Steps:
Retrieve the target Doc using find_doc.
Verify the acting user has “edit” or “admin” permission on the doc using locate_user_permissions.
Retrieve the label using find_label.
Update the label using update_labels_custom_field.
Verify by retrieving the Doc again using find_doc to confirm the label reflects the updated properties.




# Database Schema:
// DBML Schema for Confluence Content Management System
// Based on actual Confluence database table structure

// ============================================================================
// CORE CONTENT TYPES
// ============================================================================

Table pages {
  page_id varchar(50) [primary key]
  // page_number varchar(50) [not null, unique] // e.g., PAGE0000001
  title varchar(500) [not null]
  space_id varchar(50) [not null]
  parent_page_id varchar(50) // nullable for root pages
  body_storage text // 
  // body_view text // rendered HTML
  status enum('current','draft','locked', 'archived','deleted') [not null, default: 'current']
  // version_number int [not null, default: 1]
  created_by varchar(50) [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_by varchar(50) [not null]
  updated_at timestamp [not null, default: `NOW()`]

  indexes {
    parent_page_id
    space_id
    // folder_id
    (space_id, status)
    // page_number [unique]
  }
}

Table databases {
  database_id varchar(50) [primary key]
  title varchar(500) [not null]
  host_space_id varchar(50)      // For space-level databases
  host_page_id varchar(50)       // For page-level databases
  // Either host_space_id OR host_page_id must be set (mutually exclusive)
  description text
  status enum('current','archived','deleted') [not null, default: 'current']
  created_by varchar(50) [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_by varchar(50) [not null]
  updated_at timestamp [not null, default: `NOW()`]
  
  indexes {
    host_space_id
    host_page_id
  }
}

Table whiteboards {
  whiteboard_id varchar(50) [primary key]
  title varchar(500) [not null]
  host_space_id varchar(50)      // For space-level whiteboards
  host_page_id varchar(50)       // For page-level whiteboards  
  content text
  status enum('current','archived','deleted', 'locked') [not null, default: 'current']
  created_by varchar(50) [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_by varchar(50) [not null]
  updated_at timestamp [not null, default: `NOW()`]
  
  indexes {
    host_space_id
    host_page_id
  }
}

Table smart_links {
  smart_link_id varchar(50) [primary key]
  title varchar(500) [not null]
  url varchar(2000) [not null]
  
  // What this smart link POINTS TO (the reference/target)
  target_id varchar(50)           // The entity this link references
  target_type enum('page','database','whiteboard','external', 'attachment')
  
  // Where this smart link is DISPLAYED (the container)
  host_page_id varchar(50) [not null]
  // host_id varchar(50) [not null]
  // host_type enum('page','database','whiteboard') [not null]
  
  // link_type varchar(100) // e.g., 'jira_issue', 'external_url', etc.
  // link_type enum(
  //   'internal_link',
  //   'document_link',
  //   'repository_link',
  //   'communication_link',
  //   'media_link',
  //   'external_url'
  // ) [not null, default: 'external_url']
  // status enum('current','archived','deleted') [not null, default: 'current']
  created_by varchar(50) [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_by varchar(50) [not null]
  updated_at timestamp [not null, default: `NOW()`]
  
  indexes {
    // parent_id
    // space_id
    url
  }
}


// ============================================================================
// SPACES
// ============================================================================

Table spaces {
  space_id varchar(50) [primary key]
  space_key varchar(50) [not null, unique]
  name varchar(255) [not null]
  description text
  type enum('global','personal') [not null]
  status enum('current','archived') [not null, default: 'current']
  // homepage_id varchar(50) // FK to pages
  created_by varchar(50) [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
  
  indexes {
    space_key [unique]
  }
}

// ============================================================================
// USERS AND AUTHENTICATION
// ============================================================================

Table users {
  user_id varchar(50) [primary key]
  // account_id varchar(100) [not null, unique] // Atlassian account ID
  email varchar(320) [not null, unique]
  display_name varchar(255) [not null]
  // account_type enum('atlassian','app','anonymous') [not null]
  status enum('active','inactive','deactivated') [not null, default: 'active']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
  
  indexes {
    // account_id [unique]
    email [unique]
  }
}


// ============================================================================
// ATTACHMENTS
// ============================================================================

Table attachments {
  attachment_id varchar(50) [primary key]
  content_id varchar(50) [not null]
  content_type enum('page','database','whiteboard','smart_link') [not null]
  host_page_id varchar(50) 
  file_name varchar(500) [not null]
  file_url varchar(2000) [not null]
  // file_size_bytes bigint [not null]
  // media_type varchar(100) [not null] // MIME type
  // download_url varchar(2000) [not null]
  // comment text
  // version_number int [not null, default: 1]
  status enum('current','archived','deleted') [not null, default: 'current']
  uploaded_by varchar(50) [not null]
  uploaded_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
  
  indexes {
    content_id
    (content_id, content_type)
    uploaded_by
  }
}


// ============================================================================
// VERSIONS
// ============================================================================


Table page_versions {
  page_version_id varchar(50) [primary key]
  page_id varchar(50) [not null]
  version_number int [not null]
  title varchar(500) [not null]
  body_storage text
  // is_minor_edit boolean [not null, default: false]
  // created_by varchar(50)  
  created_at timestamp [not null, default: `NOW()`]
}

Table page_version_components {
  component_id varchar(50) [primary key]
  page_version_id varchar(50) [not null]
  component_type enum('whiteboard','smart_link') [not null]
  component_data text [not null] // Complete snapshot of the component
  
  indexes {
    page_version_id
  }
}

Ref: page_version_components.page_version_id > page_versions.page_version_id


// Table whiteboard_versions {
//   whiteboard_version_id varchar(50) [primary key]
//   whiteboard_id varchar(50) [not null]
//   version_number int [not null]
//   title varchar(500) [not null]
//   content text
//   version_message text
//   created_by varchar(50) [not null]
//   created_at timestamp [not null, default: `NOW()`]
  
//   indexes {
//     whiteboard_id
//     (whiteboard_id, version_number) [unique]
//   }
// }



// ============================================================================
// LABELS
// ============================================================================

Table page_labels {
  page_label_id varchar(50) [primary key]
  page_id varchar(50) [not null]
  label_name varchar(255) [not null]  // stored directly
  added_by varchar(50) [not null]
  added_at timestamp [not null, default: `NOW()`]
  
  indexes {
    page_id
    (page_id, label_name) [unique]
  }
}

// Table labels {
//   label_id varchar(50) [primary key]
//   label_name varchar(255) [not null, unique]
//   // prefix varchar(50) // e.g., 'global', 'my', 'team'
//   created_at timestamp [not null, default: `NOW()`]
  
//   indexes {
//     label_name
//   }
// }

// Table page_labels {
//   page_label_id varchar(50) [primary key]
//   page_id varchar(50) [not null]
//   label_id varchar(50) [not null]
//   added_by varchar(50) [not null]
//   added_at timestamp [not null, default: `NOW()`]
  
//   indexes {
//     (page_id, label_id) [unique]
//     label_id
//   }
// }

// Table attachment_labels {
//   attachment_label_id varchar(50) [primary key]
//   attachment_id varchar(50) [not null]
//   label_id varchar(50) [not null]
//   added_by varchar(50) [not null]
//   added_at timestamp [not null, default: `NOW()`]
  
//   indexes {
//     (attachment_id, label_id) [unique]
//     label_id
//   }
// }

// ============================================================================
// LIKES
// ============================================================================

// Table likes {
//   like_id varchar(50) [primary key]
//   page_id varchar(50) [not null]
//   // content_id varchar(50) [not null]
//   // content_type enum('page','database','whiteboard','smart_link') [not null]
//   user_id varchar(50) [not null]
//   // account_id varchar(100) [not null] // Atlassian account ID
//   liked_at timestamp [not null, default: `NOW()`]
  
//   indexes {
//     // (content_id, content_type, user_id) [unique]
//     // content_id
//     user_id
//   }
// }

// ============================================================================
// PERMISSIONS
// ============================================================================

Table permissions {
  permission_id varchar(50) [primary key]
  content_id varchar(50) [not null]
  content_type enum('space','page') [not null]
  user_id varchar(50)
  operation enum('view','edit','delete','create','admin', 'restrict_other_users') [not null]
  granted_by varchar(50)
  granted_at timestamp [not null, default: `NOW()`]
  
  indexes {
    (content_id, content_type)
    user_id
    operation
  }
}


// ============================================================================
// RELATIONSHIPS
// ============================================================================

// Content Pages
Ref: pages.parent_page_id > pages.page_id
Ref: pages.space_id > spaces.space_id
Ref: pages.created_by > users.user_id
Ref: pages.updated_by > users.user_id

// Databases
Ref: databases.host_space_id > spaces.space_id
Ref: databases.host_page_id > pages.page_id
Ref: databases.created_by > users.user_id
Ref: databases.updated_by > users.user_id

// Whiteboards
Ref: whiteboards.host_space_id > spaces.space_id
Ref: whiteboards.host_page_id > pages.page_id
Ref: whiteboards.created_by > users.user_id
Ref: whiteboards.updated_by > users.user_id

// Smart Links
// Ref: smart_links.space_id > spaces.space_id
Ref: smart_links.created_by > users.user_id
Ref: smart_links.updated_by > users.user_id

// Spaces
// Ref: spaces.homepage_id > pages.page_id
Ref: spaces.created_by > users.user_id

// Attachments
Ref: attachments.uploaded_by > users.user_id
// Ref: attachment_bodies.attachment_version_id > attachment_versions.attachment_version_id

// Versions
Ref: page_versions.page_id > pages.page_id
// Ref: page_versions.created_by > users.user_id

// Labels
Ref: page_labels.page_id > pages.page_id
// Ref: page_labels.label_id > labels.label_id
Ref: page_labels.added_by > users.user_id

// Ref: attachment_labels.attachment_id > attachments.attachment_id
// Ref: attachment_labels.label_id > labels.label_id
// Ref: attachment_labels.added_by > users.user_id


// Likes
// Ref: likes.user_id > users.user_id

// Permissions
Ref: permissions.user_id > users.user_id
// Ref: permissions.group_id > groups.group_id
Ref: permissions.granted_by > users.user_id

Ref: smart_links.host_page_id > pages.page_id


You have to provide the json file for each function separately including all the tests for that function in the actions part. You are going to provide the bash script that will create and populate those json files in a folder named tools_regression_tests/interface_4/.

Note: ids are just numeric strings "1", "2", ...
