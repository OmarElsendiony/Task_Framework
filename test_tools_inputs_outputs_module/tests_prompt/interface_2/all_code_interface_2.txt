Assume you are an experienced tester. I am going to give you python functions and you are going to give me the inputs to test this function. The inputs are provided in the form of actions. You have to provide diverse tests with different number of parameters (if applicable). You have to provide edge cases and normal cases. Try to use all of the fields in one of the cases. You have to provide invalid cases. You have to provide empty cases if applicable. However, you have to follow the format that I provide to you below.

# Format:
{
    "env": "hr_experts",
    "interface_num": 2,
    "task": {
        "actions": [
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            },
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            }
        ]
    }
}

where the name of action is the function name and the arguments are the parameters of the function. You have to provide multiple actions for a single file in a single test if applicable. 

# Functions:
import json
from typing import Any, Dict, Optional

# A placeholder for the base Tool class
class Tool:
    pass

class ManageTrainingPrograms(Tool):
    """
    Manages training programs, including creation and modification.
    """
    @staticmethod
    def generate_id(table: Dict[str, Any]) -> str:
        """Generates a new unique ID for a record."""
        if not table:
            return "1"
        return str(max(int(k) for k in table.keys()) + 1)

    @staticmethod
    def invoke(
        data: Dict[str, Any],
        operation: str,
        program_id: Optional[str] = None,
        program_name: Optional[str] = None,
        program_type: Optional[str] = None,
        duration_hours: Optional[int] = None,
        delivery_method: Optional[str] = None,
        mandatory: Optional[bool] = None, # Corrected: Default changed from False to None
        status: Optional[str] = None,     # Corrected: Default changed from "active" to None
    ) -> str:
        """
        Executes the specified operation (create or update) on training programs.
        """
        timestamp = "2025-10-01T00:00:00"
        programs = data.get("training_programs", {})

        if operation == "create":
            # For 'create', set defaults if not provided
            effective_mandatory = mandatory if mandatory is not None else False
            effective_status = status if status is not None else "active"

            if not all([program_name, program_type, duration_hours, delivery_method]):
                return json.dumps({"error": "Missing required parameters for create operation."})

            valid_types = ["onboarding", "compliance", "technical", "leadership", "safety", "diversity", "ai_ethics"]
            if program_type not in valid_types:
                return json.dumps({"error": f"Invalid program type. Must be one of {valid_types}."})

            valid_methods = ["in_person", "online", "hybrid", "self_paced"]
            if delivery_method not in valid_methods:
                return json.dumps({"error": f"Invalid delivery method. Must be one of {valid_methods}."})
            
            valid_statuses = ["active", "inactive", "draft"]
            if effective_status not in valid_statuses:
                return json.dumps({"error": f"Invalid status. Must be one of {valid_statuses}."})

            new_program_id = ManageTrainingPrograms.generate_id(programs)
            new_program = {
                "program_id": new_program_id,
                "program_name": program_name,
                "program_type": program_type,
                "duration_hours": duration_hours,
                "delivery_method": delivery_method,
                "mandatory": effective_mandatory,
                "status": effective_status,
                "created_at": timestamp,
                "updated_at": timestamp,
            }
            programs[new_program_id] = new_program
            return json.dumps(new_program)

        elif operation == "update":
            if not program_id:
                return json.dumps({"error": "program_id is required for update operation."})
            if program_id not in programs:
                return json.dumps({"error": f"Training program with ID {program_id} not found."})

            program_to_update = programs[program_id]
            if program_name is not None:
                program_to_update["program_name"] = program_name
            if program_type is not None:
                program_to_update["program_type"] = program_type
            if duration_hours is not None:
                program_to_update["duration_hours"] = duration_hours
            if delivery_method is not None:
                program_to_update["delivery_method"] = delivery_method
            if mandatory is not None:
                program_to_update["mandatory"] = mandatory
            if status is not None:
                program_to_update["status"] = status
            
            program_to_update["updated_at"] = timestamp
            return json.dumps(program_to_update)

        else:
            return json.dumps({"error": "Invalid operation. Must be 'create' or 'update'."})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        """
        Returns the schema for the ManageTrainingPrograms tool.
        """
        return {
            "type": "function",
            "function": {
                "name": "manage_training_programs",
                "description": "Allows for the creation of new corporate training programs and the modification of existing ones.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "operation": {"type": "string", "description": "Action: 'create' or 'update'."},
                        "program_name": {"type": "string", "description": "The official name of the training program. Required for 'create'."},
                        "program_type": {"type": "string", "description": "'onboarding', 'compliance', 'technical', 'leadership', 'safety', 'diversity', 'ai_ethics'. Required for 'create'."},
                        "duration_hours": {"type": "integer", "description": "Total length in hours. Required for 'create'."},
                        "delivery_method": {"type": "string", "description": "'in_person', 'online', 'hybrid', 'self_paced'. Required for 'create'."},
                        "mandatory": {"type": "boolean", "description": "'True', 'False'. Defaults to false."},
                        "status": {"type": "string", "description": "'active', 'inactive', 'draft'. Defaults to 'active'."},
                        "program_id": {"type": "string", "description": "The ID of the training program to update. Required for 'update'."},
                    },
                    "required": ["operation"],
                },
            },
        }

# -----------------

from .manage_audit_logs import ManageAuditLogs
from .manage_document_storage import ManageDocumentStorage
from .manage_employee_training import ManageEmployeeTraining
from .manage_expense_reimbursements import ManageExpenseReimbursements
from .manage_leave_requests import ManageLeaveRequests
from .manage_training_programs import ManageTrainingPrograms

ALL_TOOLS_INTERFACE_2 = [
    ManageAuditLogs,
    ManageDocumentStorage,
    ManageEmployeeTraining,
    ManageExpenseReimbursements,
    ManageLeaveRequests,
    ManageTrainingPrograms,
]



# -----------------

import json
from typing import Any, Dict, Optional

# A placeholder for the base Tool class
class Tool:
    pass

class ManageAuditLogs(Tool):
    """
    Manages the creation of immutable audit logs.
    """
    @staticmethod
    def generate_id(table: Dict[str, Any]) -> str:
        """Generates a new unique ID for a record."""
        if not table:
            return "1"
        return str(max(int(k) for k in table.keys()) + 1)

    @staticmethod
    def invoke(
        data: Dict[str, Any],
        operation: str,
        user_id: str,
        action: str,
        reference_type: str,
        reference_id: str,
        field_name: Optional[str] = None,
        old_value: Optional[str] = None,
        new_value: Optional[str] = None,
    ) -> str:
        """
        Executes the create operation for audit logs.
        """
        timestamp = "2025-10-01T00:00:00"
        audit_logs = data.get("audit_logs", {})
        users = data.get("users", {})

        if operation != "create":
            return json.dumps({"error": "Invalid operation. Only 'create' is permitted for audit logs."})
        
        if not all([user_id, action, reference_type, reference_id]):
            return json.dumps({"error": "Missing required parameters for create operation."})
        
        if user_id not in users:
            return json.dumps({"error": f"User with ID {user_id} not found."})

        valid_actions = ["create", "read", "update", "delete", "approve", "reject"]
        if action not in valid_actions:
            return json.dumps({"error": f"Invalid action. Must be one of {valid_actions}."})

        new_log_id = ManageAuditLogs.generate_id(audit_logs)
        new_log = {
            "log_id": new_log_id,
            "user_id": user_id,
            "action": action,
            "reference_type": reference_type,
            "reference_id": reference_id,
            "field_name": field_name,
            "old_value": old_value,
            "new_value": new_value,
            "timestamp": timestamp,
        }
        audit_logs[new_log_id] = new_log
        return json.dumps(new_log)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        """
        Returns the schema for the ManageAuditLogs tool.
        """
        return {
            "type": "function",
            "function": {
                "name": "manage_audit_logs",
                "description": "Used to create immutable audit trail records for significant actions performed within the system.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "operation": {"type": "string", "description": "Must be 'create'."},
                        "user_id": {"type": "string", "description": "The ID of the user who performed the action."},
                        "action": {"type": "string", "description": "Type of action audited: 'create', 'read', 'update', 'delete', 'approve', 'reject'."},
                        "reference_type": {"type": "string", "description": "Type or table: (e.g., 'employees', 'payroll_records')."},
                        "reference_id": {"type": "string", "description": "The primary key or unique identifier of the affected record."},
                        "field_name": {"type": "string", "description": "The specific field that was changed. Used for 'update' actions."},
                        "old_value": {"type": "string", "description": "The value of the field before the change."},
                        "new_value": {"type": "string", "description": "The value of the field after the change."},
                    },
                    "required": ["operation", "user_id", "action", "reference_type", "reference_id"],
                },
            },
        }


# -----------------

import json
from typing import Any, Dict, Optional

# A placeholder for the base Tool class
class Tool:
    pass

class ManageExpenseReimbursements(Tool):
    """
    Manages expense reimbursements, including creation and processing.
    """
    @staticmethod
    def generate_id(table: Dict[str, Any]) -> str:
        """Generates a new unique ID for a record."""
        if not table:
            return "1"
        return str(max(int(k) for k in table.keys()) + 1)

    @staticmethod
    def invoke(
        data: Dict[str, Any],
        operation: str,
        employee_id: Optional[str] = None,
        expense_date: Optional[str] = None,
        amount: Optional[float] = None,
        expense_type: Optional[str] = None,
        receipt_file_path: Optional[str] = None,
        reimbursement_id: Optional[str] = None,
        status: Optional[str] = None,
        approved_by: Optional[str] = None,
        payment_date: Optional[str] = None,
    ) -> str:
        """
        Executes the specified operation (create or update) on expense reimbursements.
        """
        timestamp = "2025-10-01T00:00:00"
        reimbursements = data.get("expense_reimbursements", {})
        employees = data.get("employees", {})
        users = data.get("users", {})

        if operation == "create":
            if not all([employee_id, expense_date, amount, expense_type]):
                return json.dumps({"error": "Missing required parameters for create operation."})

            if employee_id not in employees:
                return json.dumps({"error": f"Employee with ID {employee_id} not found."})
            
            valid_expense_types = ["travel", "meals", "equipment", "training", "other"]
            if expense_type not in valid_expense_types:
                return json.dumps({"error": f"Invalid expense type. Must be one of {valid_expense_types}."})

            new_reimbursement_id = ManageExpenseReimbursements.generate_id(reimbursements)
            new_reimbursement = {
                "reimbursement_id": new_reimbursement_id,
                "employee_id": employee_id,
                "expense_date": expense_date,
                "amount": amount,
                "expense_type": expense_type,
                "receipt_file_path": receipt_file_path,
                "status": "submitted",
                "approved_by": None,
                "payment_date": None,
                "created_at": timestamp,
                "updated_at": timestamp,
            }
            reimbursements[new_reimbursement_id] = new_reimbursement
            return json.dumps(new_reimbursement)

        elif operation == "update":
            if not all([reimbursement_id, status, approved_by]):
                return json.dumps({"error": "Missing required parameters for update operation."})

            if reimbursement_id not in reimbursements:
                return json.dumps({"error": f"Reimbursement with ID {reimbursement_id} not found."})
            
            if approved_by not in users:
                return json.dumps({"error": f"User with ID {approved_by} not found."})

            valid_statuses = ["approved", "rejected", "paid"]
            if status not in valid_statuses:
                return json.dumps({"error": f"Invalid status. Must be one of {valid_statuses}."})
            
            if status == "paid" and not payment_date:
                return json.dumps({"error": "payment_date is required when status is 'paid'."})

            record_to_update = reimbursements[reimbursement_id]
            record_to_update["status"] = status
            record_to_update["approved_by"] = approved_by
            if payment_date:
                record_to_update["payment_date"] = payment_date
            record_to_update["updated_at"] = timestamp
            return json.dumps(record_to_update)

        else:
            return json.dumps({"error": "Invalid operation. Must be 'create' or 'update'."})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        """
        Returns the schema for the ManageExpenseReimbursements tool.
        """
        return {
            "type": "function",
            "function": {
                "name": "manage_expense_reimbursements",
                "description": "Used by employees to submit new expense claims (create) and by finance to process these claims (update).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "operation": {"type": "string", "description": "Action: 'create' or 'update'."},
                        "employee_id": {"type": "string", "description": "The ID of the employee submitting the expense. Required for 'create'."},
                        "expense_date": {"type": "string", "description": "The date the expense was incurred (YYYY-MM-DD). Required for 'create'."},
                        "amount": {"type": "number", "description": "The total amount of the reimbursement claim. Required for 'create'."},
                        "expense_type": {"type": "string", "description": "Category: 'travel', 'meals', 'equipment', 'training', 'other'. Required for 'create'."},
                        "receipt_file_path": {"type": "string", "description": "The storage path to the scanned receipt or invoice. Optional for 'create'."},
                        "reimbursement_id": {"type": "string", "description": "The ID of the expense reimbursement record to modify. Required for 'update'."},
                        "status": {"type": "string", "description": "New status: 'approved', 'rejected', 'paid'. sRequired for 'update'."},
                        "approved_by": {"type": "string", "description": "The user ID of the finance officer or manager processing the request. Required for 'update'."},
                        "payment_date": {"type": "string", "description": "The date the payment was issued (YYYY-MM-DD). Required if status is 'paid'."},
                    },
                    "required": ["operation"],
                },
            },
        }


# -----------------

import json
from typing import Any, Dict, Optional

# A placeholder for the base Tool class
class Tool:
    pass

class ManageLeaveRequests(Tool):
    """
    Manages leave requests, including creation and status updates.
    """
    @staticmethod
    def generate_id(table: Dict[str, Any]) -> str:
        """Generates a new unique ID for a record."""
        if not table:
            return "1"
        return str(max(int(k) for k in table.keys()) + 1)

    @staticmethod
    def invoke(
        data: Dict[str, Any],
        operation: str,
        employee_id: Optional[str] = None,
        leave_type: Optional[str] = None,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        days_requested: Optional[float] = None,
        leave_id: Optional[str] = None,
        status: Optional[str] = None,
        approved_by: Optional[str] = None,
    ) -> str:
        """
        Executes the specified operation (create or update) on leave requests.
        """
        timestamp = "2025-10-01T00:00:00"
        leave_requests = data.get("leave_requests", {})
        employees = data.get("employees", {})
        users = data.get("users", {})

        if operation == "create":
            if not all([employee_id, leave_type, start_date, end_date, days_requested]):
                return json.dumps({"error": "Missing required parameters for create operation."})
            
            if employee_id not in employees:
                return json.dumps({"error": f"Employee with ID {employee_id} not found."})
            
            valid_leave_types = ["annual", "sick", "fmla", "personal", "bereavement", "jury_duty"]
            if leave_type not in valid_leave_types:
                return json.dumps({"error": f"Invalid leave type. Must be one of {valid_leave_types}."})

            new_leave_id = ManageLeaveRequests.generate_id(leave_requests)
            new_request = {
                "leave_id": new_leave_id,
                "employee_id": employee_id,
                "leave_type": leave_type,
                "start_date": start_date,
                "end_date": end_date,
                "days_requested": days_requested,
                "status": "pending",
                "approved_by": None,
                "approval_date": None,
                "created_at": timestamp,
                "updated_at": timestamp,
            }
            leave_requests[new_leave_id] = new_request
            return json.dumps(new_request)

        elif operation == "update":
            if not all([leave_id, status, approved_by]):
                return json.dumps({"error": "Missing required parameters for update operation."})

            if leave_id not in leave_requests:
                return json.dumps({"error": f"Leave request with ID {leave_id} not found."})
            
            if approved_by not in users:
                 return json.dumps({"error": f"User with ID {approved_by} not found."})

            valid_statuses = ["approved", "rejected", "cancelled"]
            if status not in valid_statuses:
                return json.dumps({"error": f"Invalid status. Must be one of {valid_statuses}."})

            request_to_update = leave_requests[leave_id]
            request_to_update["status"] = status
            request_to_update["approved_by"] = approved_by
            request_to_update["approval_date"] = timestamp
            request_to_update["updated_at"] = timestamp
            return json.dumps(request_to_update)

        else:
            return json.dumps({"error": "Invalid operation. Must be 'create' or 'update'."})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        """
        Returns the schema for the ManageLeaveRequests tool.
        """
        return {
            "type": "function",
            "function": {
                "name": "manage_leave_requests",
                "description": "Handles the creation of new leave requests by employees and the subsequent updating of their status (e.g., approval, rejection) by authorized personnel.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "operation": {"type": "string", "description": "Action: 'create', 'update'."},
                        "employee_id": {"type": "string", "description": "ID of the employee requesting leave. Required for 'create'."},
                        "leave_type": {"type": "string", "description": "Type of leave: 'annual', 'sick', 'fmla', 'personal', 'bereavement', 'jury_duty'. Required for 'create'."},
                        "start_date": {"type": "string", "description": "The first day of the leave period (YYYY-MM-DD). Required for 'create'."},
                        "end_date": {"type": "string", "description": "The last day of the leave period (YYYY-MM-DD). Required for 'create'."},
                        "days_requested": {"type": "number", "description": "The total number of leave days requested. Required for 'create'."},
                        "leave_id": {"type": "string", "description": "The ID of the leave request to be updated. Required for 'update'."},
                        "status": {"type": "string", "description": "New status: 'approved', 'rejected', 'cancelled'. Required for 'update'."},
                        "approved_by": {"type": "string", "description": "The user ID of the managesr or HR personnel approving or rejecting the request. Required for 'update'."},
                    },
                    "required": ["operation"],
                },
            },
        }


# -----------------

import json
from typing import Any, Dict, Optional

# A placeholder for the base Tool class
class Tool:
    pass

class ManageEmployeeTraining(Tool):
    """
    Manages employee training records, including enrollment and progress tracking.
    """
    @staticmethod
    def generate_id(table: Dict[str, Any]) -> str:
        """Generates a new unique ID for a record."""
        if not table:
            return "1"
        return str(max(int(k) for k in table.keys()) + 1)

    @staticmethod
    def invoke(
        data: Dict[str, Any],
        operation: str,
        employee_id: Optional[str] = None,
        program_id: Optional[str] = None,
        enrollment_date: Optional[str] = None,
        training_record_id: Optional[str] = None,
        status: Optional[str] = None,
        completion_date: Optional[str] = None,
        score: Optional[float] = None,
        certificate_issued: Optional[bool] = None,
        expiry_date: Optional[str] = None,
    ) -> str:
        """
        Executes the specified operation (create or update) on employee training records.
        """
        timestamp = "2025-10-01T00:00:00"
        employee_trainings = data.get("employee_training", {})
        employees = data.get("employees", {})
        programs = data.get("training_programs", {})

        if operation == "create":
            if not all([employee_id, program_id, enrollment_date]):
                return json.dumps({"error": "Missing required parameters for create operation."})

            if employee_id not in employees:
                return json.dumps({"error": f"Employee with ID {employee_id} not found."})
            if program_id not in programs:
                return json.dumps({"error": f"Training program with ID {program_id} not found."})

            new_record_id = ManageEmployeeTraining.generate_id(employee_trainings)
            new_record = {
                "training_record_id": new_record_id,
                "employee_id": employee_id,
                "program_id": program_id,
                "enrollment_date": enrollment_date,
                "status": "enrolled",
                "completion_date": None,
                "score": None,
                "certificate_issued": False,
                "expiry_date": None,
                "created_at": timestamp,
                "updated_at": timestamp,
            }
            employee_trainings[new_record_id] = new_record
            return json.dumps(new_record)

        elif operation == "update":
            if not all([training_record_id, status]):
                return json.dumps({"error": "Missing required parameters for update operation."})
            
            if training_record_id not in employee_trainings:
                return json.dumps({"error": f"Training record with ID {training_record_id} not found."})
            
            valid_statuses = ["in_progress", "completed", "failed", "cancelled"]
            if status not in valid_statuses:
                return json.dumps({"error": f"Invalid status. Must be one of {valid_statuses}."})

            record_to_update = employee_trainings[training_record_id]
            record_to_update["status"] = status
            if completion_date is not None:
                record_to_update["completion_date"] = completion_date
            if score is not None:
                record_to_update["score"] = score
            if certificate_issued is not None:
                record_to_update["certificate_issued"] = certificate_issued
            if expiry_date is not None:
                record_to_update["expiry_date"] = expiry_date
            
            record_to_update["updated_at"] = timestamp
            return json.dumps(record_to_update)

        else:
            return json.dumps({"error": "Invalid operation. Must be 'create' or 'update'."})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        """
        Returns the schema for the ManageEmployeeTraining tool.
        """
        return {
            "type": "function",
            "function": {
                "name": "manage_employee_training",
                "description": "Handles employee enrollment in training programs (create) and tracks their progress and completion (update).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "operation": {"type": "string", "description": "Action: 'create' or 'update'."},
                        "employee_id": {"type": "string", "description": "The ID of the employee to be enrolled. Required for 'create'."},
                        "program_id": {"type": "string", "description": "The ID of the training program for enrollment. Required for 'create'."},
                        "enrollment_date": {"type": "string", "description": "The date the employee was enrolled (YYYY-MM-DD). Required for 'create'."},
                        "training_record_id": {"type": "string", "description": "The unique ID of the employee's training record. Required for 'update'."},
                        "status": {"type": "string", "description": "New status: 'in_progress', 'completed', 'failed', 'cancelled'. Required for 'update'."},
                        "completion_date": {"type": "string", "description": "The date the employee completed the training (YYYY-MM-DD). Optional for 'update'."},
                        "score": {"type": "number", "description": "The final score or grade, if applicable. Optional for 'update'."},
                        "certificate_issued": {"type": "boolean", "description": "'True', 'False'. Optional for 'update'."},
                        "expiry_date": {"type": "string", "description": "The expiration date of the certification, if applicable (YYYY-MM-DD). Optional for 'update'."},
                    },
                    "required": ["operation"],
                },
            },
        }


# -----------------

import json
from typing import Any, Dict, Optional

# A placeholder for the base Tool class
class Tool:
    pass

class ManageDocumentStorage(Tool):
    """
    Manages document storage, including uploads and metadata updates.
    """
    @staticmethod
    def generate_id(table: Dict[str, Any]) -> str:
        """Generates a new unique ID for a record."""
        if not table:
            return "1"
        return str(max(int(k) for k in table.keys()) + 1)

    @staticmethod
    def invoke(
        data: Dict[str, Any],
        operation: str,
        document_id: Optional[str] = None,
        document_name: Optional[str] = None,
        document_type: Optional[str] = None,
        file_path: Optional[str] = None,
        uploaded_by: Optional[str] = None,
        employee_id: Optional[str] = None,
        confidentiality_level: Optional[str] = 'internal',
        retention_period_years: Optional[int] = 7,
        status: Optional[str] = None,
        expiry_date: Optional[str] = None,
    ) -> str:
        """
        Executes the specified operation (create or update) on documents.
        """
        timestamp = "2025-10-01T00:00:00"
        documents = data.get("document_storage", {})
        users = data.get("users", {})
        employees = data.get("employees", {})

        if operation == "create":
            if not all([document_name, document_type, file_path, uploaded_by]):
                return json.dumps({"error": "Missing required parameters for create operation."})
            
            if uploaded_by not in users:
                return json.dumps({"error": f"User with ID {uploaded_by} not found."})
            if employee_id and employee_id not in employees:
                return json.dumps({"error": f"Employee with ID {employee_id} not found."})

            valid_types = ["contract", "policy", "handbook", "form", "certificate", "report", "resume", "offer_letter"]
            if document_type not in valid_types:
                return json.dumps({"error": f"Invalid document type. Must be one of {valid_types}."})

            new_doc_id = ManageDocumentStorage.generate_id(documents)
            new_document = {
                "document_id": new_doc_id,
                "document_name": document_name,
                "document_type": document_type,
                "employee_id": employee_id,
                "file_path": file_path,
                "upload_date": timestamp,
                "uploaded_by": uploaded_by,
                "confidentiality_level": confidentiality_level,
                "retention_period_years": retention_period_years,
                "expiry_date": None,
                "status": "active",
                "created_at": timestamp,
            }
            documents[new_doc_id] = new_document
            return json.dumps(new_document)

        elif operation == "update":
            if not all([document_id, status]):
                return json.dumps({"error": "Missing required parameters for update operation."})
            
            if document_id not in documents:
                return json.dumps({"error": f"Document with ID {document_id} not found."})

            valid_statuses = ["active", "archived", "deleted"]
            if status not in valid_statuses:
                return json.dumps({"error": f"Invalid status. Must be one of {valid_statuses}."})
            
            doc_to_update = documents[document_id]
            doc_to_update["status"] = status
            if document_name is not None:
                doc_to_update["document_name"] = document_name
            if confidentiality_level is not None:
                doc_to_update["confidentiality_level"] = confidentiality_level
            if expiry_date is not None:
                doc_to_update["expiry_date"] = expiry_date
            
            return json.dumps(doc_to_update)

        else:
            return json.dumps({"error": "Invalid operation. Must be 'create' or 'update'."})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        """
        Returns the schema for the ManageDocumentStorage tool.
        """
        return {
            "type": "function",
            "function": {
                "name": "manage_document_storage",
                "description": "Handles the uploading of new documents (create) and the modification of their metadata or status (update).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "operation": {"type": "string", "description": "Action: 'create' or 'update'."},
                        "document_name": {"type": "string", "description": "The display name of the document. Required for 'create', optional for 'update'."},
                        "document_type": {"type": "string", "description": "Type: 'contract', 'policy', 'handbook', 'form', 'certificate', 'report', 'resume', 'offer_letter'. Required for 'create'."},
                        "file_path": {"type": "string", "description": "The storage path where the document file is located. Required for 'create'."},
                        "uploaded_by": {"type": "string", "description": "The user ID of the person uploading the document. Required for 'create'."},
                        "employee_id": {"type": "string", "description": "The ID of the employee associated with this document. Optional for 'create'."},
                        "confidentiality_level": {"type": "string", "description": "Security level, defaults to 'internal'. Optional for 'create' and 'update'."},
                        "retention_period_years": {"type": "integer", "description": "The number of years the document must be stored. Defaults to 7. Optional for 'create'."},
                        "document_id": {"type": "string", "description": "The ID of the document to be updated. Required for 'update'."},
                        "status": {"type": "string", "description": "New status: 'active', 'archived', 'deleted'. Required for 'update'."},
                        "expiry_date": {"type": "string", "description": "A new or updated expiration date (YYYY-MM-DD). Optional for 'update'."},
                    },
                    "required": ["operation"],
                },
            },
        }


# Policy:
HR Payroll Policy & SOPs
Introduction
This document defines the operational guide for an HR Payroll automation agent. It is designed for single-turn execution: each procedure must be self-contained and completed in one interaction.
Validation first: All inputs must be validated. If any required element is missing or invalid, the process halts with a clear error message.
Halt conditions: If approvals are missing, compliance not satisfied, or external systems fail, the process halts with explicit instructions.
Logging: All steps must be logged. Every create, update, approve, reject, delete, or execute action must generate an audit log entry.
Role-based permissions: Only the defined roles can perform specified actions.
The elevated roles are: HR director, payroll_administrator, finance_officer, it_administrator, compliance_officer
Roles & Responsibilities
HR Director
Approve HR policies and major structural changes (departments, job levels).
Own role definitions and segregation of duties.
Escalation owner for compliance-critical HR actions.
Create and update department records
Create and update benefits plans
Create job positions
Post and close job openings
HR Manager
Oversee daily HR operations across recruitment, onboarding, leave, and employee records.
Ensure SOP adherence and timely approvals where required.
Process employee onboarding
Process employee offboarding and terminations
Manage performance review cycles
Update employee profiles
Create and manage training programs
Process leave requests
Create and update department records
Create job positions
Manage skills managements and job position skill requirements
Post and close job openings
Hiring Manager
Raise requisitions, participate in interviews, provide hiring decisions.
Cannot access payroll or benefits data unless explicitly granted.
Participate in interview scheduling and outcome recording
Manage application stage transitions per workflow
Create job positions
Associate skills with job positions
Post and close job openings
Schedule interviews and record outcomes
Can approve timesheet entries
Recruiter
Manage candidates and applications, schedule interviews, record outcomes.
Cannot approve compensation, payroll, or benefits.
Create and manage candidate records
Create job applications and manage application stages
Schedule interviews and record interview outcomes
Manage application stage transitions per workflow
Add candidate records to the system
Create job positions
Post and close job openings
Payroll Administrator
Create, update, and process payroll records, bonuses, and deductions.
Cannot approve their own payroll runs.
Submit and manage timesheet entries
Process payroll runs and calculations
Process payroll corrections
Aggregate hours and compute gross pay, deductions, and net pay
Process timesheet submissions and corrections
Finance Officer
Validate payroll accuracy and statutory deductions; approve or reject payroll runs.
Reconcile payroll with finance ledgers; authorize reimbursements and payouts.
Process expense reimbursements
Validate payroll calculations and reconciliation
Create and update benefits plans
Update expense reimbursement records
Compliance Officer
Approve or reject compliance-sensitive actions (tax filings, terminations, incidents).
Halt operations if legal or regulatory violations are detected.
IT / System Administrator
Configure RBAC, MFA, encryption; manage backups and audit logs.
Provision/deprovision system access promptly upon status change.
Employee
Provide accurate personal information; submit timesheets promptly.
Acknowledge policies and participate in reviews and training as required.
Submit timesheet entries with accurate work dates and hours
Enroll in and complete training programs
Submit leave requests with proper documentation
Participate in performance review cycles
Submit expense reimbursement requests
Upload and manage personal documents
Standard Operating Procedures
User Provisioning
Input Validation
Validate that email is present, follows valid email format, and is unique in the system using discover_user_entities
Validate that role is one of the supported system roles (HR Director, HR Manager, Recruiter, Payroll Administrator, Hiring Manager, Finance Officer, IT Administrator, Compliance Officer, Employee)
Validate that first name and last name are provided and non-empty
Check that user with this email does not already exist in the system using discover_user_entities
Authorization Check
Check if HR Director or IT Administrator approval is required for elevated roles (administrative and financial access roles) using check_approval
If approval is missing for elevated roles, then output 'Halt: Approval missing for elevated role assignment'
Record Creation
Create new user with required information: first name, last name, email, role using manage_user
Set optional information if provided: phone number
Set system defaults: active status, multi-factor authentication enabled
Generate unique user identifier
Audit Logging
Log the user provisioning action as a creation event in the audit trail using manage_audit_logs
Create/Update Department
Input Validation
For creation:
Validate that department name is provided and non-empty
Validate that assigned manager exists in the employee system and has active status using discover_employee_entities
Validate that budget amount follows proper decimal format if provided
For updates: Validate that department exists and has active status using discover_department_entities
Authorization Check
Check that HR Director approval is obtained for department creation, updates, or manager changes using check_approval
If approval is missing, then output 'Halt: Approval missing for department operation'
Record Management
For creation:
Create department with required information: department name, assigned manager using manage_department
Set optional information if provided: budget allocation
Set system defaults: active status
For updates: Update specified information while maintaining organizational integrity using manage_department
Audit Logging
Log the department action as creation or update event in the audit trail using manage_audit_logs
Create/Update Job Position
Input Validation
For creation:
Validate that position title and department assignment are provided
Validate that assigned department exists and has active status using discover_department_entities
Validate that employment type is within supported categories (full-time, part-time, contract, intern, temporary)
Validate that minimum hourly rate does not exceed maximum rate if both provided
Validate that salary rates are positive monetary values
For updates: Validate that position exists in the system using discover_job_entities
Authorization Check
Check that HR Director or Hiring Manager approval is obtained for positions using check_approval
If approval is missing, then output 'Halt: Approval missing for publishable position'
Post Job Opening
Input Validation
Validate that position exists and currently has draft status using discover_job_entities
Validate that position contains all required information for publication
Status Update
Change job position status from draft to open for public visibility using manage_job_position
Update modification timestamp
Audit Logging
Log the job posting action as an update event in the audit trail using manage_audit_logs
Skills Management
Validate that the skill name is provided and valid. If skill name is missing or invalid, then output 'Halt: Invalid skill details: [list]'
Check that HR Director approval is obtained for skills catalog operations using check_approval. If approval is missing, then output 'Halt: Approval missing for skills operation'
For creation, check that skill name does not already exist using discover_job_entities. If duplicate exists, then output 'Halt: Skill name already exists'
Create or update the skill record with the status provided (active/inactive) using manage_skill
Log the skills catalog action in the audit log using manage_audit_logs
Job Position Skills Management
Validate that the position ID is valid and skill IDs are provided using discover_job_entities. If position ID is invalid or skill IDs missing, then output 'Halt: Invalid position skills details: [list]'
Check that HR Director or Hiring Manager approval is obtained for position skills changes using check_approval. If approval is missing, then output 'Halt: Approval missing for position skills operation'
Verify that the job position exists and all specified skills exist in the skills catalog using discover_job_entities
For adding skills, check that skills are not already associated with the position. For removing skills, check that skills are currently associated
Add or remove skill associations for the job position using manage_job_position_skills
Log the position skills management action in the audit log using manage_audit_logs
Close Job Opening
Input Validation
Validate that position exists and currently has open status using discover_job_entities
Status Update
Change job position status from open to closed using manage_job_position
Audit Logging
Log the job closing event as an update event in the audit trail using manage_audit_logs
Adding Candidate Record
Input Validation
Validate that first name, last name, and email are provided and non-empty
Validate that email is unique in the system using discover_recruitment_entities
Validate that source is within accepted recruitment channels (job board, referral, company website, recruiter, social media, career fair)
Record Creation
Create candidate with required information: first name, last name, email, recruitment source using manage_candidate
Set optional information if provided: phone number, address
Set the status of the candidate as new if the status is not specified. The allowed statuses are: 'new', 'screening','interviewing','offer','hired','rejected','withdrawn'
Audit Logging
Log the candidate creation as a creation event in the audit trail using manage_audit_logs
Create/Update Job Application
Input Validation
For creation:
Validate that candidate and position exist and are valid using discover_recruitment_entities and discover_job_entities
Validate that assigned recruiter exists and has recruiter role using discover_user_entities
Validate that application date is provided and not in future
For updates:
Validate that application exists using discover_recruitment_entities
Validate status transitions follow proper workflow. Applications follow a linear progression: submitted → under_review → screening (with AI scoring) → interviewing → offer_made → accepted. Applications can exit to 'rejected' or 'withdrawn' from any active stage but cannot move backward, transition from terminal states (accepted, rejected, withdrawn), or skip intermediate steps.
Record Management
For creation:
Create application with required information: candidate, position, application date, assigned recruiter using manage_job_applications
Set status of the application as submitted unless the state is specified. The allowed states are: 'submitted','under_review','screening','interviewing','offer_made','accepted','rejected','withdrawn'
For updates:
Update specified information, ensure status transitions are valid using manage_job_applications
Optional information that are not required to create the job application but preferred: AI screening score (percentage), final hiring decision, current status
Audit Logging
Log the application action as creation or update event in the audit trail using manage_audit_logs
Manage Application Stage
Input Validation
Validate that the application exists, and the stage transition is valid using discover_recruitment_entities. If application is not found or stage transition is invalid, then output 'Halt: Invalid application status change'
Validate that AI screening score is within acceptable percentage range (0-100) if provided
Validate that final decision is within accepted options (hire, reject, hold) if provided
Authorization Check
Check that Recruiter or Hiring Manager approval is obtained using check_approval
Record Update
Update job application status and AI screening score if provided using manage_job_applications
Set final hiring decision (hire, reject, hold) if provided
Audit Logging
Log the stage change as an update event in the audit trail using manage_audit_logs
Schedule Interview
Input Validation
Validate that the application and interviewer exist using discover_recruitment_entities and discover_user_entities. If application or interviewer is missing → output 'Halt: Invalid interview scheduling details'
Validate that interview type is within accepted categories (phone screening, technical, behavioral, panel, final)
Validate that scheduled date and time is in the future
Validate that duration is a positive time value with reasonable default
Record Creation
Create interview with required information: application, interviewer, interview type, scheduled date and time using manage_interviews
Set optional information if provided: duration
Set system defaults: scheduled status, standard duration
Generate unique interview identifier
Audit Logging
Log the interview scheduling as a creation event in the audit trail using manage_audit_logs
Record Interview Outcome
Input Validation
Validate that interview exists and has scheduled or completed status using discover_recruitment_entities
Validate that overall rating is within accepted scale (excellent through poor)
Validate that individual scores are within acceptable numeric range if provided (technical, communication, cultural fit)
Validate that recommendation is within accepted options (strong hire, hire, no hire, strong no hire)
Record Update
Update interview with outcome information: overall rating, individual scores, recommendation using manage_interviews
Change status to completed
Update related job application status based on interview outcome using manage_job_applications. The update for job application is as follows: positive recommendations ('strong_hire' or 'hire') advance 'interviewing' status to 'offer_made', while negative recommendations ('no_hire' or 'strong_no_hire') immediately set status to 'rejected'. When no recommendation is provided, applications with 'excellent' or 'good' ratings remain at 'interviewing' for potential additional interviews, while 'poor' or 'below_average' ratings trigger 'rejected' status. Final interviews with positive recommendations automatically advance to 'offer_made'.
Audit Logging
Log the interview outcome as an update event in the audit trail using manage_audit_logs
Employee Onboarding
Input Validation
Validate that all required information is provided: user account, position assignment, hire date
Validate that user account exists and is not already associated with an employee record using discover_user_entities and discover_employee_entities
Validate that assigned position exists and has active status using discover_job_entities
Validate that hire date is not in the past
Validate that hourly rate is positive monetary value, if provided
Validate optional information if provided: manager assignment (must exist in employee system using discover_employee_entities), date of birth, address
Authorization Check
Check that HR Manager approval is obtained and Compliance verification for eligibility documents is completed using check_approval
If approvals are missing, then output 'Halt: Approval or compliance verification missing'
Record Creation
Create employee record with required information: user account, position, hire date using manage_employee
Set optional information if provided: manager assignment, personal details, compensation rate
Set system defaults: active employment status
Update user account to active status using manage_user
Document Generation
Generate and store welcome documents in the document management system using manage_document_storage
Audit Logging
Log all onboarding actions as creation events in the audit trail using manage_audit_logs
Update Employee Profile
Input Validation
Validate that employee exists and has active status using discover_employee_entities
Validate that employment status is within accepted values (active, terminated, on leave, suspended)
Validate that hourly rate is positive monetary value if provided
Record Update
Update employee record information using manage_employee
Track before and after values for audit purposes
Audit Logging
Log before and after values as update events in the audit trail using manage_audit_logs
Employee Offboarding
Input Validation
Validate that employee exists and has active employment status using discover_employee_entities
Check for pending payroll records that have not been finalized using discover_payroll_entities
Check for active benefits enrollments using discover_benefits_entities
Check for incomplete training programs using discover_training_entities
Authorization Check
Check that HR Manager and Compliance Officer approvals are obtained using check_approval
If approvals are missing, then output 'Halt: Required approvals missing'
Record Updates
Set employee employment status to terminated using manage_employee
Update user account status to inactive using manage_user
Terminate active benefits enrollments using manage_employee_benefits
Cancel incomplete training enrollments using manage_employee_training
Audit Logging
Log all offboarding steps as update events in the audit trail using manage_audit_logs
Timesheet Submission
Input Validation
Validate that employee exists and has active status using discover_employee_entities
Validate that work date is provided and not in future
Validate that clock in and clock out times are provided and logical (clock in occurs before clock out)
Validate that break duration is non-negative time value with reasonable default
Record Creation
Create timesheet with required information: employee, work date, clock in time, clock out time using manage_timesheet_entries
Calculate total hours worked based on time difference minus break duration
Set optional information if provided: break duration, project assignment
Set system defaults: submitted status, zero break time
Audit Logging
Log the timesheet submission as a creation event in the audit trail using manage_audit_logs
Timesheet Approval/Correction
Input Validation
Validate that timesheet exists in the system using discover_timesheet_entities
Validate that approver has payroll administrator or hiring manager role using discover_user_entities
Validate status transitions follow proper workflow (draft or submitted to approved or rejected)
Authorization Check
Verify approver is authorized manager (Payroll Administrator or Hiring Manager) using check_approval
If unauthorized, then output 'Halt: Unauthorized access'
Record Update
Update timesheet with approver information and change status to approved or rejected using manage_timesheet_entries
Adjust time information if correction requested (total hours, break duration)
Audit Logging
Log approval and corrections as update events in the audit trail using manage_audit_logs
Process Payroll Run
Input Validation
Validate that all required information is provided: employee, pay period dates
Validate that pay period dates are logical (start date before end date)
Validate that hourly rate is positive monetary value
Aggregate approved timesheet hours for the specified pay period using discover_timesheet_entities
Authorization Check
Check that Finance Officer approval is obtained using check_approval
If approval is missing, then output 'Halt: Finance Officer approval required'
Record Creation/Update
Create payroll record with required information: employee, pay period dates, hourly rate using manage_payroll_records
Calculate hours worked from approved timesheets
Audit Logging
Log all payroll transactions as creation events in the audit trail using manage_audit_logs
Payroll Correction
Input Validation
Validate that payroll record exists in the system using discover_payroll_entities
Validate that correction information is valid (hours worked and hourly rate must be positive)
Authorization Check
Check that Finance Officer approval is obtained using check_approval
If approval is missing, then output 'Halt: Finance Officer approval required'
Record Update
Adjust payroll record with correction details using manage_payroll_records
Update modification timestamp
Audit Logging
Log the payroll correction as an update event in the audit trail using manage_audit_logs
Create/Update Benefits Plan
Input Validation
For creation:
Validate that plan name and plan type are provided
Validate that plan type is within supported categories (health insurance, dental, vision, life insurance, disability, retirement, paid time off, flexible spending)
Validate that effective date is provided and expiration date occurs after effective date if provided
Validate that cost amounts are non-negative monetary values if provided
For updates: Validate that plan exists in the system using discover_benefits_entities
Authorization Check
Check that HR Director or Finance Officer approval is obtained using check_approval
If approval is missing, then output 'Halt: HR Director or Finance Officer approval required'
Record Management
For creation: Create plan with required information: plan name, plan type, effective date using manage_benefits_plans
Set optional information if provided: provider, employee cost, employer cost, expiration date
Set system defaults: active status
For updates: Update specified information while maintaining date consistency using manage_benefits_plans
Audit Logging
Log the benefits plan action as creation or update event in the audit trail using manage_audit_logs
Employee Benefits Enrollment & Update
Input Validation
For enrollment: Validate that employee and benefits plan exist and have active status using discover_employee_entities and discover_benefits_entities
Validate that enrollment date is provided and not in future
Validate that coverage level is within accepted options (employee only, employee plus spouse, employee plus children, family coverage)
Check that employee is not already enrolled in the same plan type using discover_benefits_entities
For updates: Validate that enrollment record exists using discover_benefits_entities
Record Management
For enrollment: Create benefits enrollment with required information: employee, plan, enrollment date, coverage level using manage_employee_benefits
Set optional information if provided: beneficiary name and relationship
Set system defaults: active enrollment status
For updates: Update specified information, validate status transitions using manage_employee_benefits
Audit Logging
Log the benefits enrollment change as creation or update event in the audit trail using manage_audit_logs
Performance Review Cycle
Input Validation
Validate that employee and reviewer exist and have active status using discover_employee_entities
Validate that review period dates are logical (start date before end date)
Validate that review type is within accepted categories (annual, quarterly, probationary, project-based)
Authorization Check
Check that HR Manager approval is obtained for final approval using check_approval
If approval is missing, then output 'Halt: HR Manager approval required'
Record Management
Create performance review with required information: employee, reviewer, review period dates, review type, overall rating using manage_performance_reviews
Set optional score information if provided for various competency areas
Update status through proper progression (draft to submitted to approved)
Audit Logging
Log all status transitions as creation or update events in the audit trail using manage_audit_logs
Creating Training Program
Validate that all program fields are provided and valid. If program fields are missing or invalid, then output 'Halt: Invalid training program details'
Create or update training programs with mandatory flag if the training is required and set status to 'active' using manage_training_programs
Log the training program action in the audit trail using manage_audit_logs
Employee Training Enrollment & Completion
Validate that the employee and training program are valid using discover_employee_entities and discover_training_entities. If employee or program is invalid, then output 'Halt: Invalid training enrollment'
Create or update employee training record with status progression (enrolled → completed) and set expiry date if applicable using manage_employee_training
Log the training enrollment and completion in the audit trail using manage_audit_logs
Document Upload & Management
Validate that the document type is supported and all required metadata is provided. If document type is unsupported or metadata is missing, then output 'Halt: Invalid document metadata: [list]'
Insert document into document storage system with confidentiality level and retention period in years, and store file pointer using manage_document_storage
Log the document creation in the audit trail using manage_audit_logs
Audit Trail Logging (Global)
Input Validation
Validate that all required information is provided: user, action type, reference type, reference identifier
Validate that user exists in the system using discover_user_entities
Validate that action type is within accepted values (create, read, update, delete, approve, reject)
For field-level changes, validate that field name, old value, and new value are provided
Record Creation
Create audit log entry with all provided information using manage_audit_logs
Set timestamp to current system time
For record-level operations (create or delete), set field-level change information to null
Error Handling
If audit log write fails, then output 'Halt: Audit trail failure'
Leave Request Processing
Input Validation
Validate that employee exists and has active status using discover_employee_entities
Validate that leave type is within accepted categories (annual, sick, family medical leave, personal, bereavement, jury duty)
Validate that start and end dates are provided and logical (start date on or before end date, not in past)
Calculate requested days from date range
Record Creation
Create leave request with required information: employee, leave type, start date, end date, requested days using manage_leave_requests
Calculate and set remaining balance after this request
Set the approval status as pending unless logging a leave request that has many changes incurred to it.
Audit Logging
Log the leave request submission as a creation event in the audit trail using manage_audit_logs
Create/Update Expense Reimbursement
Input Validation
For creation:
Validate that employee, expense date, amount, and expense type are provided
Validate that employee exists and has active status using discover_employee_entities
Validate that expense type is within accepted categories (travel, meals, equipment, training, other)
Validate that amount is positive monetary value
Validate that expense date is not in future
For updates: Validate that reimbursement record exists and has submitted status using discover_expense_entities
Record Management
For creation: Create reimbursement with required information: employee, expense date, amount, expense type using manage_expense_reimbursements
For updates: Update specified information (amount, receipt location) only if status allows modification using manage_expense_reimbursements
Audit Logging
Log the reimbursement action as creation or update event in the audit trail using manage_audit_logs
Process Expense Reimbursement
Input Validation
Validate that reimbursement record exists in the system using discover_expense_entities
Validate that approving user exists and has appropriate role using discover_user_entities
Validate that status is within accepted values (approved, rejected, paid)
Validate status transitions follow proper workflow (submitted to approved or rejected, approved to paid)
Record Update
Update reimbursement status to specified value using manage_expense_reimbursements
Set approver information to approving user if status is approved
Set payment date if status is paid and payment date is provided
Audit Logging
Log the reimbursement processing as an update event in the audit trail using manage_audit_logs
Payroll Deductions Management
Input Validation
Validate that payroll record exists in the system using discover_payroll_entities
Validate that deduction type is within accepted categories (tax, insurance, retirement, garnishment, equipment, other)
Validate that deduction amount is positive monetary value
Validate that creator exists in the user system using discover_user_entities
Record Creation
Create deduction with required information: payroll record, deduction type, amount, creator using manage_payroll_deductions
Generate unique deduction identifier
Audit Logging
Log the deduction creation as a creation event in the audit trail using manage_audit_logs



# Database Schema:
// Use DBML to define your database structure
// HR Management System Database Schema
// This schema represents a comprehensive database for managing human resources operations,
// including recruitment, payroll, employee management, compliance, and AI/LLM governance

Table users {
  user_id string [primary key]
  first_name varchar(100) [not null]
  last_name varchar(100) [not null]
  email varchar(320) [not null, unique]
  phone_number varchar(20)
  role enum('hr_director','hr_manager','recruiter','payroll_administrator','hiring_manager','finance_officer','it_administrator','compliance_officer','employee') [not null]
  status enum('active','inactive','suspended') [not null, default: 'active']
  // last_login timestamp
  mfa_enabled boolean [default: true]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table departments {
  department_id string [primary key]
  department_name varchar(255) [not null]
  manager_id string [not null]
  budget decimal(15,2)
  status enum('active','inactive') [not null, default: 'active']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table job_positions {
  position_id string [primary key]
  title varchar(255) [not null]
  department_id string [not null]
  job_level enum('entry','junior','mid','senior','lead','manager','director','executive') [not null]
  employment_type enum('full_time','part_time','contract','intern','temporary') [not null]
  hourly_rate_min  decimal(12,2)
  hourly_rate_max  decimal(12,2)
  // required_skills text
  status enum('open','closed','draft') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table skills {
  skill_id string [primary key]
  skill_name text [not null]
  status enum('active','inactive') [default: 'active']
}

Table job_position_skills {
  position_id string [not null]
  skill_id string [not null]
  primary key (position_id, skill_id)
}

Ref: job_position_skills.position_id > job_positions.position_id
Ref: job_position_skills.skill_id > skills.skill_id


Table employees {
  employee_id string [primary key]
  user_id string [not null, unique]
  position_id string [not null]
  hire_date date [not null]
  employment_status enum('active','terminated','on_leave','suspended') [not null, default: 'active']
  manager_id string
  date_of_birth date
  address text
  hourly_rate int
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table candidates {
  candidate_id string [primary key]
  first_name varchar(100) [not null]
  last_name varchar(100) [not null]
  email varchar(320) [not null]
  phone_number varchar(20)
  address text
  // resume_file_path varchar(500)
  // linkedin_profile varchar(500)
  source enum('job_board','referral','company_website','recruiter','social_media','career_fair') [not null]
  status enum('new','screening','interviewing','offer','hired','rejected','withdrawn') [not null, default: 'new']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table job_applications {
  application_id string [primary key]
  candidate_id string [not null]
  position_id string [not null]
  application_date date [not null]
  status enum('submitted','under_review','screening','interviewing','offer_made','accepted','rejected','withdrawn') [not null, default: 'submitted']
  recruiter_id string [not null]
  // cover_letter text
  ai_screening_score decimal(5,2)
  // ai_recommendations text
  final_decision enum('hire','reject','hold') 
  // decision_reason text
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table interviews {
  interview_id string [primary key]
  application_id string [not null]
  interviewer_id string [not null]
  interview_type enum('phone_screening','technical','behavioral','panel','final') [not null]
  scheduled_date timestamp [not null]
  duration_minutes integer [default: 60]
  status enum('scheduled','completed','cancelled','no_show') [not null, default: 'scheduled']
  overall_rating enum('excellent','good','average','below_average','poor')
  technical_score decimal(3,1)
  communication_score decimal(3,1)
  cultural_fit_score decimal(3,1)
  // notes text
  recommendation enum('strong_hire','hire','no_hire','strong_no_hire')
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table payroll_records {
  payroll_id string [primary key]
  employee_id string [not null]
  pay_period_start date [not null]
  pay_period_end date [not null]
  hours_worked decimal(6,2)
  // overtime_hours decimal(6,2)
  hourly_rate decimal(12,2) [not null]
  // overtime_pay decimal(12,2)
  // bonus decimal(12,2)
  // gross_pay decimal(12,2) [not null]
  // total_deductions decimal(12,2) [not null]   // 👈 single field
  // net_pay decimal(12,2) [not null]
  payment_date date
  status enum('draft','approved','paid','cancelled') [not null, default: 'draft']
  approved_by string
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table payroll_deductions {
  deduction_id string [primary key]
  payroll_id string [not null]
  deduction_type enum('tax','insurance','retirement','garnishment','equipment','other') [not null]
  // description varchar(255) [not null]
  amount decimal(10,2) [not null]
  // is_pre_tax boolean [default: false]
  created_by string [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table benefits_plans {
  plan_id string [primary key]
  plan_name varchar(255) [not null]
  plan_type enum('health_insurance','dental','vision','life_insurance','disability','retirement_401k','pto','flexible_spending') [not null]
  provider varchar(255)
  // description text
  employee_cost decimal(10,2)
  employer_cost decimal(10,2)
  status enum('active','inactive') [not null, default: 'active']
  effective_date date [not null]
  expiration_date date
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table employee_benefits {
  enrollment_id string [primary key]
  employee_id string [not null]
  plan_id string [not null]
  enrollment_date date [not null]
  status enum('active','terminated','pending') [not null, default: 'active']
  // employee_contribution decimal(10,2)
  coverage_level enum('employee_only','employee_spouse','employee_children','family') [not null]
  beneficiary_name varchar(255)
  beneficiary_relationship varchar(100)
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table performance_reviews {
  review_id string [primary key]
  employee_id string [not null]
  reviewer_id string [not null]
  review_period_start date [not null]
  review_period_end date [not null]
  review_type enum('annual','quarterly','probationary','project_based') [not null]
  overall_rating enum('exceeds_expectations','meets_expectations','below_expectations','unsatisfactory') [not null]
  goals_achievement_score decimal(3,1)
  communication_score decimal(3,1)
  teamwork_score decimal(3,1)
  leadership_score decimal(3,1)
  technical_skills_score decimal(3,1)
  // comments text
  // development_goals text
  status enum('draft','submitted','approved') [not null, default: 'draft']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

// Table leave_requests {
//   leave_id string [primary key]
//   employee_id string [not null]
//   leave_type enum('annual','sick','fmla','personal','bereavement','jury_duty') [not null]
//   start_date date [not null]
//   end_date date [not null]
//   days_requested decimal(3,1) [not null]
//   // reason text
//   status enum('pending','approved','rejected','cancelled') [not null, default: 'pending']
//   processed_by string
//   processing_date timestamp
//   remaining_balance decimal(5,1)
//   created_at timestamp [not null, default: `NOW()`]
//   updated_at timestamp [not null, default: `NOW()`]
// }

Table leave_requests {
  leave_id string [primary key]
  employee_id string [not null]
  leave_type enum('annual','sick','fmla','personal','bereavement','jury_duty') [not null]
  start_date date [not null]
  end_date date [not null]
  days_requested decimal(3,1) [not null]
  status enum('pending','approved','rejected','cancelled') [not null, default: 'pending']
  approved_by string
  approval_date timestamp
  remaining_balance decimal(5,1) // filled after approval
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}



Table expense_reimbursements {
  reimbursement_id string [primary key]
  employee_id string [not null]
  expense_date date [not null]
  amount decimal(10,2) [not null]
  expense_type enum('travel','meals','equipment','training','other') [not null]
  // description text [not null]
  receipt_file_path varchar(500)
  status enum('submitted','approved','rejected','paid') [not null, default: 'submitted']
  approved_by string
  payment_date date
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table training_programs {
  program_id string [primary key]
  program_name varchar(255) [not null]
  program_type enum('onboarding','compliance','technical','leadership','safety','diversity','ai_ethics') [not null]
  // description text
  duration_hours integer [not null]
  delivery_method enum('in_person','online','hybrid','self_paced') [not null]
  mandatory boolean [default: false]
  status enum('active','inactive','draft') [not null, default: 'active']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table employee_training {
  training_record_id string [primary key]
  employee_id string [not null]
  program_id string [not null]
  enrollment_date date [not null]
  completion_date date
  status enum('enrolled','in_progress','completed','failed','cancelled') [not null, default: 'enrolled']
  score decimal(5,2)
  certificate_issued boolean [default: false]
  expiry_date date
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table audit_logs {
  log_id string [primary key]
  user_id string [not null]
  action enum('create','read','update','delete','approve','reject') [not null]
  reference_type string [not null]
  reference_id string [not null]
  field_name varchar(100)
  old_value text
  new_value text
  timestamp timestamp [not null, default: `NOW()`]
}


// Table compliance_records {
//   compliance_id string [primary key]
//   record_type enum('eeoc_report','flsa_audit','ada_accommodation','fmla_leave','safety_incident','data_breach','ai_bias_test') [not null]
//   employee_id string
//   // description text [not null]
//   compliance_officer_id string [not null]
//   status enum('open','under_review','resolved','escalated') [not null, default: 'open']
//   severity enum('low','medium','high','critical') [not null]
//   due_date date
//   // resolution_notes text
//   created_at timestamp [not null, default: `NOW()`]
//   updated_at timestamp [not null, default: `NOW()`]
// }


Table document_storage {
  document_id string [primary key]
  document_name varchar(255) [not null]
  document_type enum('contract','policy','handbook','form','certificate','report','resume','offer_letter') [not null]
  employee_id string
  file_path varchar(500) [not null]
  // file_size_bytes bigint
  upload_date timestamp [not null]
  uploaded_by string [not null]
  confidentiality_level enum('public','internal','confidential','restricted') [not null, default: 'internal']
  retention_period_years integer [not null, default: 7]
  expiry_date date
  status enum('active','archived','deleted') [not null, default: 'active']
  created_at timestamp [not null, default: `NOW()`]
}

// RELATIONSHIPS

// User and Employee relationships
Ref: employees.user_id > users.user_id
Ref: employees.manager_id > employees.employee_id
Ref: employees.position_id > job_positions.position_id

// Department relationships
Ref: departments.manager_id > employees.employee_id
Ref: job_positions.department_id > departments.department_id

// Application and Interview relationships
Ref: job_applications.candidate_id > candidates.candidate_id
Ref: job_applications.position_id > job_positions.position_id
Ref: job_applications.recruiter_id > users.user_id
Ref: interviews.application_id > job_applications.application_id
Ref: interviews.interviewer_id > users.user_id

// Payroll relationships
Ref: payroll_records.employee_id > employees.employee_id
Ref: payroll_records.approved_by > users.user_id

// Benefits relationships
Ref: employee_benefits.employee_id > employees.employee_id
Ref: employee_benefits.plan_id > benefits_plans.plan_id

// Performance and Training relationships
Ref: performance_reviews.employee_id > employees.employee_id
Ref: performance_reviews.reviewer_id > users.user_id
Ref: employee_training.employee_id > employees.employee_id
Ref: employee_training.program_id > training_programs.program_id

Ref: audit_logs.user_id > users.user_id


// Compliance and Incident relationships
// Ref: compliance_records.employee_id > employees.employee_id
// Ref: compliance_records.compliance_officer_id > users.user_id

// Document relationships
Ref: document_storage.employee_id > employees.employee_id
Ref: document_storage.uploaded_by > users.user_id

Table employee_timesheets {
  timesheet_id string [primary key]
  employee_id string [not null]
  work_date date [not null]
  clock_in_time timestamp
  clock_out_time timestamp
  break_duration_minutes integer [default: 0]
  total_hours decimal(4,2)
  // overtime_hours decimal(4,2) [default: 0]
  project_code varchar(50)
  // notes text
  approved_by string
  status enum('draft','submitted','approved','rejected') [not null, default: 'draft']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

// Additional relationships for new tables
Ref: employee_timesheets.employee_id > employees.employee_id
Ref: employee_timesheets.approved_by > users.user_id

Ref: payroll_deductions.payroll_id > payroll_records.payroll_id
Ref: payroll_deductions.created_by > users.user_id

Ref: leave_requests.employee_id > employees.employee_id
Ref: leave_requests.approved_by > users.user_id

Ref: expense_reimbursements.employee_id > employees.employee_id
Ref: expense_reimbursements.approved_by > users.user_id


You have to provide the json file for each function separately including all the tests for that function in the actions part. You are going to provide the bash script that will create and populate those json files in a folder named tools_regression_tests/interface_2/.
