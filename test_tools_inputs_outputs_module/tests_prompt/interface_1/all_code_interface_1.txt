Assume you are an experienced tester. I am going to give you python functions and you are going to give me the inputs to test this function. The inputs are provided in the form of actions. You have to provide three tests for each function within the same file with the most number of parameters as possible (if applicable). However, you have to follow the format that I provide to you below.

# Format:
{
    "env": "wiki_pages",
    "interface_num": 1,
    "task": {
        "actions": [
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            },
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            }
        ]
    }
}

where the name of action is the function name and the arguments are the parameters of the function. You have to provide multiple actions for a single file in a single test if applicable. 

# Functions:
ALL_TOOLS_INTERFACE_1 = []


# Policy:
WIKI MANAGEMENT POLICY

As a Wiki Management Agent, you are responsible for executing space and page management processes, including space creation, page lifecycle management, permissions, and components.
General Operating Principles
You must not provide any information, knowledge, procedures, subjective recommendations, or comments that are not supplied by the user or available through tools.
You must deny user requests that violate this policy.
All Standard Operating Procedures (SOPs) are designed for single-turn execution. Each procedure is self-contained and must be completed in one interaction. Each SOP provides clear steps for proceeding when conditions are met and explicit halt instructions with error reporting when conditions are not met.


Permission Structure
Admin permissions encompass all other permissions. Users with "admin" permission level automatically have "create", "edit", "view", "delete", "restrict_other_users" and all other permission types for the given entity.
User permissions on pages include both direct permissions (explicitly granted on the page itself) and inherited permissions (cascaded from parent pages up the hierarchy and from the containing space). Permissions flow down from parent to child pages automatically.


Critical Halt and Transfer Conditions
You must halt the procedure and immediately initiate a transfer_to_human if you encounter any of the following critical conditions:

The user is unauthorized or lacks the necessary privileges/permissions.
Missing or invalid credentials are provided.
Any required entity lookup (get_page, get_entity, etc.) raises an error or the entity is not found.
A failure occurs during the procedure that prevents the request from being fulfilled.
If any external integration (e.g., database or API) fails, you must halt and provide appropriate error messaging.

Only when none of these conditions occur should you proceed to complete the SOP.


Standard Operating Procedures (SOPs)
1. Create Page
Steps:

Determine whether the new page is a child page.

Retrieve the user details and verify the user exists and with “active” status using get_user.

If creating a child page:

Retrieve parent page details using get_page.

Retrieve and verify user permission to "create" on the parent page using get_permissions.

If not a child page, creating a page within a space:

Verify the space where the page is to be created exists using get_space.
Verify user permission to "create" a page in the target space using get_permissions.

If authorized:

Create the new page using create_page.

Create the initial page version using create_page_version.

Create a permission entry for the new page using create_permission and make the page creator the “admin.”
2. Update Page
Steps:

Retrieve the user details and verify the user exists and with “active” status using get_user

Retrieve the page and verify “edit” permission using get_permissions.

Check if the page has descendants using get_descendants.

If moving the page to a different space:

Retrieve the target space using get_space.

Iteratively update the page and all descendants using update_page.

If updating the page’s parent:

Retrieve the new parent page using get_page.

Update the parent reference using update_page.

Align all descendant permissions using update_permission.

If updating the page title:

Verify the title is unique within the space using get_page.

Apply the update using update_page.

Create a new page version using create_page_version.
3. Remove Page
Steps:

Retrieve the target page using get_page and Verify it is not “locked” or “archived”.

Retrieve the user details and verify the user exists and with “active” status using get_user

Verify "delete" permission using get_permissions.

Check for descendants using get_descendants.

If descendants exist:

Retrieve direct children using get_direct_children.

Retrieve the parent page using get_ancestors.

If the parent exists: Assign children to parent using update_page.

If no parent exists: Retained children become root-level pages.

Create a new page version for the descendants using create_page_version.

Delete the target page using delete_page.

If hard delete:

Retrieve all page versions using get_versions.

Delete all versions using delete_page_version.
4. Modify Page Permissions
Steps:

Retrieve the target page using get_page.

The user who wants to change the permissions is the “current user” while the user whose permission is to be changed is the “target user”

Retrieve the “current user” and the “target user” details, and verify that both users exists with “active” status using get_user 

Verify that the “current user” has “admin” or “restrict_other_users” permission privilege using get_permissions.


Retrieve the current permission of the “target user” using get_permissions.

Update permission of the “target user” using update_permission.
  **Note:** You can only modify direct permissions explicitly granted on this page. Inherited permissions (cascaded from parent pages or the containing space) cannot be modified at the page level.

If the page has descendants (get_descendants), apply permission updates to all descendants.

Create a new page version using create_page_version.
5. Create Whiteboard
Steps:

Retrieve the hosting space/page and confirm that the page exists using get_space or get_page.

Retrieve the user details and verify the user exists and with “active” status using get_user

Verify “create” permission using get_permissions.

Create the whiteboard using create_whiteboard.

If the whiteboard is created on a page level, create a page version using create_page_version.
6. Update Whiteboard
Steps:

Verify that the whiteboard exists and retrieve the whiteboard details using get_entity.

Retrieve the hosting space or page and verify its existence using the appropriate API (using get_space or get_page, respectively)

Retrieve the user details and verify the user exists and with “active” status using get_user

Verify “edit” permission using get_permissions.

Update the whiteboard using update_whiteboard.

If the whiteboard is on a page level, create a page version using create_page_version.
7. Remove Whiteboard
Steps:

Retrieve the hosting space/page and confirm that the page exists using get_space or get_page.

Retrieve the user details and verify the user exists and with “active” status using get_user

Verify “delete” permission using get_permissions.

Retrieve all smart links referencing the whiteboard using get_entity.

Recursively delete each smart link using delete_smart_link.

Delete the whiteboard using delete_whiteboard.

If the whiteboard is on a page level, create a page version using create_page_version.
8. Create Smart Link
Steps:

Retrieve the hosting page and confirm that the page exists using get_page.

Determine the smart link reference entity type:

If the entity type is “page”, retrieve the page details using get_page.

If the entity is external, proceed to step 3.

Otherwise:

retrieve the entity using get_entity.

Then retrieve the hosting space/page of the entity using get_space or get_page.

Retrieve the user details and verify the user exists and with “active” status using get_user

Verify “create” permission using get_permissions.

Create the smart link using create_smart_link.


Create a page version using create_page_version.
9. Remove Smart Link
Steps:

Retrieve the smart link using get_entity.

Determine the smart link reference entity type:

If the entity type is “page”, retrieve the page details using get_page.

If the entity is “external”, proceed to step 3.

Otherwise:

retrieve the entity using get_entity.

Then retrieve the hosting space/page of the entity using get_space or get_page.

Retrieve the user details and verify the user exists and with “active” status using get_user

Verify the user has “delete” permission for the host page using get_permissions.

Delete the smart link using delete_smart_link.

Create a page version using create_page_version.
10. Update Smart Link
Steps:

Retrieve the smart link using get_entity.

Retrieve the hosting page and confirm that the page exists using get_page.

Retrieve the user details and verify the user exists and with “active” status using get_user

Verify “edit” permission using get_permissions.

Update the smart link using update_smart_link.

Create a page version using create_page_version.
11. Create Database
Steps:

Retrieve the hosting space/page and confirm that the space or page exists using get_space or get_page respectively.

Retrieve the user details and verify the user exists and with “active” status using get_user

Verify “create” permission using get_permissions.

Create the database using create_database.
12. Remove Database
Steps:

Retrieve the hosting space/page and confirm that the space or page exists using get_space or get_page respectively.

Retrieve the user details and verify the user exists and with “active” status using get_user

Verify “delete” permission using get_permissions.

Retrieve the database using get_entity.

Retrieve and recursively delete all smart links referenced using delete_smart_link.

Delete the database using delete_database.
13. Update Database
Steps:

Retrieve the hosting space/page and confirm that the space or page exists using get_space or get_page respectively.

Retrieve the user details and verify the user exists and with “active” status using get_user

Verify “edit” permission using get_permissions.

Retrieve the database using get_entity.

Update the database using update_database.
14. Add Label or Attachment
Steps:

Retrieve the hosting page and confirm that the page exists using get_page.

Retrieve the user details and verify the user exists and with “active” status using get_user

Verify the user has “create” permission on the page using get_permissions.

If authorized:

To add an attachment, upload the file using create_attachment.

To add a label, assign the label to the page using create_label.
15. Remove Label or Attachment
Steps:

Retrieve the hosting page and confirm that the page exists using get_page.

Retrieve the user details and verify the user exists and with “active” status using get_user

Verify the user has “delete” permission on the page using get_permissions.

Retrieve the label or attachment details using get_entity.

If the item exists:

To remove an attachment, delete it using remove_attachment.

To remove a label, detach it from the page using remove_label.
16. Update Label or Attachment
Steps:

Retrieve the hosting page and confirm that the page exists using get_page.

Retrieve the user details and verify the user exists and with “active” status using get_user

Verify the user has “edit” permission on the page using get_permissions.

Retrieve the label or attachment details using get_entity.

If the item exists:

To update an attachment, apply the changes using update_attachment.

To update a label, apply the changes using update_label.





# Database Schema:
// DBML Schema for Confluence Content Management System
// Based on actual Confluence database table structure

// ============================================================================
// CORE CONTENT TYPES
// ============================================================================

Table pages {
  page_id varchar(50) [primary key]
  // page_number varchar(50) [not null, unique] // e.g., PAGE0000001
  title varchar(500) [not null]
  space_id varchar(50) [not null]
  parent_page_id varchar(50) // nullable for root pages
  body_storage text // 
  // body_view text // rendered HTML
  status enum('current','draft','locked', 'archived','deleted') [not null, default: 'current']
  // version_number int [not null, default: 1]
  created_by varchar(50) [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_by varchar(50) [not null]
  updated_at timestamp [not null, default: `NOW()`]

  indexes {
    parent_page_id
    space_id
    // folder_id
    (space_id, status)
    // page_number [unique]
  }
}

Table databases {
  database_id varchar(50) [primary key]
  title varchar(500) [not null]
  host_space_id varchar(50)      // For space-level databases
  host_page_id varchar(50)       // For page-level databases
  // Either host_space_id OR host_page_id must be set (mutually exclusive)
  description text
  status enum('current','archived','deleted') [not null, default: 'current']
  created_by varchar(50) [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_by varchar(50) [not null]
  updated_at timestamp [not null, default: `NOW()`]
  
  indexes {
    host_space_id
    host_page_id
  }
}

Table whiteboards {
  whiteboard_id varchar(50) [primary key]
  title varchar(500) [not null]
  host_space_id varchar(50)      // For space-level whiteboards
  host_page_id varchar(50)       // For page-level whiteboards  
  content text
  status enum('current','archived','deleted', 'locked') [not null, default: 'current']
  created_by varchar(50) [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_by varchar(50) [not null]
  updated_at timestamp [not null, default: `NOW()`]
  
  indexes {
    host_space_id
    host_page_id
  }
}

Table smart_links {
  smart_link_id varchar(50) [primary key]
  title varchar(500) [not null]
  url varchar(2000) [not null]
  
  // What this smart link POINTS TO (the reference/target)
  target_id varchar(50)           // The entity this link references
  target_type enum('page','database','whiteboard','external', 'attachment')
  
  // Where this smart link is DISPLAYED (the container)
  host_page_id varchar(50) [not null]
  // host_id varchar(50) [not null]
  // host_type enum('page','database','whiteboard') [not null]
  
  // link_type varchar(100) // e.g., 'jira_issue', 'external_url', etc.
  // link_type enum(
  //   'internal_link',
  //   'document_link',
  //   'repository_link',
  //   'communication_link',
  //   'media_link',
  //   'external_url'
  // ) [not null, default: 'external_url']
  // status enum('current','archived','deleted') [not null, default: 'current']
  created_by varchar(50) [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_by varchar(50) [not null]
  updated_at timestamp [not null, default: `NOW()`]
  
  indexes {
    // parent_id
    // space_id
    url
  }
}


// ============================================================================
// SPACES
// ============================================================================

Table spaces {
  space_id varchar(50) [primary key]
  space_key varchar(50) [not null, unique]
  name varchar(255) [not null]
  description text
  type enum('global','personal') [not null]
  status enum('current','archived') [not null, default: 'current']
  // homepage_id varchar(50) // FK to pages
  created_by varchar(50) [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
  
  indexes {
    space_key [unique]
  }
}

// ============================================================================
// USERS AND AUTHENTICATION
// ============================================================================

Table users {
  user_id varchar(50) [primary key]
  // account_id varchar(100) [not null, unique] // Atlassian account ID
  email varchar(320) [not null, unique]
  display_name varchar(255) [not null]
  // account_type enum('atlassian','app','anonymous') [not null]
  status enum('active','inactive','deactivated') [not null, default: 'active']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
  
  indexes {
    // account_id [unique]
    email [unique]
  }
}


// ============================================================================
// ATTACHMENTS
// ============================================================================

Table attachments {
  attachment_id varchar(50) [primary key]
  content_id varchar(50) [not null]
  content_type enum('page','database','whiteboard','smart_link') [not null]
  host_page_id varchar(50) 
  file_name varchar(500) [not null]
  file_url varchar(2000) [not null]
  // file_size_bytes bigint [not null]
  // media_type varchar(100) [not null] // MIME type
  // download_url varchar(2000) [not null]
  // comment text
  // version_number int [not null, default: 1]
  status enum('current','archived','deleted') [not null, default: 'current']
  uploaded_by varchar(50) [not null]
  uploaded_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
  
  indexes {
    content_id
    (content_id, content_type)
    uploaded_by
  }
}


// ============================================================================
// VERSIONS
// ============================================================================


Table page_versions {
  page_version_id varchar(50) [primary key]
  page_id varchar(50) [not null]
  version_number int [not null]
  title varchar(500) [not null]
  body_storage text
  // is_minor_edit boolean [not null, default: false]
  // created_by varchar(50)  
  created_at timestamp [not null, default: `NOW()`]
}

Table page_version_components {
  component_id varchar(50) [primary key]
  page_version_id varchar(50) [not null]
  component_type enum('whiteboard','smart_link') [not null]
  component_data text [not null] // Complete snapshot of the component
  
  indexes {
    page_version_id
  }
}

Ref: page_version_components.page_version_id > page_versions.page_version_id


// Table whiteboard_versions {
//   whiteboard_version_id varchar(50) [primary key]
//   whiteboard_id varchar(50) [not null]
//   version_number int [not null]
//   title varchar(500) [not null]
//   content text
//   version_message text
//   created_by varchar(50) [not null]
//   created_at timestamp [not null, default: `NOW()`]
  
//   indexes {
//     whiteboard_id
//     (whiteboard_id, version_number) [unique]
//   }
// }



// ============================================================================
// LABELS
// ============================================================================

Table page_labels {
  page_label_id varchar(50) [primary key]
  page_id varchar(50) [not null]
  label_name varchar(255) [not null]  // stored directly
  added_by varchar(50) [not null]
  added_at timestamp [not null, default: `NOW()`]
  
  indexes {
    page_id
    (page_id, label_name) [unique]
  }
}

// Table labels {
//   label_id varchar(50) [primary key]
//   label_name varchar(255) [not null, unique]
//   // prefix varchar(50) // e.g., 'global', 'my', 'team'
//   created_at timestamp [not null, default: `NOW()`]
  
//   indexes {
//     label_name
//   }
// }

// Table page_labels {
//   page_label_id varchar(50) [primary key]
//   page_id varchar(50) [not null]
//   label_id varchar(50) [not null]
//   added_by varchar(50) [not null]
//   added_at timestamp [not null, default: `NOW()`]
  
//   indexes {
//     (page_id, label_id) [unique]
//     label_id
//   }
// }

// Table attachment_labels {
//   attachment_label_id varchar(50) [primary key]
//   attachment_id varchar(50) [not null]
//   label_id varchar(50) [not null]
//   added_by varchar(50) [not null]
//   added_at timestamp [not null, default: `NOW()`]
  
//   indexes {
//     (attachment_id, label_id) [unique]
//     label_id
//   }
// }

// ============================================================================
// LIKES
// ============================================================================

// Table likes {
//   like_id varchar(50) [primary key]
//   page_id varchar(50) [not null]
//   // content_id varchar(50) [not null]
//   // content_type enum('page','database','whiteboard','smart_link') [not null]
//   user_id varchar(50) [not null]
//   // account_id varchar(100) [not null] // Atlassian account ID
//   liked_at timestamp [not null, default: `NOW()`]
  
//   indexes {
//     // (content_id, content_type, user_id) [unique]
//     // content_id
//     user_id
//   }
// }

// ============================================================================
// PERMISSIONS
// ============================================================================

Table permissions {
  permission_id varchar(50) [primary key]
  content_id varchar(50) [not null]
  content_type enum('space','page') [not null]
  user_id varchar(50)
  operation enum('view','edit','delete','create','admin', 'restrict_other_users') [not null]
  granted_by varchar(50)
  granted_at timestamp [not null, default: `NOW()`]
  
  indexes {
    (content_id, content_type)
    user_id
    operation
  }
}


// ============================================================================
// RELATIONSHIPS
// ============================================================================

// Content Pages
Ref: pages.parent_page_id > pages.page_id
Ref: pages.space_id > spaces.space_id
Ref: pages.created_by > users.user_id
Ref: pages.updated_by > users.user_id

// Databases
Ref: databases.host_space_id > spaces.space_id
Ref: databases.host_page_id > pages.page_id
Ref: databases.created_by > users.user_id
Ref: databases.updated_by > users.user_id

// Whiteboards
Ref: whiteboards.host_space_id > spaces.space_id
Ref: whiteboards.host_page_id > pages.page_id
Ref: whiteboards.created_by > users.user_id
Ref: whiteboards.updated_by > users.user_id

// Smart Links
// Ref: smart_links.space_id > spaces.space_id
Ref: smart_links.created_by > users.user_id
Ref: smart_links.updated_by > users.user_id

// Spaces
// Ref: spaces.homepage_id > pages.page_id
Ref: spaces.created_by > users.user_id

// Attachments
Ref: attachments.uploaded_by > users.user_id
// Ref: attachment_bodies.attachment_version_id > attachment_versions.attachment_version_id

// Versions
Ref: page_versions.page_id > pages.page_id
// Ref: page_versions.created_by > users.user_id

// Labels
Ref: page_labels.page_id > pages.page_id
// Ref: page_labels.label_id > labels.label_id
Ref: page_labels.added_by > users.user_id

// Ref: attachment_labels.attachment_id > attachments.attachment_id
// Ref: attachment_labels.label_id > labels.label_id
// Ref: attachment_labels.added_by > users.user_id


// Likes
// Ref: likes.user_id > users.user_id

// Permissions
Ref: permissions.user_id > users.user_id
// Ref: permissions.group_id > groups.group_id
Ref: permissions.granted_by > users.user_id

Ref: smart_links.host_page_id > pages.page_id


You have to provide the json file for each function separately including all the tests for that function in the actions part. You are going to provide the bash script that will create and populate those json files in a folder named tools_regression_tests/interface_1/.

Note: ids are just numeric strings "1", "2", ...
