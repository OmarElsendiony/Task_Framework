Assume you are an experienced tester. I am going to give you python functions and you are going to give me the inputs to test this function. The inputs are provided in the form of actions. You have to provide two tests for each function with the most number of parameters as possible (if applicable). However, you have to follow the format that I provide to you below.

# Format:
{
    "env": "incident_management_redos",
    "interface_num": 1,
    "task": {
        "actions": [
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            },
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            }
        ]
    }
}

where the name of action is the function name and the arguments are the parameters of the function. You have to provide multiple actions for a single file in a single test if applicable. 

# Functions:
import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverAssets(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover asset entities (configuration_items, ci_client_assignments). 
        The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - configuration_items: Configuration Item (CI) records
        - ci_client_assignments: CI Client Assignment records
        """
        if entity_type not in ["configuration_items", "ci_client_assignments"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'configuration_items' or 'ci_client_assignments'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    if entity_type == "configuration_items":
                        id_field = "ci_id"
                    else:  # ci_client_assignments
                        id_field = "assignment_id"
                    results.append({**entity_data, id_field: entity_id})
            else:
                if entity_type == "configuration_items":
                    id_field = "ci_id"
                else:  # ci_client_assignments
                    id_field = "assignment_id"
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_assets",
                "description": "Discover asset entities (configuration items, CI client assignments). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'configuration_items' or 'ci_client_assignments'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "ci_id": {
                                    "type": "string",
                                    "description": "Configuration Item ID"
                                },
                                "ci_name": {
                                    "type": "string",
                                    "description": "Configuration Item name (for configuration_items)"
                                },
                                "ci_type": {
                                    "type": "string",
                                    "description": "CI type: 'server', 'application', 'database', 'network', 'storage', 'service' (for configuration_items)"
                                },
                                "environment": {
                                    "type": "string",
                                    "description": "Environment: 'production', 'staging', 'development', 'testing' (for configuration_items)"
                                },
                                "operational_status": {
                                    "type": "string",
                                    "description": "Operational status: 'operational', 'degraded', 'down' (for configuration_items)"
                                },
                                "responsible_owner": {
                                    "type": "string",
                                    "description": "User ID responsible for the CI (for configuration_items)"
                                },
                                "assignment_id": {
                                    "type": "string",
                                    "description": "Assignment ID (for ci_client_assignments)"
                                },
                                "client_id": {
                                    "type": "string",
                                    "description": "Client ID (for ci_client_assignments)"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                },
                                "updated_at": {
                                    "type": "string",
                                    "description": "Update timestamp in YYYY-MM-DD format (for configuration_items)"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverIncidentTracking(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover incident tracking entities (incidents, problem_tickets, work_notes, attachments, 
        incident_reports, work_orders, incident_configuration_items, problem_configuration_items). 
        The entity to discover is decided by entity_type. Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - incidents: Incident records
        - problem_tickets: Problem Ticket records
        - work_notes: Work Note records
        - attachments: Attachment records
        - incident_reports: Incident Report records
        - work_orders: Work Order records
        - incident_configuration_items: Incident CI links
        - problem_configuration_items: Problem CI links
        """
        valid_types = ["incidents", "problem_tickets", "work_notes", "attachments", 
                      "incident_reports", "work_orders", "incident_configuration_items", 
                      "problem_configuration_items"]
        
        if entity_type not in valid_types:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be one of: {', '.join(valid_types)}"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    id_mapping = {
                        "incidents": "incident_id",
                        "problem_tickets": "problem_id",
                        "work_notes": "note_id",
                        "attachments": "attachment_id",
                        "incident_reports": "report_id",
                        "work_orders": "work_order_id",
                        "incident_configuration_items": "incident_ci_id",
                        "problem_configuration_items": "problem_ci_id"
                    }
                    id_field = id_mapping[entity_type]
                    results.append({**entity_data, id_field: entity_id})
            else:
                id_mapping = {
                    "incidents": "incident_id",
                    "problem_tickets": "problem_id",
                    "work_notes": "note_id",
                    "attachments": "attachment_id",
                    "incident_reports": "report_id",
                    "work_orders": "work_order_id",
                    "incident_configuration_items": "incident_ci_id",
                    "problem_configuration_items": "problem_ci_id"
                }
                id_field = id_mapping[entity_type]
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_incident_tracking",
                "description": "Discover incident tracking entities (incidents, problem tickets, work notes, attachments, incident reports, work orders, incident configuration items, problem configuration items). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'incidents', 'problem_tickets', 'work_notes', 'attachments', 'incident_reports', 'work_orders', 'incident_configuration_items', or 'problem_configuration_items'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "incident_id": {
                                    "type": "string",
                                    "description": "Incident ID"
                                },
                                "problem_id": {
                                    "type": "string",
                                    "description": "Problem ticket ID"
                                },
                                "incident_number": {
                                    "type": "string",
                                    "description": "Incident number, e.g., INC0012345 (for incidents)"
                                },
                                "problem_number": {
                                    "type": "string",
                                    "description": "Problem number, e.g., PRB0001234 (for problem_tickets)"
                                },
                                "title": {
                                    "type": "string",
                                    "description": "Title of the incident, problem, or work order"
                                },
                                "description": {
                                    "type": "string",
                                    "description": "Description text"
                                },
                                "category": {
                                    "type": "string",
                                    "description": "Category: 'inquiry/help', 'software', 'hardware', 'network', 'database' (for incidents and problem_tickets)"
                                },
                                "severity": {
                                    "type": "string",
                                    "description": "Severity level: 'P1', 'P2', 'P3', 'P4' (for incidents)"
                                },
                                "impact": {
                                    "type": "string",
                                    "description": "Impact level: 'critical', 'high', 'medium', 'low' (for incidents)"
                                },
                                "urgency": {
                                    "type": "string",
                                    "description": "Urgency level: 'critical', 'high', 'medium', 'low' (for incidents)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status of the entity"
                                },
                                "reported_by": {
                                    "type": "string",
                                    "description": "User ID who reported the incident or problem"
                                },
                                "assigned_to": {
                                    "type": "string",
                                    "description": "User ID assigned to the incident, problem, or work order"
                                },
                                "detection_time": {
                                    "type": "string",
                                    "description": "Detection timestamp in YYYY-MM-DD format (for incidents)"
                                },
                                "detected_at": {
                                    "type": "string",
                                    "description": "Detection timestamp in YYYY-MM-DD format (for problem_tickets)"
                                },
                                "acknowledged_at": {
                                    "type": "string",
                                    "description": "Acknowledgement timestamp in YYYY-MM-DD format (for incidents)"
                                },
                                "resolved_at": {
                                    "type": "string",
                                    "description": "Resolution timestamp in YYYY-MM-DD format (for incidents and problem_tickets)"
                                },
                                "closed_at": {
                                    "type": "string",
                                    "description": "Closure timestamp in YYYY-MM-DD format (for incidents and problem_tickets)"
                                },
                                "note_id": {
                                    "type": "string",
                                    "description": "Work note ID (for work_notes)"
                                },
                                "note_text": {
                                    "type": "string",
                                    "description": "Work note text content (for work_notes)"
                                },
                                "note_type": {
                                    "type": "string",
                                    "description": "Note type (for work_notes)"
                                },
                                "created_by": {
                                    "type": "string",
                                    "description": "User ID who created the note or entity"
                                },
                                "attachment_id": {
                                    "type": "string",
                                    "description": "Attachment ID (for attachments)"
                                },
                                "reference_id": {
                                    "type": "string",
                                    "description": "Reference ID of the parent record (for attachments)"
                                },
                                "reference_type": {
                                    "type": "string",
                                    "description": "Type of parent record: 'incident', 'change', 'rca', 'report', 'pir', 'communication', 'work_order', 'problem' (for attachments)"
                                },
                                "file_name": {
                                    "type": "string",
                                    "description": "File name (for attachments)"
                                },
                                "file_url": {
                                    "type": "string",
                                    "description": "File URL (for attachments)"
                                },
                                "file_type": {
                                    "type": "string",
                                    "description": "File type (for attachments)"
                                },
                                "file_size_bytes": {
                                    "type": "integer",
                                    "description": "File size in bytes (for attachments)"
                                },
                                "uploaded_by": {
                                    "type": "string",
                                    "description": "User ID who uploaded the file (for attachments)"
                                },
                                "uploaded_at": {
                                    "type": "string",
                                    "description": "Upload timestamp in YYYY-MM-DD format (for attachments)"
                                },
                                "report_id": {
                                    "type": "string",
                                    "description": "Report ID (for incident_reports)"
                                },
                                "report_number": {
                                    "type": "string",
                                    "description": "Report number, e.g., RPT0001234 (for incident_reports)"
                                },
                                "report_title": {
                                    "type": "string",
                                    "description": "Report title (for incident_reports)"
                                },
                                "report_type": {
                                    "type": "string",
                                    "description": "Report type: 'post_incident_review', 'client_impact', 'compliance' (for incident_reports)"
                                },
                                "report_content": {
                                    "type": "string",
                                    "description": "Report content (for incident_reports)"
                                },
                                "generated_by": {
                                    "type": "string",
                                    "description": "User ID who generated the report (for incident_reports)"
                                },
                                "generation_date": {
                                    "type": "string",
                                    "description": "Generation timestamp in YYYY-MM-DD format (for incident_reports)"
                                },
                                "report_status": {
                                    "type": "string",
                                    "description": "Report status: 'draft', 'completed', 'approved', 'archived' (for incident_reports)"
                                },
                                "work_order_id": {
                                    "type": "string",
                                    "description": "Work order ID (for work_orders)"
                                },
                                "work_order_number": {
                                    "type": "string",
                                    "description": "Work order number, e.g., WO0001234 (for work_orders)"
                                },
                                "change_id": {
                                    "type": "string",
                                    "description": "Associated change request ID (for work_orders)"
                                },
                                "scheduled_date": {
                                    "type": "string",
                                    "description": "Scheduled date in YYYY-MM-DD format (for work_orders)"
                                },
                                "completed_at": {
                                    "type": "string",
                                    "description": "Completion timestamp in YYYY-MM-DD format (for work_orders)"
                                },
                                "incident_ci_id": {
                                    "type": "string",
                                    "description": "Incident CI link ID (for incident_configuration_items)"
                                },
                                "problem_ci_id": {
                                    "type": "string",
                                    "description": "Problem CI link ID (for problem_configuration_items)"
                                },
                                "ci_id": {
                                    "type": "string",
                                    "description": "Configuration Item ID (for incident_configuration_items and problem_configuration_items)"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                },
                                "updated_at": {
                                    "type": "string",
                                    "description": "Update timestamp in YYYY-MM-DD format"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from datetime import datetime, timedelta
from tau_bench.envs.tool import Tool

class GetSlaBreachIncidents(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], client_id: str = None, start_date: str = None, end_date: str = None, status: str = None) -> str:
        """
        Retrieves incidents that have breached their Service Level Agreements (SLAs).
        Only incidents with 'resolved_at' or 'closed_at' timestamps are considered for resolution SLA breaches.
        """
        # Define SLA_MATRIX inside the function
        SLA_MATRIX = {
            'premium': {
                'P1': {'response': (15, 30), 'resolution': (120, 240)},
                'P2': {'response': (60, 120), 'resolution': (480, 1440)},
                'P3': {'response': (240, 480), 'resolution': (2880, 4320)},
                'P4': {'response': (1440, 2880), 'resolution': (7680, 7680)}
            },
            'standard': {
                'P1': {'response': (60, 120), 'resolution': (480, 1440)},
                'P2': {'response': (240, 480), 'resolution': (1440, 2880)},
                'P3': {'response': (1440, 1440), 'resolution': (4320, 7200)},
                'P4': {'response': (2880, 4320), 'resolution': (10080, 10080)}
            },
            'basic': {
                'P1': {'response': (240, 480), 'resolution': (1440, 2880)},
                'P2': {'response': (1440, 1440), 'resolution': (4320, 7200)},
                'P3': {'response': (2880, 4320), 'resolution': (7200, 14400)},
                'P4': {'response': (7200, 10080), 'resolution': (20160, 20160)}
            }
        }
        
        incidents_data = data.get("incidents", {})
        sla_agreements_data = data.get("sla_agreements", {})
        incident_ci_data = data.get("incident_configuration_items", {})
        ci_client_assignments_data = data.get("ci_client_assignments", {})
        
        breach_incidents = []
        
        # Detailed debugging - let's see what we're actually working with
        debug_info = {
            "data_structure": {
                "incidents_count": len(incidents_data),
                "sla_agreements_count": len(sla_agreements_data),
                "incident_ci_relationships_count": len(incident_ci_data),
                "ci_client_assignments_count": len(ci_client_assignments_data),
                "available_tables": list(data.keys())
            },
            "sample_data": {},
            "processing_steps": []
        }
        
        # Sample actual data
        if incidents_data:
            sample_incident_id = list(incidents_data.keys())[0]
            debug_info["sample_data"]["incident"] = {
                "id": sample_incident_id,
                "data": incidents_data[sample_incident_id]
            }
        
        if sla_agreements_data:
            sample_sla_id = list(sla_agreements_data.keys())[0]
            debug_info["sample_data"]["sla"] = {
                "id": sample_sla_id,
                "data": sla_agreements_data[sample_sla_id]
            }
        
        if incident_ci_data:
            sample_ici_id = list(incident_ci_data.keys())[0]
            debug_info["sample_data"]["incident_ci"] = {
                "id": sample_ici_id,
                "data": incident_ci_data[sample_ici_id]
            }
        
        if ci_client_assignments_data:
            sample_cca_id = list(ci_client_assignments_data.keys())[0]
            debug_info["sample_data"]["ci_client_assignment"] = {
                "id": sample_cca_id,
                "data": ci_client_assignments_data[sample_cca_id]
            }
        
        # Parse date filters
        filter_start_dt = datetime.strptime(start_date, '%Y-%m-%d') if start_date else None
        filter_end_dt = datetime.strptime(end_date, '%Y-%m-%d') if end_date else None
        
        debug_info["processing_steps"].append(f"Date filters: start={start_date}, end={end_date}")
        
        # Helper function to find client_id for an incident through CI relationships
        def get_incident_client_id(incident_id: str) -> str:
            debug_info["processing_steps"].append(f"Looking for client for incident {incident_id}")
            
            # Find CIs affected by this incident
            affected_ci_ids = []
            for relationship_id, relationship in incident_ci_data.items():
                if relationship.get("incident_id") == incident_id:
                    affected_ci_ids.append(relationship.get("ci_id"))
                    debug_info["processing_steps"].append(f"Found CI {relationship.get('ci_id')} for incident {incident_id}")
            
            debug_info["processing_steps"].append(f"Affected CIs for incident {incident_id}: {affected_ci_ids}")
            
            # Find client assignments for these CIs
            client_assignments = []
            for assignment_id, assignment in ci_client_assignments_data.items():
                if assignment.get("ci_id") in affected_ci_ids:
                    client_assignments.append(assignment)
                    debug_info["processing_steps"].append(f"Found client assignment: CI {assignment.get('ci_id')} -> Client {assignment.get('client_id')} ({assignment.get('assignment_type')})")
            
            # Return primary assignment if available
            for assignment in client_assignments:
                if assignment.get("assignment_type") == "primary":
                    debug_info["processing_steps"].append(f"Returning primary client {assignment.get('client_id')} for incident {incident_id}")
                    return assignment.get("client_id")
            
            # Otherwise return any assignment
            if client_assignments:
                client_id = client_assignments[0].get("client_id")
                debug_info["processing_steps"].append(f"Returning first available client {client_id} for incident {incident_id}")
                return client_id
            
            debug_info["processing_steps"].append(f"No client found for incident {incident_id}")
            return None
        
        incidents_checked = 0
        incidents_with_resolution = 0
        incidents_with_client = 0
        incidents_with_sla = 0
        
        for incident_id, incident in incidents_data.items():
            incidents_checked += 1
            
            # Only consider incidents that have been resolved or closed
            if not incident.get("resolved_at") and not incident.get("closed_at"):
                debug_info["processing_steps"].append(f"Incident {incident_id}: No resolution timestamp")
                continue
            
            incidents_with_resolution += 1
            debug_info["processing_steps"].append(f"Incident {incident_id}: Has resolution timestamp")
            
            # Apply status filter
            if status and incident.get("status") != status:
                debug_info["processing_steps"].append(f"Incident {incident_id}: Status filter mismatch ({incident.get('status')} != {status})")
                continue
            
            # Apply time range filter based on detection_time
            detection_time_str = incident.get("detection_time")
            if not detection_time_str:
                debug_info["processing_steps"].append(f"Incident {incident_id}: No detection_time")
                continue
            
            try:
                # Handle various datetime formats
                if detection_time_str.endswith('Z'):
                    detection_time_str = detection_time_str[:-1] + '+00:00'
                incident_detection_dt = datetime.fromisoformat(detection_time_str)
                
                if filter_start_dt and incident_detection_dt < filter_start_dt:
                    debug_info["processing_steps"].append(f"Incident {incident_id}: Before start date")
                    continue
                if filter_end_dt and incident_detection_dt > filter_end_dt:
                    debug_info["processing_steps"].append(f"Incident {incident_id}: After end date")
                    continue
            except ValueError as e:
                debug_info["processing_steps"].append(f"Incident {incident_id}: Invalid detection_time format: {e}")
                continue
            
            # Get client_id through CI relationships
            incident_client_id = get_incident_client_id(incident_id)
            if not incident_client_id:
                debug_info["processing_steps"].append(f"Incident {incident_id}: No client relationship found")
                continue
            
            incidents_with_client += 1
            
            # Apply client_id filter
            if client_id and incident_client_id != client_id:
                debug_info["processing_steps"].append(f"Incident {incident_id}: Client filter mismatch ({incident_client_id} != {client_id})")
                continue
            
            incident_severity = incident.get("severity")
            if not incident_severity:
                debug_info["processing_steps"].append(f"Incident {incident_id}: No severity")
                continue
            
            # Find the SLA agreement for the incident's client
            client_sla = None
            for sla_id, sla_agreement in sla_agreements_data.items():
                if sla_agreement.get("client_id") == incident_client_id and sla_agreement.get("status") == "active":
                    client_sla = sla_agreement
                    debug_info["processing_steps"].append(f"Incident {incident_id}: Found active SLA {sla_id} for client {incident_client_id}")
                    break
            
            if not client_sla:
                debug_info["processing_steps"].append(f"Incident {incident_id}: No active SLA for client {incident_client_id}")
                continue
            
            incidents_with_sla += 1
            
            client_tier = client_sla.get("tier")
            if not client_tier or client_tier not in SLA_MATRIX:
                debug_info["processing_steps"].append(f"Incident {incident_id}: Invalid tier {client_tier}")
                continue
            
            sla_config = SLA_MATRIX[client_tier].get(incident_severity)
            if not sla_config:
                debug_info["processing_steps"].append(f"Incident {incident_id}: No SLA config for {client_tier}/{incident_severity}")
                continue
            
            # Use the maximum resolution time from the range as the target
            expected_resolution_minutes = sla_config['resolution'][1]
            
            # Calculate actual resolution duration
            resolved_at_str = incident.get("resolved_at") or incident.get("closed_at")
            try:
                if resolved_at_str.endswith('Z'):
                    resolved_at_str = resolved_at_str[:-1] + '+00:00'
                incident_resolved_dt = datetime.fromisoformat(resolved_at_str)
                
                actual_resolution_duration_minutes = (incident_resolved_dt - incident_detection_dt).total_seconds() / 60
                
                debug_info["processing_steps"].append(f"Incident {incident_id}: Duration {actual_resolution_duration_minutes:.2f} min vs SLA {expected_resolution_minutes} min")
                
                # Check for SLA breach
                if actual_resolution_duration_minutes > expected_resolution_minutes:
                    incident_copy = incident.copy()
                    incident_copy["client_id"] = incident_client_id
                    incident_copy["sla_tier"] = client_tier
                    incident_copy["expected_resolution_minutes"] = expected_resolution_minutes
                    incident_copy["actual_resolution_minutes"] = round(actual_resolution_duration_minutes, 2)
                    incident_copy["breach_by_minutes"] = round(actual_resolution_duration_minutes - expected_resolution_minutes, 2)
                    breach_incidents.append(incident_copy)
                    debug_info["processing_steps"].append(f"Incident {incident_id}: BREACH DETECTED!")
                else:
                    debug_info["processing_steps"].append(f"Incident {incident_id}: No breach")
                    
            except ValueError as e:
                debug_info["processing_steps"].append(f"Incident {incident_id}: Invalid resolved_at format: {e}")
                continue
        
        debug_info["summary"] = {
            "incidents_checked": incidents_checked,
            "incidents_with_resolution": incidents_with_resolution,
            "incidents_with_client": incidents_with_client,
            "incidents_with_sla": incidents_with_sla,
            "breaches_found": len(breach_incidents)
        }
        
        return json.dumps({
            "success": True,
            "count": len(breach_incidents),
            "breach_incidents": breach_incidents,
            "debug": debug_info
        }, indent=2)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_sla_breach_incidents",
                "description": "Retrieves incidents that have breached their Service Level Agreements (SLAs). Includes detailed debugging information.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "client_id": {
                            "type": "string",
                            "description": "Optional: Filter incidents by a specific client ID."
                        },
                        "start_date": {
                            "type": "string",
                            "description": "Optional: Start date for the time range (YYYY-MM-DD)."
                        },
                        "end_date": {
                            "type": "string",
                            "description": "Optional: End date for the time range (YYYY-MM-DD)."
                        },
                        "status": {
                            "type": "string",
                            "description": "Optional: Filter incidents by status."
                        }
                    },
                    "required": []
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageContracts(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        entity_data: Optional[Dict[str, Any]] = None,
        entity_id: Optional[str] = None
    ) -> str:
        """
        Create or update SLA agreement records.
        
        Actions:
        - create: Create new SLA agreement record (requires entity_data)
        - update: Update existing SLA agreement record (requires entity_id and entity_data)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        timestamp = "2025-10-01T00:00:00"
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })
        
        sla_agreements = data.get("sla_agreements", {})
        clients = data.get("clients", {})
        users = data.get("users", {})
        
        if action == "create":
            if not entity_data:
                return json.dumps({
                    "success": False,
                    "error": "entity_data is required for create action"
                })
            
            # Validate required fields (based on DB schema)
            required_fields = ["client_id", "tier", "support_coverage", "effective_date", "created_by"]
            missing_fields = [field for field in required_fields if field not in entity_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not entity_data[field] or str(entity_data[field]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
            
            # Validate allowed fields
            allowed_fields = ["client_id", "tier", "support_coverage", "effective_date", "expiration_date", "created_by", "status"]
            invalid_fields = [field for field in entity_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields: {', '.join(invalid_fields)}"
                })
            
            # Validate tier enum
            valid_tiers = ["premium", "standard", "basic"]
            if entity_data["tier"] not in valid_tiers:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid tier '{entity_data['tier']}'. Must be one of: {', '.join(valid_tiers)}"
                })
            
            # Validate support_coverage enum
            valid_support_coverage = ["24x7", "business_hours", "on_call"]
            if entity_data["support_coverage"] not in valid_support_coverage:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid support_coverage '{entity_data['support_coverage']}'. Must be one of: {', '.join(valid_support_coverage)}"
                })
            
            # Validate status enum if provided
            if "status" in entity_data:
                valid_status = ["active", "inactive", "expired"]
                if entity_data["status"] not in valid_status:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status '{entity_data['status']}'. Must be one of: {', '.join(valid_status)}"
                    })
            
            # Validate optional fields are not empty if provided
            optional_fields = ["expiration_date"]
            for field in optional_fields:
                if field in entity_data and entity_data[field] is not None:
                    if str(entity_data[field]).strip() == "":
                        return json.dumps({
                            "success": False,
                            "error": f"Field '{field}' cannot be empty if provided"
                        })
            
            # Validate client_id exists
            if str(entity_data["client_id"]) not in clients:
                return json.dumps({
                    "success": False,
                    "error": "Client not found"
                })
            
            # Validate created_by exists
            if str(entity_data["created_by"]) not in users:
                return json.dumps({
                    "success": False,
                    "error": "User not found"
                })
            
            # Create new SLA agreement
            new_id = str(generate_id(sla_agreements))
            new_sla = {
                "sla_id": new_id,
                "client_id": str(entity_data["client_id"]),
                "tier": entity_data["tier"],
                "support_coverage": entity_data["support_coverage"],
                "effective_date": entity_data["effective_date"],
                "expiration_date": entity_data.get("expiration_date"),
                "created_by": str(entity_data["created_by"]),
                "created_at": timestamp,
                "updated_at": timestamp,
                "status": entity_data.get("status", "active")
            }
            sla_agreements[new_id] = new_sla
            
            return json.dumps({
                "success": True,
                "action": "create",
                "sla_id": new_id,
                "sla_data": new_sla
            })
        
        elif action == "update":
            if not entity_id:
                return json.dumps({
                    "success": False,
                    "error": "entity_id is required for update action"
                })
            
            if entity_id not in sla_agreements:
                return json.dumps({
                    "success": False,
                    "error": f"SLA agreement {entity_id} not found"
                })
            
            # Check if SLA is inactive or expired
            current_sla = sla_agreements[entity_id]
            if current_sla.get("status") in ["inactive", "expired"]:
                return json.dumps({
                    "success": False,
                    "error": f"Cannot update SLA agreement {entity_id} with status '{current_sla.get('status')}'. Please reactivate the SLA first."
                })
            
            if not entity_data:
                return json.dumps({
                    "success": False,
                    "error": "entity_data is required for update action"
                })
            
            # Validate allowed fields
            allowed_fields = ["client_id", "tier", "support_coverage", "effective_date", "expiration_date", "created_by", "status"]
            invalid_fields = [field for field in entity_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields
            for field, value in entity_data.items():
                if field != "expiration_date" and value is not None and str(value).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
                elif field == "expiration_date" and value is not None and str(value).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty if provided"
                    })
            
            # Validate tier enum if provided
            if "tier" in entity_data:
                valid_tiers = ["premium", "standard", "basic"]
                if entity_data["tier"] not in valid_tiers:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid tier. Must be one of: {', '.join(valid_tiers)}"
                    })
            
            # Validate support_coverage enum if provided
            if "support_coverage" in entity_data:
                valid_support_coverage = ["24x7", "business_hours", "on_call"]
                if entity_data["support_coverage"] not in valid_support_coverage:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid support_coverage. Must be one of: {', '.join(valid_support_coverage)}"
                    })
            
            # Validate status enum if provided
            if "status" in entity_data:
                valid_status = ["active", "inactive", "expired"]
                if entity_data["status"] not in valid_status:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status. Must be one of: {', '.join(valid_status)}"
                    })
            
            # Validate client_id if being updated
            if "client_id" in entity_data:
                if str(entity_data["client_id"]) not in clients:
                    return json.dumps({
                        "success": False,
                        "error": "Client not found"
                    })
            
            # Validate created_by if being updated
            if "created_by" in entity_data:
                if str(entity_data["created_by"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "User not found"
                    })
            
            # Update SLA agreement
            updated_sla = sla_agreements[entity_id].copy()
            for key, value in entity_data.items():
                if key in ["client_id", "created_by"]:
                    updated_sla[key] = str(value)
                else:
                    updated_sla[key] = value
            updated_sla["updated_at"] = timestamp
            sla_agreements[entity_id] = updated_sla
            
            return json.dumps({
                "success": True,
                "action": "update",
                "sla_id": entity_id,
                "sla_data": updated_sla
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_contracts",
                "description": "Create or update SLA agreement records in the incident management system. For creation, establishes new SLA agreement records with comprehensive validation. For updates, modifies existing records while maintaining data integrity. Validates SLA tiers, support coverage, and status values according to system requirements.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new record, 'update' to modify existing record"
                        },
                        "entity_data": {
                            "type": "object",
                            "description": "SLA agreement data object containing fields for creating or updating SLA agreements",
                            "properties": {
                                "client_id": {
                                    "type": "string",
                                    "description": "Client identifier (required for create, cannot be empty, must exist in system)"
                                },
                                "tier": {
                                    "type": "string",
                                    "description": "SLA tier level (required for create). Must be one of: premium, standard, basic"
                                },
                                "support_coverage": {
                                    "type": "string",
                                    "description": "Support coverage level (required for create). Must be one of: 24x7, business_hours, on_call"
                                },
                                "effective_date": {
                                    "type": "string",
                                    "description": "Date when SLA becomes effective (required for create, cannot be empty)"
                                },
                                "expiration_date": {
                                    "type": "string",
                                    "description": "Date when SLA expires (optional, cannot be empty if provided)"
                                },
                                "created_by": {
                                    "type": "string",
                                    "description": "User identifier who created the SLA (required for create, cannot be empty, must exist in system)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status of the SLA agreement (optional, defaults to 'active'). Must be one of: active, inactive, expired"
                                }
                            }
                        },
                        "entity_id": {
                            "type": "string",
                            "description": "Unique identifier of the SLA agreement record. Required for update action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageCommunications(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, communication_data: Dict[str, Any] = None, communication_id: str = None) -> str:
        """
        Create or update communication records for incident notifications.

        Actions:
        - create: Create new communication (requires incident_id, communication_type, recipient_type, sender, delivery_method, message_content)
        - update: Update existing communication (requires communication_id and fields to update)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for communications"
            })
        
        # get existing data tables
        communications = data.get("communications", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        # allowed enums
        valid_types = ["status_update", "resolution_notice", "escalation_notice", "bridge_invitation"]
        valid_recipient_types = ["client", "internal", "executive"]
        valid_methods = ["email", "portal", "sms", "phone"]
        valid_statuses = ["pending", "sent", "delivered", "failed"]

        # valid values
        required_user_status = ["active"]

        # for create action
        if action == "create":
            if not communication_data:
                return json.dumps({
                    "success": False,
                    "error": "communication_data is required for create action"
                })
            
            # Validate required fields
            required_fields = ["incident_id", "communication_type", "recipient_type", "message_content", "sender", "delivery_method"]
            
            missing_fields = [field for field in required_fields if field not in communication_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid communication details - missing fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not communication_data[field] or str(communication_data[field]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
            
            # Allowed fields
            allowed_fields = ["incident_id", "communication_type", "recipient_type", "message_content", "sender", "recipient", "delivery_method", "delivery_status", "sent_at"]

            comm_fields = [field for field in communication_data if field not in allowed_fields]
            if comm_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Unrecognized fields in communication_data: {', '.join(comm_fields)}"
                })
            
            # Validate incident exists
            if str(communication_data["incident_id"]) not in incidents:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Incident not found"
                })
            
            # Validate communication_type
            if communication_data["communication_type"] not in valid_types:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid communication type - must be one of: {', '.join(valid_types)}"
                })
            
            # Validate recipient_type
            if communication_data["recipient_type"] not in valid_recipient_types:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid recipient type - must be one of: {', '.join(valid_recipient_types)}"
                })
            
            # Validate sender exists
            if str(communication_data["sender"]) not in users:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Sender user not found"
                })
            
            # Validate that sender user is active
            if users[str(communication_data["sender"])]["status"] not in required_user_status: 
                return json.dumps({ 
                    "success": False, 
                    "error": "Halt: User 'sender' must be active" 
                })
            
            # Validate delivery_method
            if communication_data["delivery_method"] not in valid_methods:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid delivery method - must be one of: {', '.join(valid_methods)}"
                })
            
            # Validate optional fields
            if communication_data.get("recipient"):
                if not str(communication_data["recipient"]).strip():
                    return json.dumps({
                        "success": False,
                        "error": "Field 'recipient' cannot be empty if provided"
                    })
                
                # Validate recipient if provided
                if str(communication_data["recipient"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Recipient user not found"
                    })
                
                # Validate that recipient user is active
                if users[str(communication_data["recipient"])]["status"] not in required_user_status: 
                    return json.dumps({ 
                        "success": False, 
                        "error": "Halt: User 'recipient' must be active" 
                    })
                
            # Validate delivery_status
            delivery_status = communication_data.get("delivery_status", "pending")
            if delivery_status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid delivery status - must be one of: {', '.join(valid_statuses)}"
                })
            
            # Validate sent_at is not empty if provided
            if "sent_at" in communication_data:
                if not str(communication_data["sent_at"]).strip():  
                    return json.dumps({
                        "success": False,
                        "error": "Halt: sent_at cannot be empty"
                    })
            
            # Generate new communication ID
            new_comm_id = generate_id(communications)
            
            # Create new communication record
            new_comm = {
                "communication_id": str(new_comm_id),
                "incident_id": str(communication_data["incident_id"]),
                "communication_type": communication_data["communication_type"],
                "recipient_type": communication_data["recipient_type"],
                "message_content": communication_data["message_content"],
                "sender": str(communication_data["sender"]),
                "recipient": str(communication_data["recipient"]) if communication_data.get("recipient") not in (None, "") else None,
                "delivery_method": communication_data["delivery_method"],
                "delivery_status": delivery_status,
                "sent_at": communication_data.get("sent_at") or None,
                "created_at": "2025-10-07T00:00:00"
            }
            
            communications[str(new_comm_id)] = new_comm
            
            return json.dumps({
                "success": True,
                "action": "create",
                "communication_id": str(new_comm_id),
                "message": f"Communication {new_comm_id} created successfully",
                "communication_data": new_comm
            })
        
        # for update action
        elif action == "update":
            if not communication_id:
                return json.dumps({
                    "success": False,
                    "error": "communication_id is required for update action"
                })

            if str(communication_id) not in communications:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Communication not found"
                })
            
            if not communication_data:
                return json.dumps({
                    "success": False,
                    "error": "communication_data is required for update action"
                })
            
            # Validate at least one optional field is provided
            update_fields = ["communication_type", "recipient_type", "message_content", "sender", "recipient", "delivery_method", "delivery_status", "sent_at"]

            provided_fields = [field for field in update_fields if field in communication_data]
            if not provided_fields:
                return json.dumps({
                    "success": False,
                    "error": f"At least one optional field must be provided for updates {', '.join(update_fields)}"
                })
            
            # Validate only allowed fields for updates
            invalid_fields = [field for field in communication_data.keys() if field not in update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for communication updating: {', '.join(invalid_fields)}"
                })

            # Validate non-empty fields
            for field, value in communication_data.items():
                if field != "recipient" and value is not None and str(value).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate communication type if provided
            if "communication_type" in communication_data and communication_data["communication_type"] not in valid_types:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid communication type - must be one of: {', '.join(valid_types)}"
                })
            
            # Validate recipient type if provided
            if "recipient_type" in communication_data and communication_data["recipient_type"] not in valid_recipient_types:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid recipient type - must be one of: {', '.join(valid_recipient_types)}"
                })
            
            # Validate sender if provided
            if "sender" in communication_data:
                if str(communication_data["sender"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Sender user not found"
                    })
                
                # Validate that sender user is active
                if users[str(communication_data["sender"])]["status"] not in required_user_status: 
                    return json.dumps({ 
                        "success": False, 
                        "error": "Halt: User 'sender' must be active" 
                    })
            
            # Validate recipient if provided
            if "recipient" in communication_data:
                if communication_data["recipient"] is not None and str(communication_data["recipient"]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": "Field 'recipient' cannot be empty if provided"
                    })
                
                if communication_data["recipient"] is not None:
                    if str(communication_data["recipient"]) not in users:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: Recipient user not found"
                        })
                    
                    # Validate that recipient user is active
                    if users[str(communication_data["recipient"])]["status"] not in required_user_status: 
                        return json.dumps({ 
                            "success": False, 
                            "error": "Halt: User 'recipient' must be active" 
                        })
            
            # Validate delivery method if provided
            if "delivery_method" in communication_data and communication_data["delivery_method"] not in valid_methods:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid delivery method - must be one of: {', '.join(valid_methods)}"
                })
            
            # Validate delivery_status if provided
            if "delivery_status" in communication_data and communication_data["delivery_status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid delivery status - must be one of: {', '.join(valid_statuses)}"
                })
            
            # Get current communication record
            current_comm = communications[str(communication_id)]
            # Update communication record with modified information
            updated_comm = current_comm.copy()
            for key, value in communication_data.items():
                if key in ["recipient", "delivery_method", "sent_at"]:
                    updated_comm[key] = str(value) if value not in (None, "") else None
                else:
                    updated_comm[key] = value

            communications[str(communication_id)] = updated_comm
            
            return json.dumps({
                "success": True,
                "action": "update",
                "communication_id": str(communication_id),
                "message": f"Communication {communication_id} updated successfully",
                "communication_data": updated_comm
            })
        
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_communications",
                "description": "Create or update communication records for incident notifications in the incident management system. This tool manages all incident-related communications including status updates, resolution notices, escalation notifications, and bridge invitations. Handles multi-channel delivery (email, portal, SMS, phone) to various recipient types (client, internal, executive). Validates sender/recipient user existence, ensures proper communication types, tracks delivery status, and maintains communication audit trail.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to record new communication or 'update' to modify existing communication"
                        },
                        "communication_data": {
                            "type": "object",
                            "description": "Communication data object containing fields for creating or updating communications",
                            "properties": {
                                "incident_id": {
                                    "type": "string",
                                    "description": "Related incident identifier (required for create, cannot be empty)"
                                },
                                "communication_type": {
                                    "type": "string",
                                    "description": "Type of communication (required for create). Must be one of: status_update, resolution_notice, escalation_notice, bridge_invitation"
                                },
                                "recipient_type": {
                                    "type": "string",
                                    "description": "Type of recipient (required for create). Must be one of: client, internal, executive"
                                },
                                "sender": {
                                    "type": "string",
                                    "description": "User identifier sending the communication (required for create, must be active user)"
                                },
                                "recipient": {
                                    "type": "string",
                                    "description": "Specific user identifier receiving the communication (optional, must be active user if provided)"
                                },
                                "delivery_method": {
                                    "type": "string",
                                    "description": "Method of delivery (required for create). Must be one of: email, portal, sms, phone"
                                },
                                "message_content": {
                                    "type": "string",
                                    "description": "Content of the communication message (required for create, cannot be empty)"
                                },
                                "sent_at": {
                                    "type": "string",
                                    "description": "Timestamp when communication was sent in YYYY-MM-DDTHH:MM:SS format (optional, cannot be empty if provided)"
                                },
                                "delivery_status": {
                                    "type": "string",
                                    "description": "Delivery status (optional, defaults to 'pending'). Must be one of: pending, sent, delivered, failed"
                                }
                            }
                        },
                        "communication_id": {
                            "type": "string",
                            "description": "Unique identifier of the communication. Required for update action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class LogAuditRecords(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        reference_id: str,
        reference_type: str,
        action: str,
        user_id: str,
        field_name: Optional[str] = None,
        old_value: Optional[str] = None,
        new_value: Optional[str] = None
    ) -> str:
        """
        Create audit trail records to track changes made to database records.
        
        Parameters:
        - reference_id: ID of the record that was changed
        - reference_type: Type of record being audited
        - action: Action performed (create, update)
        - user_id: ID of the user who performed the action
        - field_name: Name of the field that was changed (required for update)
        - old_value: Previous value of the field (nullable)
        - new_value: New value of the field (required for update)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        timestamp = "2025-10-01T00:00:00"
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })
        
        audit_trails = data.get("audit_trails", {})
        users = data.get("users", {})
        
        # Validate reference_type based on DBML schema
        valid_reference_types = [
            "user", "client", "sla", "ci", "incident", "escalation", "bridge", 
            "change", "rollback", "work_order", "problem", "incident_ci", 
            "problem_ci", "client_ci"
        ]
        if reference_type not in valid_reference_types:
            return json.dumps({
                "success": False,
                "error": f"Invalid reference_type '{reference_type}'. Must be one of: {', '.join(valid_reference_types)}"
            })
        
        # Validate action enum based on DBML schema
        valid_actions = ["create", "update"]
        if action not in valid_actions:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be one of: {', '.join(valid_actions)}"
            })
        
        # Business rule validation
        if action == "create" and field_name is not None:
            return json.dumps({
                "success": False,
                "error": "field_name should be null for create actions"
            })
        
        if action == "create" and old_value is not None:
            return json.dumps({
                "success": False,
                "error": "old_value should be null for create actions"
            })
        
        if action == "update":
            if field_name is None or str(field_name).strip() == "":
                return json.dumps({
                    "success": False,
                    "error": "field_name is required for update actions"
                })
            if new_value is None or str(new_value).strip() == "":
                return json.dumps({
                    "success": False,
                    "error": "new_value is required for update actions"
                })
        
        # Validate user_id FK
        user_id_str = str(user_id).strip().strip('"')
        if user_id_str not in users:
            return json.dumps({
                "success": False,
                "error": f"User '{user_id_str}' not found"
            })
        if users[user_id_str]["status"] != "active":
            return json.dumps({
                "success": False,
                "error": f"User '{user_id_str}' is not active"
            })
        
        # Validate that the referenced entity exists based on reference_type
        reference_tables = {
            "user": "users",
            "client": "clients",
            "sla": "sla_agreements",
            "ci": "configuration_items",
            "incident": "incidents",
            "escalation": "escalations",
            "bridge": "bridges",
            "change": "change_requests",
            "rollback": "rollback_requests",
            "work_order": "work_orders",
            "problem": "problem_tickets",
            "incident_ci": "incident_configuration_items",
            "problem_ci": "problem_configuration_items",
            "client_ci": "ci_client_assignments"
        }
        
        reference_table = reference_tables.get(reference_type)
        if reference_table and reference_table in data:
            reference_id_str = str(reference_id).strip().strip('"')
            if reference_id_str not in data[reference_table]:
                return json.dumps({
                    "success": False,
                    "error": f"{reference_type.title()} '{reference_id_str}' not found"
                })
        
        audit_trail_id = generate_id(audit_trails)
        
        new_audit_trail = {
            "audit_id": str(audit_trail_id),
            "reference_id": str(reference_id),
            "reference_type": reference_type,
            "action": action,
            "user_id": user_id_str,
            "field_name": field_name if field_name else None,
            "old_value": old_value if old_value else None,
            "new_value": new_value if new_value else None,
            "created_at": timestamp
        }
        
        audit_trails[str(audit_trail_id)] = new_audit_trail
        return json.dumps({
            "success": True,
            "audit_id": str(audit_trail_id),
            "audit_data": new_audit_trail
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "log_audit_records",
                "description": "Create audit trail records to track changes made to database records. Validates user activity, reference types, and enforces business rules for create vs update actions.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "reference_id": {
                            "type": "string",
                            "description": "ID of the record that was changed (required, cannot be empty)"
                        },
                        "reference_type": {
                            "type": "string",
                            "description": "Type of record being audited. Must be one of: user, client, sla, ci, incident, escalation, bridge, change, rollback, work_order, problem, incident_ci, problem_ci, client_ci",
                            "enum": ["user", "client", "sla", "ci", "incident", "escalation", "bridge", "change", "rollback", "work_order", "problem", "incident_ci", "problem_ci", "client_ci"]
                        },
                        "action": {
                            "type": "string",
                            "description": "Action performed. Must be one of: create, update. Note: field_name must be null for create actions, old_value must be null for create actions",
                            "enum": ["create", "update"]
                        },
                        "user_id": {
                            "type": "string",
                            "description": "ID of the user who performed the action (required, must be an active user)"
                        },
                        "field_name": {
                            "type": "string",
                            "description": "Name of the field that was changed (required for update actions, must be null for create actions)"
                        },
                        "old_value": {
                            "type": "string",
                            "description": "Previous value of the field (nullable, must be null for create actions)"
                        },
                        "new_value": {
                            "type": "string",
                            "description": "New value of the field (required for update actions, nullable for create actions)"
                        }
                    },
                    "required": ["reference_id", "reference_type", "action", "user_id"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageUsers(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        user_data: Optional[Dict[str, Any]] = None,
        user_id: Optional[str] = None
    ) -> str:
        """
        Create or update user records.
        
        Actions:
        - create: Create new user record (requires user_data with first_name, last_name, email, role, timezone)
        - update: Update existing user record (requires user_id and user_data with changes)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        timestamp = "2025-10-01T00:00:00"
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })
        
        users = data.get("users", {})
        clients = data.get("clients", {})
        
        if action == "create":
            if not user_data:
                return json.dumps({
                    "success": False,
                    "error": "user_data is required for create action"
                })
            
            # Validate required fields
            required_fields = ["first_name", "last_name", "email", "role", "timezone"]
            missing_fields = [field for field in required_fields if field not in user_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not user_data[field] or str(user_data[field]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
            
            # Validate allowed fields
            allowed_fields = ["first_name", "last_name", "email", "role", "timezone", "status", "client_id"]
            invalid_fields = [field for field in user_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields: {', '.join(invalid_fields)}"
                })
            
            # Validate role enum
            valid_roles = ["incident_manager", "technical_support", "account_manager", "executive", "system_administrator", "client_contact"]
            if user_data["role"] not in valid_roles:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid role '{user_data['role']}'. Must be one of: {', '.join(valid_roles)}"
                })
            
            # Validate status enum if provided (schema only has 'active' and 'inactive')
            if "status" in user_data:
                if user_data["status"] is not None and str(user_data["status"]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": "Field 'status' cannot be empty if provided"
                    })
                valid_status = ["active", "inactive"]
                if user_data["status"] not in valid_status:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status '{user_data['status']}'. Must be one of: {', '.join(valid_status)}"
                    })
            
            # Check email uniqueness
            for user in users.values():
                if user.get("email") == user_data["email"]:
                    return json.dumps({
                        "success": False,
                        "error": "Email already exists"
                    })
            
            # Validate client_id if role is client_contact
            if user_data["role"] == "client_contact":
                if "client_id" not in user_data:
                    return json.dumps({
                        "success": False,
                        "error": "client_id is required for client_contact role"
                    })
                if not user_data["client_id"] or str(user_data["client_id"]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": "Field 'client_id' cannot be empty"
                    })
                if str(user_data["client_id"]) not in clients:
                    return json.dumps({
                        "success": False,
                        "error": "Client not found"
                    })
            
            # Validate optional fields are not empty if provided
            if "client_id" in user_data and user_data["client_id"] is not None:
                if str(user_data["client_id"]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": "Field 'client_id' cannot be empty if provided"
                    })
            
            # Create new user
            new_id = str(generate_id(users))
            new_user = {
                "user_id": new_id,
                "first_name": user_data["first_name"],
                "last_name": user_data["last_name"],
                "email": user_data["email"],
                "role": user_data["role"],
                "timezone": user_data["timezone"],
                "status": user_data.get("status", "active"),
                "client_id": str(user_data["client_id"]) if user_data.get("client_id") not in (None, "") else None,
                "created_at": timestamp,
                "updated_at": timestamp
            }
            users[new_id] = new_user
            
            return json.dumps({
                "success": True,
                "action": "create",
                "user_id": new_id,
                "user_data": new_user
            })
        
        elif action == "update":
            if not user_id:
                return json.dumps({
                    "success": False,
                    "error": "user_id is required for update action"
                })
            
            if str(user_id) not in users:
                return json.dumps({
                    "success": False,
                    "error": f"User {user_id} not found"
                })
            
            if not user_data:
                return json.dumps({
                    "success": False,
                    "error": "user_data is required for update action"
                })
            
            # Validate allowed fields
            allowed_fields = ["first_name", "last_name", "email", "role", "timezone", "status", "client_id"]
            invalid_fields = [field for field in user_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields
            for field, value in user_data.items():
                if field in ["client_id", "status"] and value is not None and str(value).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty if provided"
                    })
                elif field not in ["client_id", "status"] and value is not None and str(value).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
            
            # Validate role enum if provided
            if "role" in user_data:
                valid_roles = ["incident_manager", "technical_support", "account_manager", "executive", "system_administrator", "client_contact"]
                if user_data["role"] not in valid_roles:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid role. Must be one of: {', '.join(valid_roles)}"
                    })
            
            # Validate status enum if provided (schema only has 'active' and 'inactive')
            if "status" in user_data:
                valid_status = ["active", "inactive"]
                if user_data["status"] not in valid_status:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status. Must be one of: {', '.join(valid_status)}"
                    })
            
            # Check email uniqueness if being updated
            if "email" in user_data:
                for uid, user in users.items():
                    if uid != str(user_id) and user.get("email") == user_data["email"]:
                        return json.dumps({
                            "success": False,
                            "error": "New email already exists"
                        })
            
            # Get current user to check role
            current_user = users[str(user_id)]
            current_role = user_data.get("role", current_user.get("role"))
            
            # Validate client_id if role is client_contact
            if current_role == "client_contact" and "client_id" in user_data:
                if user_data["client_id"] and str(user_data["client_id"]) not in clients:
                    return json.dumps({
                        "success": False,
                        "error": "Client not found"
                    })
            
            # Update user
            updated_user = users[str(user_id)].copy()
            for key, value in user_data.items():
                if key == "client_id" and value:
                    updated_user[key] = str(value)
                elif key == "client_id" and value in (None, ""):
                    updated_user[key] = None
                else:
                    updated_user[key] = value
            updated_user["updated_at"] = timestamp
            users[str(user_id)] = updated_user
            
            return json.dumps({
                "success": True,
                "action": "update",
                "user_id": str(user_id),
                "user_data": updated_user
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_users",
                "description": "Create or update user records in the incident management system. Manages user lifecycle including role-based access control, client associations, and status management. Validates user roles, email uniqueness, and enforces role-specific requirements for client contacts.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new user record, 'update' to modify existing user record"
                        },
                        "user_data": {
                            "type": "object",
                            "description": "User data object containing fields for creating or updating users",
                            "properties": {
                                "first_name": {
                                    "type": "string",
                                    "description": "User's first name (required for create, cannot be empty)"
                                },
                                "last_name": {
                                    "type": "string",
                                    "description": "User's last name (required for create, cannot be empty)"
                                },
                                "email": {
                                    "type": "string",
                                    "description": "User's email address (required for create, cannot be empty, must be unique across all users)"
                                },
                                "role": {
                                    "type": "string",
                                    "description": "User's role in the system (required for create). Must be one of: incident_manager, technical_support, account_manager, executive, system_administrator, client_contact"
                                },
                                "timezone": {
                                    "type": "string",
                                    "description": "User's timezone (required for create, cannot be empty)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "User's status (optional, defaults to 'active'). Must be one of: active, inactive"
                                },
                                "client_id": {
                                    "type": "string",
                                    "description": "Associated client identifier (required for client_contact role, optional for others, must exist if provided)"
                                }
                            }
                        },
                        "user_id": {
                            "type": "string",
                            "description": "Unique identifier of the user record. Required for update action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class AssessIncidentSeverity(Tool):
    """
    Assesses incident severity based on impact, scope, and business criticality.
    Determines severity level (P1-P4) through systematic evaluation criteria.
    """
    
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        complete_outage: Optional[bool] = None,
        no_workaround: Optional[bool] = None,
        enterprise_impact: Optional[bool] = None,
        affected_parties_count: Optional[int] = None,
        regulatory_implications: Optional[bool] = None,
        high_priority_customer: Optional[bool] = None,
        recurrent_incident: Optional[bool] = None,
        major_degradation: Optional[bool] = None,
        workaround_available: Optional[bool] = None,
        multiple_departments: Optional[bool] = None,
        sla_breach_risk: Optional[bool] = None,
        single_department: Optional[bool] = None,
        moderate_degradation: Optional[bool] = None,
        minimal_workaround: Optional[bool] = None
    ) -> str:
        """
        Evaluates incident severity based on structured criteria and returns P1-P4 classification.
        
        Severity Levels:
        - P1: Critical - Complete outage, enterprise-wide impact, or regulatory implications
        - P2: High - Major degradation, multi-department impact, or SLA breach risk
        - P3: Medium - Single department impact or moderate degradation with workaround
        - P4: Low - Minor impact, localized issue
        """
        
        severity = None
        justification = []
        evaluation_path = []
        
        # P1 Evaluation
        evaluation_path.append("Starting P1 evaluation")
        
        # P1 Criterion 1: Complete outage of business-critical service
        if complete_outage is True and no_workaround is True:
            severity = "P1"
            justification.append("Complete outage of business-critical service with no workaround available")
            evaluation_path.append("P1 Criterion 1: Met - Complete outage without workaround")
        elif complete_outage is not None or no_workaround is not None:
            evaluation_path.append("P1 Criterion 1: Not met - Continuing evaluation")
        
        # P1 Criterion 2: Enterprise or multiple customer impact
        if severity is None and (enterprise_impact is True or (affected_parties_count is not None and affected_parties_count >= 5)):
            severity = "P1"
            if enterprise_impact:
                justification.append("Impacts entire enterprise or multiple customers")
            if affected_parties_count and affected_parties_count >= 5:
                justification.append(f"Affects {affected_parties_count} parties (threshold: 5+)")
            evaluation_path.append("P1 Criterion 2: Met - Enterprise-wide or multi-customer impact")
        elif enterprise_impact is not None or affected_parties_count is not None:
            evaluation_path.append("P1 Criterion 2: Not met - Continuing evaluation")
        
        # P1 Criterion 3: Regulatory, safety, or financial implications
        if severity is None and regulatory_implications is True:
            severity = "P1"
            justification.append("Significant regulatory, safety, or financial implications")
            evaluation_path.append("P1 Criterion 3: Met - Regulatory/safety/financial implications")
        elif regulatory_implications is not None:
            evaluation_path.append("P1 Criterion 3: Not met - Continuing evaluation")
        
        # P1 Criterion 4: High-priority customer or recurrent incident
        if severity is None and (high_priority_customer is True or recurrent_incident is True):
            severity = "P1"
            if high_priority_customer:
                justification.append("Involves high-priority customer with contractual P1 requirements")
            if recurrent_incident:
                justification.append("Recurrent incident with escalated priority")
            evaluation_path.append("P1 Criterion 4: Met - High-priority customer or recurrent incident")
        elif high_priority_customer is not None or recurrent_incident is not None:
            evaluation_path.append("P1 Criterion 4: Not met - Proceeding to P2 evaluation")
        
        # P2 Evaluation
        if severity is None:
            evaluation_path.append("Starting P2 evaluation")
            
            # P2 Criterion 1: Major degradation with workaround
            if major_degradation is True and workaround_available is True:
                severity = "P2"
                justification.append("Major degradation of business-critical services with workaround available")
                evaluation_path.append("P2 Criterion 1: Met - Major degradation with workaround")
            elif major_degradation is not None or workaround_available is not None:
                evaluation_path.append("P2 Criterion 1: Not met - Continuing evaluation")
            
            # P2 Criterion 2: Multiple departments or critical functions
            if severity is None and multiple_departments is True:
                severity = "P2"
                justification.append("Impacts multiple departments, sites, or critical business functions")
                evaluation_path.append("P2 Criterion 2: Met - Multi-department impact")
            elif multiple_departments is not None:
                evaluation_path.append("P2 Criterion 2: Not met - Continuing evaluation")
            
            # P2 Criterion 3: SLA breach risk
            if severity is None and sla_breach_risk is True:
                severity = "P2"
                justification.append("Risks breaching high-priority SLA with significant impact")
                evaluation_path.append("P2 Criterion 3: Met - SLA breach risk")
            elif sla_breach_risk is not None:
                evaluation_path.append("P2 Criterion 3: Not met - Proceeding to P3 evaluation")
        
        # P3 Evaluation
        if severity is None:
            evaluation_path.append("Starting P3 evaluation")
            
            # P3 Criterion 1: Single department or localized impact
            if single_department is True:
                severity = "P3"
                justification.append("Impacts single department, localized users, or non-critical function")
                evaluation_path.append("P3 Criterion 1: Met - Single department impact")
            elif single_department is not None:
                evaluation_path.append("P3 Criterion 1: Not met - Continuing evaluation")
            
            # P3 Criterion 2: Moderate degradation with minimal workaround
            if severity is None and moderate_degradation is True and minimal_workaround is True:
                severity = "P3"
                justification.append("Moderate degradation with operations continuing using minimal workaround")
                evaluation_path.append("P3 Criterion 2: Met - Moderate degradation with minimal workaround")
            elif moderate_degradation is not None or minimal_workaround is not None:
                evaluation_path.append("P3 Criterion 2: Not met - Defaulting to P4")
        
        # P4 Default
        if severity is None:
            severity = "P4"
            justification.append("Low impact incident not meeting higher severity criteria")
            evaluation_path.append("Defaulting to P4 - Minor/localized issue")
        
        result = {
            "severity": severity,
            # "justification": justification,
            # "evaluation_path": evaluation_path,
            # "timestamp": "2025-10-01T12:00:00"
        }
        
        return json.dumps(result)
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        """
        Returns the schema for the AssessIncidentSeverity tool.
        """
        return {
            "type": "function",
            "function": {
                "name": "assess_incident_severity",
                "description": "Assesses and determines incident severity level (P1-P4) through systematic evaluation of impact, scope, and business criticality. Evaluates incidents against structured criteria: P1 for critical outages, enterprise-wide impact, or regulatory implications; P2 for major degradation or multi-department impact; P3 for single department or moderate degradation; P4 for minor issues. Returns severity classification with justification and evaluation path.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "complete_outage": {
                            "type": "boolean",
                            "description": "Whether incident causes complete outage of business-critical service (P1 criterion)"
                        },
                        "no_workaround": {
                            "type": "boolean",
                            "description": "Whether no workaround is available for the outage (P1 criterion, evaluated with complete_outage)"
                        },
                        "enterprise_impact": {
                            "type": "boolean",
                            "description": "Whether incident impacts entire enterprise or multiple customers (P1 criterion)"
                        },
                        "affected_parties_count": {
                            "type": "integer",
                            "description": "Number of affected parties/customers (P1 if 5 or more)"
                        },
                        "regulatory_implications": {
                            "type": "boolean",
                            "description": "Whether incident has significant regulatory, safety, or financial implications (P1 criterion)"
                        },
                        "high_priority_customer": {
                            "type": "boolean",
                            "description": "Whether incident involves high-priority customer with contractual P1 requirements (P1 criterion)"
                        },
                        "recurrent_incident": {
                            "type": "boolean",
                            "description": "Whether this is a recurrent incident requiring escalated priority (P1 criterion)"
                        },
                        "major_degradation": {
                            "type": "boolean",
                            "description": "Whether incident causes major degradation of business-critical services (P2 criterion)"
                        },
                        "workaround_available": {
                            "type": "boolean",
                            "description": "Whether a workaround is available for major degradation (P2 criterion, evaluated with major_degradation)"
                        },
                        "multiple_departments": {
                            "type": "boolean",
                            "description": "Whether incident impacts multiple departments, sites, or critical business functions (P2 criterion)"
                        },
                        "sla_breach_risk": {
                            "type": "boolean",
                            "description": "Whether incident risks breaching high-priority SLA with significant impact (P2 criterion)"
                        },
                        "single_department": {
                            "type": "boolean",
                            "description": "Whether incident impacts single department, localized users, or non-critical function (P3 criterion)"
                        },
                        "moderate_degradation": {
                            "type": "boolean",
                            "description": "Whether incident causes moderate degradation (P3 criterion)"
                        },
                        "minimal_workaround": {
                            "type": "boolean",
                            "description": "Whether operations continue using minimal workaround (P3 criterion, evaluated with moderate_degradation)"
                        }
                    },
                    "required": [
                        "complete_outage",
                        "no_workaround",
                        "enterprise_impact",
                        "affected_parties_count",
                        "regulatory_implications",
                        "high_priority_customer",
                        "recurrent_incident",
                        "major_degradation",
                        "workaround_available",
                        "multiple_departments",
                        "sla_breach_risk",
                        "single_department",
                        "moderate_degradation",
                        "minimal_workaround"
                    ]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverWorkflows(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover workflow entities (communications, approval_requests). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - communications: Communication records
        - approval_requests: Approval Request records
        """
        if entity_type not in ["communications", "approval_requests"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'communications' or 'approval_requests'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    if entity_type == "communications":
                        id_field = "communication_id"
                    else:  # approval_requests
                        id_field = "approval_id"
                    results.append({**entity_data, id_field: entity_id})
            else:
                if entity_type == "communications":
                    id_field = "communication_id"
                else:  # approval_requests
                    id_field = "approval_id"
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_workflows",
                "description": "Discover workflow entities (communications, approval requests). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'communications' or 'approval_requests'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "communication_id": {
                                    "type": "string",
                                    "description": "Communication ID (for communications)"
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "Associated incident ID"
                                },
                                "communication_type": {
                                    "type": "string",
                                    "description": "Type of communication: 'status_update', 'resolution_notice', 'escalation_notice', 'bridge_invitation' (for communications)"
                                },
                                "recipient_type": {
                                    "type": "string",
                                    "description": "Type of recipient: 'client', 'internal', 'executive' (for communications)"
                                },
                                "sender": {
                                    "type": "string",
                                    "description": "User ID of sender (for communications)"
                                },
                                "recipient": {
                                    "type": "string",
                                    "description": "User ID of recipient (for communications)"
                                },
                                "delivery_method": {
                                    "type": "string",
                                    "description": "Delivery method: 'email', 'portal', 'sms', 'phone' (for communications)"
                                },
                                "message_content": {
                                    "type": "string",
                                    "description": "Message content (for communications)"
                                },
                                "delivery_status": {
                                    "type": "string",
                                    "description": "Delivery status: 'pending', 'sent', 'delivered', 'failed' (for communications)"
                                },
                                "sent_at": {
                                    "type": "string",
                                    "description": "Sent timestamp in YYYY-MM-DD format (for communications)"
                                },
                                "approval_id": {
                                    "type": "string",
                                    "description": "Approval request ID (for approval_requests)"
                                },
                                "reference_id": {
                                    "type": "string",
                                    "description": "ID of the record requiring approval (for approval_requests)"
                                },
                                "reference_type": {
                                    "type": "string",
                                    "description": "Type of record requiring approval: 'escalation', 'bridge', 'change', 'rollback', 'rca', 'incident_closure' (for approval_requests)"
                                },
                                "requested_by": {
                                    "type": "string",
                                    "description": "User ID who requested approval (for approval_requests)"
                                },
                                "requested_action": {
                                    "type": "string",
                                    "description": "Action being requested: 'create_escalation', 'initiate_bridge', 'create_change_request', 'create_rollback_request', 'conduct_rca', 'close_incident' (for approval_requests)"
                                },
                                "approver": {
                                    "type": "string",
                                    "description": "User ID of approver (for approval_requests)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Approval status: 'pending', 'approved', 'denied' (for approval_requests)"
                                },
                                "requested_at": {
                                    "type": "string",
                                    "description": "Request timestamp in YYYY-MM-DD format (for approval_requests)"
                                },
                                "responded_at": {
                                    "type": "string",
                                    "description": "Response timestamp in YYYY-MM-DD format (for approval_requests)"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageWorkNotes(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        note_data: Optional[Dict[str, Any]] = None,
        note_id: Optional[str] = None
    ) -> str:
        """
        Create or update work note records.

        Actions:
        - create: Create a new work note record (requires note_data)
        - update: Update an existing work note record (requires note_id and note_data)
        """

        def generate_id(table: Dict[str, Any], prefix: str) -> str:
            if not table:
                return f"{prefix}1"
            max_id = 0
            for k in table.keys():
                try:
                    num = int(k[len(prefix):])
                    if num > max_id:
                        max_id = num
                except ValueError:
                    continue
            return f"{prefix}{max_id + 1}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        work_notes = data.get("work_notes", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        # Define valid enums based on DBML schema
        valid_note_types = ["progress_update", "troubleshooting", "resolution"]

        if action == "create":
            if not note_data:
                return json.dumps({
                    "success": False,
                    "error": "note_data is required for create action"
                })

            # Validate required fields as per DBML schema
            required_fields = [
                "incident_id", "note_text", "note_type", "created_by"
            ]
            missing_fields = [field for field in required_fields if field not in note_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not note_data[field] or (isinstance(note_data[field], str) and str(note_data[field]).strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate note_type enum
            if note_data["note_type"] not in valid_note_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid note_type '{note_data['note_type']}'. Must be one of: {', '.join(valid_note_types)}"
                })

            # Validate incident_id FK
            incident_id = str(note_data["incident_id"]).strip().strip('"')
            if incident_id not in incidents:
                return json.dumps({
                    "success": False,
                    "error": f"Incident '{incident_id}' not found"
                })

            # Validate created_by FK
            created_by = str(note_data["created_by"]).strip().strip('"')
            if created_by not in users:
                return json.dumps({
                    "success": False,
                    "error": f"User '{created_by}' not found"
                })
            if users[created_by]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"User '{created_by}' is not active"
                })

            new_id = generate_id(work_notes, "")
            new_note = {
                "note_id": new_id,
                "incident_id": incident_id,
                "note_text": note_data["note_text"],
                "note_type": note_data["note_type"],
                "created_by": created_by,
                "created_at": timestamp
            }
            work_notes[new_id] = new_note
            return json.dumps({
                "success": True,
                "action": "create",
                "note_id": new_id,
                "note_data": new_note
            })

        elif action == "update":
            if not note_id:
                return json.dumps({
                    "success": False,
                    "error": "note_id is required for update action"
                })
            note_id = str(note_id).strip().strip('"')
            if note_id not in work_notes:
                return json.dumps({
                    "success": False,
                    "error": f"Work note '{note_id}' not found"
                })

            if not note_data:
                return json.dumps({
                    "success": False,
                    "error": "note_data is required for update action"
                })

            # Allowed fields for update (note_text and note_type can be updated)
            allowed_fields = ["note_text", "note_type"]
            invalid_fields = [field for field in note_data if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for update: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields
            for field, value in note_data.items():
                if value is None or (isinstance(value, str) and str(value).strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate note_type enum if provided
            if "note_type" in note_data and note_data["note_type"] not in valid_note_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid note_type '{note_data['note_type']}'. Must be one of: {', '.join(valid_note_types)}"
                })

            updated_note = work_notes[note_id].copy()
            for key, value in note_data.items():
                updated_note[key] = value
            
            work_notes[note_id] = updated_note
            return json.dumps({
                "success": True,
                "action": "update",
                "note_id": note_id,
                "note_data": updated_note
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_work_notes",
                "description": "Create or update work note records in the system. Work notes document incident progress, troubleshooting steps, and resolutions.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to add a new work note, 'update' to modify an existing work note."
                        },
                        "note_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating or updating a work note.",
                            "properties": {
                                "incident_id": {
                                    "type": "string",
                                    "description": "The ID of the incident this note is associated with (required for create, cannot be empty). Must refer to an existing incident."
                                },
                                "note_text": {
                                    "type": "string",
                                    "description": "The content of the work note (required for create, cannot be empty). Updatable."
                                },
                                "note_type": {
                                    "type": "string",
                                    "description": "The type/category of the work note (required for create). Must be one of: progress_update, troubleshooting, resolution. Updatable.",
                                    "enum": ["progress_update", "troubleshooting", "resolution"]
                                },
                                "created_by": {
                                    "type": "string",
                                    "description": "The user ID of the person who created the note (required for create). Must refer to an existing active user."
                                }
                            }
                        },
                        "note_id": {
                            "type": "string",
                            "description": "The unique identifier of the work note to update. Required for 'update' action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool


class CheckAuthorization(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, requester_email: str) -> str:
        """
        Check authorization for Incident Management actions.
        Uses two-tier logic with fallback:
        1. If requester has an authorized role  authorized
        2. If requester lacks an authorized role but has an 'approved' approval record from someone with an authorized role  authorized
        3. Otherwise  not authorized
        
        Args:
            data: Environment data containing users and approvals
            action: The incident management action being performed
            requester_email: Email of the user requesting the action
            
        Returns:
            JSON string with authorization result
        """
        # Single source of truth for all actions and their authorized roles
        ACTIONS = {
            "create_client": ["system_administrator", "incident_manager", "account_manager"],
            "update_client": ["system_administrator", "incident_manager", "account_manager"],
            "create_user": ["system_administrator", "incident_manager"],
            "update_user": ["system_administrator", "incident_manager"],
            "deactivate_user": ["system_administrator", "incident_manager"],
            "create_vendor": ["system_administrator", "incident_manager", "executive"],
            "update_vendor": ["system_administrator", "incident_manager", "executive"],
            "create_product": ["system_administrator", "incident_manager", "executive"],
            "update_product": ["system_administrator", "incident_manager", "executive"],
            "create_component": ["system_administrator", "technical_support", "incident_manager"],
            "update_component": ["system_administrator", "technical_support", "incident_manager"],
            "create_subscription": ["account_manager", "incident_manager", "executive"],
            "update_subscription": ["account_manager", "incident_manager", "executive"],
            "create_sla": ["account_manager", "system_administrator", "executive"],
            "update_sla": ["account_manager", "system_administrator", "executive"],
            "create_incident": ["incident_manager", "technical_support", "system_administrator", "executive"],
            "update_incident": ["incident_manager", "technical_support", "system_administrator", "executive"],
            "resolve_incident": ["incident_manager", "technical_support", "executive"],
            "close_incident": ["incident_manager", "technical_support"],
            "create_communication": ["incident_manager", "technical_support", "system_administrator", "account_manager"],
            "update_communication": ["incident_manager", "technical_support", "system_administrator", "account_manager"],
            "create_workaround": ["technical_support", "incident_manager", "system_administrator", "executive"],
            "update_workaround": ["technical_support", "incident_manager", "system_administrator", "executive"],
            "conduct_rca": ["technical_support", "incident_manager"],
            "update_rca": ["technical_support", "incident_manager", "system_administrator", "executive"],
            "create_escalation": ["incident_manager", "technical_support", "system_administrator", "executive", "account_manager"],
            "update_escalation": ["incident_manager", "technical_support", "system_administrator", "executive"],
            "create_change_request": ["technical_support", "incident_manager", "system_administrator", "executive"],
            "update_change_request": ["technical_support", "incident_manager", "system_administrator", "executive"],
            "create_rollback_request": ["technical_support", "system_administrator", "incident_manager"],
            "update_rollback_request": ["incident_manager", "system_administrator", "executive"],
            "record_metrics": ["incident_manager", "system_administrator"],
            "update_metrics": ["incident_manager", "system_administrator"],
            "generate_report": ["incident_manager", "executive"],
            "update_report": ["incident_manager", "executive"],
            "create_kb_article": ["technical_support", "incident_manager"],
            "update_kb_article": ["technical_support", "incident_manager"],
            "create_pir": ["incident_manager", "executive"],
            "update_pir": ["incident_manager", "executive"],
            "initiate_bridge": ["incident_manager", "technical_support", "executive"],
            "close_bridge": ["incident_manager", "technical_support"],
            "request_approval": ["technical_support", "system_administrator", "incident_manager"],
            "approve_request": ["incident_manager", "executive"],
            "update_communication_status": ["incident_manager", "technical_support", "system_administrator"],
            "create_work_note": ["incident_manager", "technical_support", "system_administrator"],
            "update_work_note": ["incident_manager", "technical_support", "system_administrator"],
            "create_attachment": ["incident_manager", "technical_support", "system_administrator", "client_contact"],
            "update_escalation_status": ["incident_manager", "executive", "technical_support"],
            "update_approval_request": ["incident_manager", "system_administrator"]
        }
        
        # Actions that may require approval under certain conditions
        APPROVAL_REQUIRED_ACTIONS = [
            "create_escalation",
            "initiate_bridge",
            "create_rollback_request",
            "create_change_request",
            "close_incident",
            "conduct_rca"
        ]
        
        # Find the requester's role and user_id
        users = data.get("users", {})
        requester_role = None
        requester_user_id = None
        for user_id, user in users.items():
            if user.get("email") == requester_email:
                requester_role = user.get("role")
                requester_user_id = user_id
                break
        
        if not requester_role:
            return json.dumps({
                "authorized": False,
                "error": f"No user found with email: {requester_email}"
            })
        
        # Check if the action is defined
        if action not in ACTIONS:
            return json.dumps({
                "authorized": False,
                "error": f"Unknown action: {action}"
            })
        
        authorized_roles = ACTIONS[action]
        
        # TIER 1: Check if requester has direct authorization
        if requester_role in authorized_roles:
            return json.dumps({
                "authorized": True,
                "message": f"User with role '{requester_role}' is directly authorized to perform action '{action}'"
            })
        
        # TIER 2: Requester not directly authorized, check for an explicit approval
        # This only applies to actions that support the approval workflow
        if action in APPROVAL_REQUIRED_ACTIONS:
            approvals = data.get("approvals", {})
            
            for approval in approvals.values():
                # Check for a matching, approved record for the specific requester and action
                approval_requested_by = approval.get("requested_by")
                
                # Match by user_id
                if str(approval_requested_by) != str(requester_user_id):
                    continue
                    
                # Check if this approval is for the action being requested
                # Map action names to approval request patterns
                approval_action_match = False
                requested_action = approval.get("requested_action", "")
                
                if action == "create_escalation" and "Escalation approval" in requested_action:
                    approval_action_match = True
                elif action == "initiate_bridge" and "Bridge initiation approval" in requested_action:
                    approval_action_match = True
                elif action == "create_rollback_request" and "Rollback approval" in requested_action:
                    approval_action_match = True
                elif action == "create_change_request" and "change approval" in requested_action.lower():
                    approval_action_match = True
                elif action == "close_incident" and "Incident Closure approval" in requested_action:
                    approval_action_match = True
                elif action == "conduct_rca" and "Rca approval" in requested_action:
                    approval_action_match = True
                
                if approval_action_match and approval.get("status") == "approved":
                    # Get the approver's role
                    approver_user_id = approval.get("approver")
                    approver_role = None
                    
                    for user_id, user in users.items():
                        if str(user_id) == str(approver_user_id):
                            approver_role = user.get("role")
                            break
                    
                    # Check if the approver has an authorized role
                    if approver_role and approver_role in authorized_roles:
                        return json.dumps({
                            "authorized": True,
                            "message": f"User '{requester_email}' has a valid approval from user with role '{approver_role}' for action '{action}'"
                        })
        
        # No direct authorization or valid approval found
        return json.dumps({
            "authorized": False,
            "error": f"Role '{requester_role}' is not authorized for action '{action}', and no valid approval was found. Authorized roles: {', '.join(authorized_roles)}."
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        """Return the function schema for tool registration."""
        return {
            "type": "function",
            "function": {
                "name": "check_authorization",
                "description": "Validates authorization for Incident Management actions. First checks if the requester's role is directly authorized. If not, checks for an approved approval record from a user who has an authorized role.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "The incident management action being performed. Valid actions: create_client, update_client, create_user, update_user, deactivate_user, create_vendor, update_vendor, create_product, update_product, create_component, update_component, create_subscription, update_subscription, create_sla, update_sla, create_incident, update_incident, resolve_incident, close_incident, create_communication, update_communication, create_workaround, update_workaround, conduct_rca, update_rca, create_escalation, update_escalation, create_change_request, update_change_request, create_rollback_request, update_rollback_request, record_metrics, update_metrics, generate_report, update_report, create_kb_article, update_kb_article, create_pir, update_pir, initiate_bridge, close_bridge, request_approval, approve_request, update_communication_status, create_work_note, update_work_note, create_attachment, update_escalation_status, update_approval_request"
                        },
                        "requester_email": {
                            "type": "string",
                            "description": "Email of the user requesting the action"
                        }
                    },
                    "required": ["action", "requester_email"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageProblemTickets(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        problem_data: Optional[Dict[str, Any]] = None,
        problem_id: Optional[str] = None
    ) -> str:
        """
        Create or update problem ticket records.

        Actions:
        - create: Create a new problem ticket record (requires problem_data)
        - update: Update an existing problem ticket record (requires problem_id and problem_data)
        """

        def generate_id(table: Dict[str, Any], prefix: str) -> str:
            if not table:
                return f"{prefix}1"
            max_id = 0
            for k in table.keys():
                try:
                    num = int(k[len(prefix):])
                    if num > max_id:
                        max_id = num
                except ValueError:
                    continue
            return f"{prefix}{max_id + 1}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        problem_tickets = data.get("problem_tickets", {})
        users = data.get("users", {})

        # Define valid enums based on DBML schema
        valid_categories = ["software", "hardware", "network", "database", "security"]
        valid_statuses = ["open", "investigating", "resolved", "closed"]

        if action == "create":
            if not problem_data:
                return json.dumps({
                    "success": False,
                    "error": "problem_data is required for create action"
                })

            # Validate required fields as per DBML schema
            required_fields = [
                "problem_number", "title", "description", "category",
                "reported_by", "assigned_to", "detected_at"
            ]
            missing_fields = [field for field in required_fields if field not in problem_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not problem_data[field] or (isinstance(problem_data[field], str) and str(problem_data[field]).strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate problem_number uniqueness
            problem_number = str(problem_data["problem_number"]).strip()
            for problem in problem_tickets.values():
                if problem["problem_number"].lower() == problem_number.lower():
                    return json.dumps({
                        "success": False,
                        "error": f"Problem with number '{problem_number}' already exists."
                    })

            # Validate enums
            if problem_data["category"] not in valid_categories:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid category '{problem_data['category']}'. Must be one of: {', '.join(valid_categories)}"
                })
            
            # Status is 'open' by default, if provided, must be valid
            status = problem_data.get("status", "open")
            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{status}'. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate reported_by FK
            reported_by = str(problem_data["reported_by"]).strip().strip('"')
            if reported_by not in users:
                return json.dumps({
                    "success": False,
                    "error": f"Reported by user '{reported_by}' not found"
                })
            if users[reported_by]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"Reported by user '{reported_by}' is not active"
                })

            # Validate assigned_to FK
            assigned_to = str(problem_data["assigned_to"]).strip().strip('"')
            if assigned_to not in users:
                return json.dumps({
                    "success": False,
                    "error": f"Assigned to user '{assigned_to}' not found"
                })
            if users[assigned_to]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"Assigned to user '{assigned_to}' is not active"
                })

            new_id = generate_id(problem_tickets, "PRB")
            new_problem = {
                "problem_id": new_id,
                "problem_number": problem_number,
                "title": problem_data["title"],
                "description": problem_data["description"],
                "category": problem_data["category"],
                "status": status,
                "reported_by": reported_by,
                "assigned_to": assigned_to,
                "detected_at": problem_data["detected_at"],
                "resolved_at": problem_data.get("resolved_at"),  # Nullable
                "closed_at": problem_data.get("closed_at"),  # Nullable
                "created_at": timestamp,
                "updated_at": timestamp
            }
            problem_tickets[new_id] = new_problem
            return json.dumps({
                "success": True,
                "action": "create",
                "problem_id": new_id,
                "problem_data": new_problem
            })

        elif action == "update":
            if not problem_id:
                return json.dumps({
                    "success": False,
                    "error": "problem_id is required for update action"
                })
            problem_id = str(problem_id).strip().strip('"')
            if problem_id not in problem_tickets:
                return json.dumps({
                    "success": False,
                    "error": f"Problem ticket '{problem_id}' not found"
                })

            if not problem_data:
                return json.dumps({
                    "success": False,
                    "error": "problem_data is required for update action"
                })

            # Allowed fields for update (all except problem_id, created_at)
            allowed_fields = [
                "problem_number", "title", "description", "category",
                "status", "reported_by", "assigned_to",
                "detected_at", "resolved_at", "closed_at"
            ]
            invalid_fields = [field for field in problem_data if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for update: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields (nullable fields can be None)
            # NOT NULL fields: problem_number, title, description, category, reported_by, assigned_to, detected_at
            nullable_fields = ["resolved_at", "closed_at"]
            for field, value in problem_data.items():
                if field not in nullable_fields and (value is None or (isinstance(value, str) and str(value).strip() == "")):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
                elif field in nullable_fields and (isinstance(value, str) and str(value).strip() == ""):
                    problem_data[field] = None  # Treat empty string as null for nullable fields

            # Validate problem_number uniqueness if updated
            if "problem_number" in problem_data:
                updated_problem_number = str(problem_data["problem_number"]).strip()
                for existing_problem_id, problem in problem_tickets.items():
                    if existing_problem_id != problem_id and problem["problem_number"].lower() == updated_problem_number.lower():
                        return json.dumps({
                            "success": False,
                            "error": f"Problem with number '{updated_problem_number}' already exists."
                        })
                problem_data["problem_number"] = updated_problem_number

            # Validate enums if provided
            if "category" in problem_data and problem_data["category"] not in valid_categories:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid category '{problem_data['category']}'. Must be one of: {', '.join(valid_categories)}"
                })
            if "status" in problem_data and problem_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{problem_data['status']}'. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate reported_by FK if provided
            if "reported_by" in problem_data:
                reported_by = str(problem_data["reported_by"]).strip().strip('"')
                if reported_by not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Reported by user '{reported_by}' not found"
                    })
                if users[reported_by]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Reported by user '{reported_by}' is not active"
                    })
                problem_data["reported_by"] = reported_by

            # Validate assigned_to FK if provided
            if "assigned_to" in problem_data:
                assigned_to = str(problem_data["assigned_to"]).strip().strip('"')
                if assigned_to not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Assigned to user '{assigned_to}' not found"
                    })
                if users[assigned_to]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Assigned to user '{assigned_to}' is not active"
                    })
                problem_data["assigned_to"] = assigned_to

            updated_problem = problem_tickets[problem_id].copy()
            for key, value in problem_data.items():
                updated_problem[key] = value
            updated_problem["updated_at"] = timestamp
            problem_tickets[problem_id] = updated_problem
            return json.dumps({
                "success": True,
                "action": "update",
                "problem_id": problem_id,
                "problem_data": updated_problem
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_problem_tickets",
                "description": "Create or update problem ticket records in the system. Problem tickets represent underlying issues that may cause multiple incidents.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to add a new problem ticket, 'update' to modify an existing problem ticket."
                        },
                        "problem_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating or updating a problem ticket.",
                            "properties": {
                                "problem_number": {
                                    "type": "string",
                                    "description": "A unique identifier for the problem ticket (required for create, must be unique, cannot be empty). Updatable."
                                },
                                "title": {
                                    "type": "string",
                                    "description": "A brief, descriptive title for the problem (required for create, cannot be empty). Updatable."
                                },
                                "description": {
                                    "type": "string",
                                    "description": "A detailed description of the problem, including its symptoms and potential impact (required for create, cannot be empty). Updatable."
                                },
                                "category": {
                                    "type": "string",
                                    "description": "The category of the problem (required for create). Must be one of: software, hardware, network, database, security. Updatable.",
                                    "enum": ["software", "hardware", "network", "database", "security"]
                                },
                                "status": {
                                    "type": "string",
                                    "description": "The current status of the problem (optional for create, defaults to 'open'). Must be one of: open, investigating, resolved, closed. Updatable.",
                                    "enum": ["open", "investigating", "resolved", "closed"]
                                },
                                "reported_by": {
                                    "type": "string",
                                    "description": "The user ID of the person who reported the problem (required for create). Must refer to an existing active user. Updatable."
                                },
                                "assigned_to": {
                                    "type": "string",
                                    "description": "The user ID of the person assigned to resolve the problem (required for create). Must refer to an existing active user. Updatable."
                                },
                                "detected_at": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the problem was detected (required for create, cannot be empty). Updatable."
                                },
                                "resolved_at": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the problem was resolved (optional). Updatable, can be set to null."
                                },
                                "closed_at": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the problem ticket was closed (optional). Updatable, can be set to null."
                                }
                            }
                        },
                        "problem_id": {
                            "type": "string",
                            "description": "The unique identifier of the problem ticket to update. Required for 'update' action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverCoordination(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover coordination entities (escalations, bridges, bridge_participants). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - escalations: Escalation records
        - bridges: Bridge records
        - bridge_participants: Bridge Participant records
        """
        if entity_type not in ["escalations", "bridges", "bridge_participants"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'escalations', 'bridges', or 'bridge_participants'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    if entity_type == "escalations":
                        id_field = "escalation_id"
                    elif entity_type == "bridges":
                        id_field = "bridge_id"
                    else:  # bridge_participants
                        id_field = "participant_id"
                    results.append({**entity_data, id_field: entity_id})
            else:
                if entity_type == "escalations":
                    id_field = "escalation_id"
                elif entity_type == "bridges":
                    id_field = "bridge_id"
                else:  # bridge_participants
                    id_field = "participant_id"
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_coordination",
                "description": "Discover coordination entities (escalations, bridges, bridge participants). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'escalations', 'bridges', or 'bridge_participants'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "escalation_id": {
                                    "type": "string",
                                    "description": "Escalation ID (for escalations)"
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "Associated incident ID"
                                },
                                "escalated_from": {
                                    "type": "string",
                                    "description": "User ID who requested escalation (for escalations)"
                                },
                                "escalated_to": {
                                    "type": "string",
                                    "description": "User ID receiving escalation (for escalations)"
                                },
                                "escalation_reason": {
                                    "type": "string",
                                    "description": "Reason for escalation (for escalations)"
                                },
                                "approver": {
                                    "type": "string",
                                    "description": "User ID who approved/denied the escalation (for escalations)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status: 'pending', 'approved', 'denied', 'cancelled'"
                                },
                                "requested_at": {
                                    "type": "string",
                                    "description": "Request timestamp in YYYY-MM-DD format (for escalations)"
                                },
                                "responded_at": {
                                    "type": "string",
                                    "description": "Response timestamp in YYYY-MM-DD format (for escalations)"
                                },
                                "bridge_id": {
                                    "type": "string",
                                    "description": "Bridge ID"
                                },
                                "bridge_number": {
                                    "type": "string",
                                    "description": "Bridge number, e.g., BRG0001234 (for bridges)"
                                },
                                "bridge_type": {
                                    "type": "string",
                                    "description": "Bridge type: 'major_incident', 'coordination', 'technical' (for bridges)"
                                },
                                "bridge_host": {
                                    "type": "string",
                                    "description": "User ID hosting the bridge (for bridges)"
                                },
                                "start_time": {
                                    "type": "string",
                                    "description": "Start timestamp in YYYY-MM-DD format (for bridges)"
                                },
                                "end_time": {
                                    "type": "string",
                                    "description": "End timestamp in YYYY-MM-DD format (for bridges)"
                                },
                                "participant_id": {
                                    "type": "string",
                                    "description": "Participant ID (for bridge_participants)"
                                },
                                "user_id": {
                                    "type": "string",
                                    "description": "User ID of the participant (for bridge_participants)"
                                },
                                "role_in_bridge": {
                                    "type": "string",
                                    "description": "Role in bridge: 'host', 'technical_support', 'account_manager', 'executive' (for bridge_participants)"
                                },
                                "joined_at": {
                                    "type": "string",
                                    "description": "Join timestamp in YYYY-MM-DD format (for bridge_participants)"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverImprovement(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover improvement entities (root_cause_analyses, post_incident_reviews). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - root_cause_analyses: Root Cause Analysis records
        - post_incident_reviews: Post Incident Review records
        """
        if entity_type not in ["root_cause_analyses", "post_incident_reviews"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'root_cause_analyses' or 'post_incident_reviews'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    if entity_type == "root_cause_analyses":
                        id_field = "rca_id"
                    else:  # post_incident_reviews
                        id_field = "review_id"
                    results.append({**entity_data, id_field: entity_id})
            else:
                if entity_type == "root_cause_analyses":
                    id_field = "rca_id"
                else:  # post_incident_reviews
                    id_field = "review_id"
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_improvement",
                "description": "Discover improvement entities (root cause analyses, post incident reviews). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'root_cause_analyses' or 'post_incident_reviews'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "rca_id": {
                                    "type": "string",
                                    "description": "Root cause analysis ID (for root_cause_analyses)"
                                },
                                "rca_number": {
                                    "type": "string",
                                    "description": "RCA number, e.g., RCA0001234 (for root_cause_analyses)"
                                },
                                "rca_title": {
                                    "type": "string",
                                    "description": "RCA title (for root_cause_analyses)"
                                },
                                "associated_incident_id": {
                                    "type": "string",
                                    "description": "Associated incident ID (for root_cause_analyses)"
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "Associated incident ID (for post_incident_reviews)"
                                },
                                "assigned_to": {
                                    "type": "string",
                                    "description": "User ID assigned to the RCA (for root_cause_analyses)"
                                },
                                "analysis_method": {
                                    "type": "string",
                                    "description": "Analysis method: '5_whys', 'fishbone', 'timeline', 'fault_tree', 'kepner_tregoe' (for root_cause_analyses)"
                                },
                                "root_cause_summary": {
                                    "type": "string",
                                    "description": "Summary of root cause findings (for root_cause_analyses)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status: 'assigned', 'in_progress', 'completed', 'approved', 'scheduled', 'cancelled'"
                                },
                                "due_date": {
                                    "type": "string",
                                    "description": "Due date in YYYY-MM-DD format (for root_cause_analyses)"
                                },
                                "completed_at": {
                                    "type": "string",
                                    "description": "Completion timestamp in YYYY-MM-DD format (for root_cause_analyses)"
                                },
                                "approved_by": {
                                    "type": "string",
                                    "description": "User ID who approved the RCA (for root_cause_analyses)"
                                },
                                "reported_by": {
                                    "type": "string",
                                    "description": "User ID who reported (for root_cause_analyses)"
                                },
                                "review_id": {
                                    "type": "string",
                                    "description": "Post incident review ID (for post_incident_reviews)"
                                },
                                "scheduled_date": {
                                    "type": "string",
                                    "description": "Scheduled date in YYYY-MM-DD format (for post_incident_reviews)"
                                },
                                "facilitator": {
                                    "type": "string",
                                    "description": "User ID of facilitator (for post_incident_reviews)"
                                },
                                "review_notes": {
                                    "type": "string",
                                    "description": "Notes from the review (for post_incident_reviews)"
                                },
                                "lessons_learned": {
                                    "type": "string",
                                    "description": "Lessons learned (for post_incident_reviews)"
                                },
                                "action_items": {
                                    "type": "string",
                                    "description": "Action items from the review (for post_incident_reviews)"
                                },
                                "created_by": {
                                    "type": "string",
                                    "description": "User ID who created (for post_incident_reviews)"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                },
                                "updated_at": {
                                    "type": "string",
                                    "description": "Update timestamp in YYYY-MM-DD format (for root_cause_analyses)"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageEscalations(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, escalation_data: Dict[str, Any] = None, escalation_id: str = None) -> str:
        """
        Create or update escalation records.
        
        Actions:
        - create: Create new escalation (requires incident_id, escalated_from, escalated_to, escalation_reason, approver)
        - update: Update existing escalation (requires escalation_id and fields to update)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for escalations"
            })
        
        # get existing data tables
        escalations = data.get("escalations", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        # allowed enums
        valid_statuses = ["pending", "approved", "denied", "cancelled"]

        # allowed values
        required_user_status = ["active"]

        # for create action
        if action == "create":
            if not escalation_data:
                return json.dumps({
                    "success": False,
                    "error": "escalation_data is required for create action"
                })

            # Validate required fields for create (approver is optional as it's set during approval)
            required_fields = ["incident_id", "escalated_to", "escalation_reason", "escalated_from"]
            
            missing_fields = [field for field in required_fields if field not in escalation_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Missing required fields for create action: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not escalation_data[field] or str(escalation_data[field]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
            
            # Allowed fields
            allowed_fields = ["incident_id", "escalated_to", "escalation_reason", "escalated_from", "approver", "status"]

            escalation_fields = [field for field in escalation_data if field not in allowed_fields]
            if escalation_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Unrecognized fields in escalation_data: {', '.join(escalation_fields)}"
                })
            
            # Validate that incident exists
            if str(escalation_data["incident_id"]) not in incidents:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Incident not found"
                })
            
            # Validate that escalated_from user exists
            if str(escalation_data["escalated_from"]) not in users:
                return json.dumps({
                    "success": False,
                    "error": "Halt: User escalated_from not found"
                })
            
            # Validate that escalated_to user exists
            if str(escalation_data["escalated_to"]) not in users:
                return json.dumps({
                    "success": False,
                    "error": "Halt: User escalated_to not found"
                })
            
            # Validate that escalated_to and escalated_from users are active
            for key in ["escalated_to", "escalated_from"]:
                user_id = str(escalation_data[key])
                if users[user_id]["status"] not in required_user_status:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: User {key} must be active"
                    })
            
            # Validate optional approver if provided
            if escalation_data.get("approver"):
                if not str(escalation_data["approver"]).strip():
                    return json.dumps({
                        "success": False,
                        "error": "Field 'approver' cannot be empty if provided"
                    })
                
                if str(escalation_data["approver"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Approver user not found"
                    })
                
                # Validate that approver user is active
                if users[str(escalation_data["approver"])]["status"] not in required_user_status:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User 'approver' must be active"
                    })
            
            # Validate status
            status = escalation_data.get("status", "pending")
            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid status - must be one of: {', '.join(valid_statuses)}"
                })
            
            # Generate new escalation ID
            new_escalation_id = generate_id(escalations)
            
            # Create new escalation record
            new_escalation = {
                "escalation_id": str(new_escalation_id),
                "incident_id": str(escalation_data["incident_id"]),
                "escalated_to": str(escalation_data["escalated_to"]),
                "escalation_reason": escalation_data["escalation_reason"],
                "approver": str(escalation_data["approver"]) if escalation_data.get("approver") not in (None, "") else None,
                "status": status,
                "escalated_from": str(escalation_data["escalated_from"]),
                "requested_at": "2025-10-07T00:00:00",
                "responded_at": None
            }
            
            escalations[str(new_escalation_id)] = new_escalation
            
            return json.dumps({
                "success": True,
                "action": "create",
                "escalation_id": str(new_escalation_id),
                "message": f"Escalation {new_escalation_id} created successfully",
                "escalation_data": new_escalation
            })
        
        # for update action
        elif action == "update":
            if not escalation_id:
                return json.dumps({
                    "success": False,
                    "error": "escalation_id is required for update action"
                })
            
            if str(escalation_id) not in escalations:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Escalation not found"
                })
            
            if not escalation_data:
                return json.dumps({
                    "success": False,
                    "error": "escalation_data is required for update action"
                })
            
            # Validate at least one optional field is provided (added escalation_reason and approver)
            update_fields = ["status", "escalated_to", "escalation_reason", "approver", "responded_at"]
            provided_fields = [field for field in update_fields if field in escalation_data]
            if not provided_fields:
                return json.dumps({
                    "success": False,
                    "error": f"At least one optional field must be provided for updates {', '.join(update_fields)}"
                })
            
            # Validate only allowed fields for updates
            invalid_fields = [field for field in escalation_data.keys() if field not in update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for escalation updating: {', '.join(invalid_fields)}"
                })

            # Validate non-empty fields
            for field, value in escalation_data.items():
                if field not in ["responded_at", "approver"] and value is not None and str(value).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate user to reassign the escalation to exists if provided
            if "escalated_to" in escalation_data: 
                if str(escalation_data["escalated_to"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User escalated_to not found"
                    })
            
                # Validate that reassign escalated_to user is active
                if users[str(escalation_data["escalated_to"])]["status"] not in required_user_status: 
                    return json.dumps({ 
                        "success": False, 
                        "error": "Halt: User escalated_to must be active" 
                    })
            
            # Validate approver if provided
            if "approver" in escalation_data:
                if escalation_data["approver"] is not None and str(escalation_data["approver"]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": "Field 'approver' cannot be empty if provided"
                    })
                
                if escalation_data["approver"] is not None:
                    if str(escalation_data["approver"]) not in users:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: Approver user not found"
                        })
                    
                    # Validate that approver user is active
                    if users[str(escalation_data["approver"])]["status"] not in required_user_status:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: User 'approver' must be active"
                        })
            
            # Validate status if provided
            if "status" in escalation_data and escalation_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid status. Must be one of: {', '.join(valid_statuses)}"
                })
            
            # Validate responded_at is not empty if provided
            if "responded_at" in escalation_data:
                if escalation_data["responded_at"] is not None and str(escalation_data["responded_at"]).strip() == "":
                    return json.dumps({
                        "success": False,
                        "error": "Field 'responded_at' cannot be empty if provided"
                    })

            # Get current escalation record
            current_escalation = escalations[str(escalation_id)]
            # Update escalation record with modified information
            updated_escalation = current_escalation.copy()
            for key, value in escalation_data.items():
                if key in ["responded_at", "approver"]:
                    updated_escalation[key] = str(value) if value not in (None, "") else None
                elif key == "escalated_to":
                    updated_escalation[key] = str(value)
                else:
                    updated_escalation[key] = value
            
            escalations[str(escalation_id)] = updated_escalation
            
            return json.dumps({
                "success": True,
                "action": "update",
                "escalation_id": str(escalation_id),
                "message": f"Escalation {escalation_id} updated successfully",
                "escalation_data": updated_escalation
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_escalations",
                "description": "Create or update escalation records in the incident management system. This tool manages escalation workflows with comprehensive validation of users, incidents, and status transitions. For creation, establishes new escalations with proper validation of incident existence, user roles, and escalation paths. For updates, modifies existing escalation records including status changes, escalation reason updates, and response timestamps.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to create new escalation, 'update' to modify existing escalation"
                        },
                        "escalation_data": {
                            "type": "object",
                            "description": "Escalation data object containing fields for creating or updating escalations",
                            "properties": {
                                "incident_id": {
                                    "type": "string",
                                    "description": "Related incident identifier (required for create, cannot be empty, must exist in system)"
                                },
                                "escalated_from": {
                                    "type": "string",
                                    "description": "User identifier who requested the escalation (required for create, cannot be empty, must be active user)"
                                },
                                "escalated_to": {
                                    "type": "string",
                                    "description": "User identifier receiving the escalation (required for create, cannot be empty, must be active user). Updatable."
                                },
                                "escalation_reason": {
                                    "type": "string",
                                    "description": "Reason for escalation (required for create, cannot be empty). Updatable."
                                },
                                "approver": {
                                    "type": "string",
                                    "description": "User identifier who approved/denied the escalation (optional, typically set during approval process, cannot be empty if provided, must be active user). Updatable."
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Escalation status (optional for create, defaults to 'pending'). Must be one of: pending, approved, denied, cancelled. Updatable."
                                },
                                "responded_at": {
                                    "type": "string",
                                    "description": "Response timestamp in YYYY-MM-DDTHH:MM:SS format (optional, cannot be empty if provided). Updatable."
                                }
                            }
                        },
                        "escalation_id": {
                            "type": "string",
                            "description": "Unique identifier of the escalation. Required for update action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageIncidents(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        incident_data: Optional[Dict[str, Any]] = None,
        incident_id: Optional[str] = None
    ) -> str:
        """
        Create or update incident records.

        Actions:
        - create: Create a new incident record (requires incident_data)
        - update: Update an existing incident record (requires incident_id and incident_data)
        """

        def generate_id(table: Dict[str, Any], prefix: str) -> str:
            if not table:
                return f"{prefix}1"
            max_id = 0
            for k in table.keys():
                try:
                    num = int(k[len(prefix):])
                    if num > max_id:
                        max_id = num
                except ValueError:
                    continue
            return f"{prefix}{max_id + 1}"

        def generate_incident_number(table: Dict[str, Any]) -> str:
            if not table:
                return "INC0000001"
            max_num = 0
            for incident in table.values():
                incident_num = incident.get("incident_number", "")
                if incident_num.startswith("INC"):
                    try:
                        num = int(incident_num[3:])
                        if num > max_num:
                            max_num = num
                    except ValueError:
                        continue
            return f"INC{max_num + 1:07d}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        incidents = data.get("incidents", {})
        users = data.get("users", {})
        problem_tickets = data.get("problem_tickets", {})

        # Define valid enums based on DBML schema
        valid_categories = ["inquiry/help", "software", "hardware", "Network", "Database"]
        valid_severities = ["P1", "P2", "P3", "P4"]
        valid_impacts = ["low", "medium", "high", "critical"]
        valid_urgencies = ["low", "medium", "high", "critical"]
        valid_statuses = ["open", "in_progress", "monitoring", "resolved", "closed"]

        if action == "create":
            if not incident_data:
                return json.dumps({
                    "success": False,
                    "error": "incident_data is required for create action"
                })

            # Validate required fields as per DBML (incident_number is auto-generated)
            required_fields = [
                "title", "description", "category",
                "severity", "impact", "urgency", "reported_by", "detection_time"
            ]
            missing_fields = [field for field in required_fields if field not in incident_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not incident_data[field] or (isinstance(incident_data[field], str) and str(incident_data[field]).strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate enums
            if incident_data["category"] not in valid_categories:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid category '{incident_data['category']}'. Must be one of: {', '.join(valid_categories)}"
                })
            if incident_data["severity"] not in valid_severities:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid severity '{incident_data['severity']}'. Must be one of: {', '.join(valid_severities)}"
                })
            if incident_data["impact"] not in valid_impacts:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid impact '{incident_data['impact']}'. Must be one of: {', '.join(valid_impacts)}"
                })
            if incident_data["urgency"] not in valid_urgencies:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid urgency '{incident_data['urgency']}'. Must be one of: {', '.join(valid_urgencies)}"
                })
            
            # Status is 'open' by default, if provided, must be valid
            status = incident_data.get("status", "open")
            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{status}'. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate reported_by FK
            reported_by = str(incident_data["reported_by"]).strip().strip('"')
            if reported_by not in users:
                return json.dumps({
                    "success": False,
                    "error": f"Reported by user '{reported_by}' not found"
                })
            if users[reported_by]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"Reported by user '{reported_by}' is not active"
                })

            # Validate assigned_to FK if provided
            assigned_to = incident_data.get("assigned_to")
            if assigned_to:
                assigned_to = str(assigned_to).strip().strip('"')
                if assigned_to not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Assigned to user '{assigned_to}' not found"
                    })
                if users[assigned_to]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Assigned to user '{assigned_to}' is not active"
                    })
            
            # Validate problem_id FK if provided
            problem_id = incident_data.get("problem_id")
            if problem_id:
                problem_id = str(problem_id).strip().strip('"')
                if problem_id not in problem_tickets:
                    return json.dumps({
                        "success": False,
                        "error": f"Problem ticket '{problem_id}' not found"
                    })

            new_id = generate_id(incidents, "")
            incident_number = generate_incident_number(incidents)
            
            new_incident = {
                "incident_id": new_id,
                "problem_id": problem_id if problem_id else None,
                "incident_number": incident_number,
                "title": incident_data["title"],
                "description": incident_data["description"],
                "category": incident_data["category"],
                "severity": incident_data["severity"],
                "impact": incident_data["impact"],
                "urgency": incident_data["urgency"],
                "status": status,
                "reported_by": reported_by,
                "assigned_to": assigned_to if assigned_to else None,
                "detection_time": incident_data["detection_time"],
                "acknowledged_at": incident_data.get("acknowledged_at"), # Nullable
                "resolved_at": incident_data.get("resolved_at"), # Nullable
                "closed_at": incident_data.get("closed_at"), # Nullable
                "created_at": timestamp,
                "updated_at": timestamp
            }
            incidents[new_id] = new_incident
            return json.dumps({
                "success": True,
                "action": "create",
                "incident_id": new_id,
                "incident_data": new_incident
            })

        elif action == "update":
            if not incident_id:
                return json.dumps({
                    "success": False,
                    "error": "incident_id is required for update action"
                })
            incident_id = str(incident_id).strip().strip('"')
            if incident_id not in incidents:
                return json.dumps({
                    "success": False,
                    "error": f"Incident '{incident_id}' not found"
                })

            if not incident_data:
                return json.dumps({
                    "success": False,
                    "error": "incident_data is required for update action"
                })

            # Allowed fields for update (incident_id, incident_number, created_at are not updatable)
            allowed_fields = [
                "problem_id", "title", "description", "category",
                "severity", "impact", "urgency", "status", "reported_by",
                "assigned_to", "detection_time", "acknowledged_at", "resolved_at", "closed_at"
            ]
            invalid_fields = [field for field in incident_data if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for update: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields (if provided, they shouldn't be empty strings, but nullable fields can be None)
            # Note: title, description, category, severity, impact, urgency, reported_by, detection_time are NOT NULL
            nullable_fields = [
                "problem_id", "assigned_to", "acknowledged_at", "resolved_at", "closed_at"
            ]
            for field, value in incident_data.items():
                if field not in nullable_fields and (value is None or (isinstance(value, str) and str(value).strip() == "")):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
                elif field in nullable_fields and (isinstance(value, str) and str(value).strip() == ""):
                    incident_data[field] = None # Treat empty string as null for nullable fields

            # Validate enums if provided
            if "category" in incident_data and incident_data["category"] not in valid_categories:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid category '{incident_data['category']}'. Must be one of: {', '.join(valid_categories)}"
                })
            if "severity" in incident_data and incident_data["severity"] not in valid_severities:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid severity '{incident_data['severity']}'. Must be one of: {', '.join(valid_severities)}"
                })
            if "impact" in incident_data and incident_data["impact"] not in valid_impacts:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid impact '{incident_data['impact']}'. Must be one of: {', '.join(valid_impacts)}"
                })
            if "urgency" in incident_data and incident_data["urgency"] not in valid_urgencies:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid urgency '{incident_data['urgency']}'. Must be one of: {', '.join(valid_urgencies)}"
                })
            if "status" in incident_data and incident_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{incident_data['status']}'. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate reported_by FK if provided
            if "reported_by" in incident_data:
                reported_by = str(incident_data["reported_by"]).strip().strip('"')
                if reported_by not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Reported by user '{reported_by}' not found"
                    })
                if users[reported_by]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Reported by user '{reported_by}' is not active"
                    })
                incident_data["reported_by"] = reported_by

            # Validate assigned_to FK if provided
            if "assigned_to" in incident_data and incident_data["assigned_to"] is not None:
                assigned_to = str(incident_data["assigned_to"]).strip().strip('"')
                if assigned_to not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Assigned to user '{assigned_to}' not found"
                    })
                if users[assigned_to]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Assigned to user '{assigned_to}' is not active"
                    })
                incident_data["assigned_to"] = assigned_to
            elif "assigned_to" in incident_data and incident_data["assigned_to"] is None:
                incident_data["assigned_to"] = None # Allow setting to null

            # Validate problem_id FK if provided
            if "problem_id" in incident_data and incident_data["problem_id"] is not None:
                problem_id = str(incident_data["problem_id"]).strip().strip('"')
                if problem_id not in problem_tickets:
                    return json.dumps({
                        "success": False,
                        "error": f"Problem ticket '{problem_id}' not found"
                    })
                incident_data["problem_id"] = problem_id
            elif "problem_id" in incident_data and incident_data["problem_id"] is None:
                incident_data["problem_id"] = None # Allow setting to null

            updated_incident = incidents[incident_id].copy()
            for key, value in incident_data.items():
                updated_incident[key] = value
            updated_incident["updated_at"] = timestamp
            incidents[incident_id] = updated_incident
            return json.dumps({
                "success": True,
                "action": "update",
                "incident_id": incident_id,
                "incident_data": updated_incident
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_incidents",
                "description": "Create or update incident records in the system. This tool allows for managing incident details, including linking to problem tickets, assigning to users, and tracking status. Incident numbers are automatically generated.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to add a new incident, 'update' to modify an existing incident."
                        },
                        "incident_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating or updating an incident.",
                            "properties": {
                                "problem_id": {
                                    "type": "string",
                                    "description": "The ID of the associated problem ticket (optional). Must refer to an existing problem ticket. Updatable, can be set to null."
                                },
                                "title": {
                                    "type": "string",
                                    "description": "A brief, descriptive title for the incident (required for create, cannot be empty). Updatable."
                                },
                                "description": {
                                    "type": "string",
                                    "description": "A detailed description of the incident, including symptoms and impact (required for create, cannot be empty). Updatable."
                                },
                                "category": {
                                    "type": "string",
                                    "description": "The category of the incident (required for create). Must be one of: inquiry/help, software, hardware, Network, Database. Updatable.",
                                    "enum": ["inquiry/help", "software", "hardware", "Network", "Database"]
                                },
                                "severity": {
                                    "type": "string",
                                    "description": "The severity level of the incident (required for create). Must be one of: P1, P2, P3, P4. Updatable.",
                                    "enum": ["P1", "P2", "P3", "P4"]
                                },
                                "impact": {
                                    "type": "string",
                                    "description": "The impact of the incident on services or users (required for create). Must be one of: low, medium, high, critical. Updatable.",
                                    "enum": ["low", "medium", "high", "critical"]
                                },
                                "urgency": {
                                    "type": "string",
                                    "description": "The urgency of resolving the incident (required for create). Must be one of: low, medium, high, critical. Updatable.",
                                    "enum": ["low", "medium", "high", "critical"]
                                },
                                "status": {
                                    "type": "string",
                                    "description": "The current status of the incident (optional for create, defaults to 'open'). Must be one of: open, in_progress, monitoring, resolved, closed. Updatable.",
                                    "enum": ["open", "in_progress", "monitoring", "resolved", "closed"]
                                },
                                "reported_by": {
                                    "type": "string",
                                    "description": "The user ID of the person who reported the incident (required for create). Must refer to an existing active user. Updatable."
                                },
                                "assigned_to": {
                                    "type": "string",
                                    "description": "The user ID of the person assigned to resolve the incident (optional). Must refer to an existing active user. Updatable, can be set to null."
                                },
                                "detection_time": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the incident was detected (required for create, cannot be empty). Updatable."
                                },
                                "acknowledged_at": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the incident was acknowledged (optional). Updatable, can be set to null."
                                },
                                "resolved_at": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the incident was resolved (optional). Updatable, can be set to null."
                                },
                                "closed_at": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the incident was closed (optional). Updatable, can be set to null."
                                }
                            }
                        },
                        "incident_id": {
                            "type": "string",
                            "description": "The unique identifier of the incident to update. Required for 'update' action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageAssets(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        entity_type: str,
        entity_data: Optional[Dict[str, Any]] = None,
        entity_id: Optional[str] = None
    ) -> str:
        """
        Create or update asset records (configuration items or CI-client assignments).

        Actions:
        - create: Create a new record (requires entity_type and entity_data)
        - update: Update an existing record (requires entity_type, entity_id, and entity_data)

        Entity Types:
        - configuration_items: Manages individual configuration items.
        - ci_client_assignments: Manages the assignment of configuration items to clients.
        """

        def generate_id(table: Dict[str, Any], prefix: str = "") -> str:
            if not table:
                return f"{prefix}1"
            max_id_num = 0
            for k in table.keys():
                try:
                    # Extract numeric part, handling potential non-numeric keys gracefully
                    if k.startswith(prefix):
                        num_part = int(k[len(prefix):])
                        if num_part > max_id_num:
                            max_id_num = num_part
                except ValueError:
                    continue # Ignore keys that don't match the expected format
            return f"{prefix}{max_id_num + 1}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if entity_type not in ["configuration_items", "ci_client_assignments"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'configuration_items' or 'ci_client_assignments'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        config_items = data.get("configuration_items", {})
        ci_client_assignments = data.get("ci_client_assignments", {})
        users = data.get("users", {}) # For responsible_owner validation
        clients = data.get("clients", {}) # For client_id validation

        # Define valid enums based on DBML schema
        valid_ci_types = ["server", "application", "database", "network", "storage", "service"]
        valid_environments = ["production", "staging", "development", "testing"]
        valid_operational_statuses = ["operational", "degraded", "down"]

        if action == "create":
            if not entity_data:
                return json.dumps({
                    "success": False,
                    "error": "entity_data is required for create action"
                })

            if entity_type == "configuration_items":
                required_fields = ["ci_name", "ci_type", "environment", "operational_status", "responsible_owner"]
                for field in required_fields:
                    if field not in entity_data or not entity_data[field] or str(entity_data[field]).strip() == "":
                        return json.dumps({
                            "success": False,
                            "error": f"Missing or empty required field for configuration_items: '{field}'"
                        })

                # Validate enums
                if entity_data["ci_type"] not in valid_ci_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid ci_type '{entity_data['ci_type']}'. Must be one of: {', '.join(valid_ci_types)}"
                    })
                if entity_data["environment"] not in valid_environments:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid environment '{entity_data['environment']}'. Must be one of: {', '.join(valid_environments)}"
                    })
                if entity_data["operational_status"] not in valid_operational_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid operational_status '{entity_data['operational_status']}'. Must be one of: {', '.join(valid_operational_statuses)}"
                    })

                # Validate responsible_owner exists and is active
                responsible_owner = str(entity_data["responsible_owner"]).strip().strip('"')
                if responsible_owner not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Responsible owner user '{responsible_owner}' not found"
                    })
                if users[responsible_owner]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Responsible owner user '{responsible_owner}' is not active"
                    })

                # Check for unique ci_name
                for ci in config_items.values():
                    if ci["ci_name"] == entity_data["ci_name"]:
                        return json.dumps({
                            "success": False,
                            "error": f"Configuration item with name '{entity_data['ci_name']}' already exists."
                        })

                new_id = generate_id(config_items, "CI")
                new_ci = {
                    "ci_id": new_id,
                    "ci_name": entity_data["ci_name"],
                    "ci_type": entity_data["ci_type"],
                    "environment": entity_data["environment"],
                    "operational_status": entity_data["operational_status"],
                    "responsible_owner": responsible_owner,
                    "created_at": timestamp,
                    "updated_at": timestamp
                }
                config_items[new_id] = new_ci
                return json.dumps({
                    "success": True,
                    "action": "create",
                    "entity_type": entity_type,
                    "ci_id": new_id,
                    "ci_data": new_ci
                })

            elif entity_type == "ci_client_assignments":
                required_fields = ["ci_id", "client_id"]
                for field in required_fields:
                    if field not in entity_data or not entity_data[field] or str(entity_data[field]).strip() == "":
                        return json.dumps({
                            "success": False,
                            "error": f"Missing or empty required field for ci_client_assignments: '{field}'"
                        })

                # Validate ci_id and client_id exist
                ci_id = str(entity_data["ci_id"]).strip().strip('"')
                client_id = str(entity_data["client_id"]).strip().strip('"')

                if ci_id not in config_items:
                    return json.dumps({
                        "success": False,
                        "error": f"Configuration item '{ci_id}' not found."
                    })
                if client_id not in clients:
                    return json.dumps({
                        "success": False,
                        "error": f"Client '{client_id}' not found."
                    })

                # Check for unique assignment (ci_id, client_id)
                for assignment in ci_client_assignments.values():
                    if assignment["ci_id"] == ci_id and assignment["client_id"] == client_id:
                        return json.dumps({
                            "success": False,
                            "error": f"Assignment for CI '{ci_id}' to client '{client_id}' already exists."
                        })

                new_id = generate_id(ci_client_assignments, "ASSIGN")
                new_assignment = {
                    "assignment_id": new_id,
                    "ci_id": ci_id,
                    "client_id": client_id,
                    "created_at": timestamp
                }
                ci_client_assignments[new_id] = new_assignment
                return json.dumps({
                    "success": True,
                    "action": "create",
                    "entity_type": entity_type,
                    "assignment_id": new_id,
                    "assignment_data": new_assignment
                })

        elif action == "update":
            if not entity_id:
                return json.dumps({
                    "success": False,
                    "error": "entity_id is required for update action"
                })
            if not entity_data:
                return json.dumps({
                    "success": False,
                    "error": "entity_data is required for update action"
                })

            entity_id = str(entity_id).strip().strip('"')

            if entity_type == "configuration_items":
                if entity_id not in config_items:
                    return json.dumps({
                        "success": False,
                        "error": f"Configuration item '{entity_id}' not found."
                    })

                # Validate allowed fields for update
                allowed_fields = ["ci_name", "ci_type", "environment", "operational_status", "responsible_owner"]
                invalid_fields = [field for field in entity_data if field not in allowed_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields for configuration_items update: {', '.join(invalid_fields)}"
                    })

                # Validate non-empty fields
                for field, value in entity_data.items():
                    if value is None or (isinstance(value, str) and value.strip() == ""):
                        return json.dumps({
                            "success": False,
                            "error": f"Field '{field}' cannot be empty"
                        })

                # Validate enums if provided
                if "ci_type" in entity_data and entity_data["ci_type"] not in valid_ci_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid ci_type '{entity_data['ci_type']}'. Must be one of: {', '.join(valid_ci_types)}"
                    })
                if "environment" in entity_data and entity_data["environment"] not in valid_environments:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid environment '{entity_data['environment']}'. Must be one of: {', '.join(valid_environments)}"
                    })
                if "operational_status" in entity_data and entity_data["operational_status"] not in valid_operational_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid operational_status '{entity_data['operational_status']}'. Must be one of: {', '.join(valid_operational_statuses)}"
                    })

                # Validate responsible_owner if provided
                if "responsible_owner" in entity_data:
                    responsible_owner = str(entity_data["responsible_owner"]).strip().strip('"')
                    if responsible_owner not in users:
                        return json.dumps({
                            "success": False,
                            "error": f"Responsible owner user '{responsible_owner}' not found"
                        })
                    if users[responsible_owner]["status"] != "active":
                        return json.dumps({
                            "success": False,
                            "error": f"Responsible owner user '{responsible_owner}' is not active"
                        })
                    entity_data["responsible_owner"] = responsible_owner

                # Check for unique ci_name if updated
                if "ci_name" in entity_data:
                    for ci_id_key, ci in config_items.items():
                        if ci_id_key != entity_id and ci["ci_name"] == entity_data["ci_name"]:
                            return json.dumps({
                                "success": False,
                                "error": f"Configuration item with name '{entity_data['ci_name']}' already exists."
                            })

                updated_ci = config_items[entity_id].copy()
                for key, value in entity_data.items():
                    updated_ci[key] = value
                updated_ci["updated_at"] = timestamp
                config_items[entity_id] = updated_ci
                return json.dumps({
                    "success": True,
                    "action": "update",
                    "entity_type": entity_type,
                    "ci_id": entity_id,
                    "ci_data": updated_ci
                })

            elif entity_type == "ci_client_assignments":
                if entity_id not in ci_client_assignments:
                    return json.dumps({
                        "success": False,
                        "error": f"CI-Client assignment '{entity_id}' not found."
                    })

                # Based on the DBML schema, ci_id and client_id are not directly updatable via assignment_id.
                # Assignments are typically immutable; if changes are needed, the old assignment is deleted,
                # and a new one is created.
                return json.dumps({
                    "success": False,
                    "error": "CI-Client assignments are generally immutable. Please delete and re-create if changes are needed."
                })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_assets",
                "description": "Create or update asset records. This includes managing configuration items (CIs) and their assignments to clients. Use 'configuration_items' for individual asset details and 'ci_client_assignments' for linking CIs to clients.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new record, 'update' to modify existing record"
                        },
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to manage. Must be 'configuration_items' or 'ci_client_assignments'.",
                            "enum": ["configuration_items", "ci_client_assignments"]
                        },
                        "entity_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating or updating the specified entity_type. The required fields vary based on 'entity_type' and 'action'.",
                            "properties": {
                                # Properties relevant for 'configuration_items'
                                "ci_name": {
                                    "type": "string",
                                    "description": "Name of the Configuration Item (required for creating 'configuration_items', must be unique, cannot be empty). Updatable."
                                },
                                "ci_type": {
                                    "type": "string",
                                    "description": "Type of the Configuration Item (required for creating 'configuration_items'). Must be one of: server, application, database, network, storage, service. Updatable.",
                                    "enum": ["server", "application", "database", "network", "storage", "service"]
                                },
                                "environment": {
                                    "type": "string",
                                    "description": "Environment where the CI is deployed (required for creating 'configuration_items'). Must be one of: production, staging, development, testing. Updatable.",
                                    "enum": ["production", "staging", "development", "testing"]
                                },
                                "operational_status": {
                                    "type": "string",
                                    "description": "Operational status of the CI (required for creating 'configuration_items'). Must be one of: operational, degraded, down. Updatable.",
                                    "enum": ["operational", "degraded", "down"]
                                },
                                "responsible_owner": {
                                    "type": "string",
                                    "description": "User ID of the responsible owner for the CI (required for creating 'configuration_items', must be an active user). Updatable."
                                },
                                # Properties relevant for 'ci_client_assignments'
                                "ci_id": {
                                    "type": "string",
                                    "description": "ID of the Configuration Item to assign (required for creating 'ci_client_assignments', must exist). Not updatable for existing assignments."
                                },
                                "client_id": {
                                    "type": "string",
                                    "description": "ID of the Client to assign the CI to (required for creating 'ci_client_assignments', must exist). Not updatable for existing assignments."
                                }
                            }
                        },
                        "entity_id": {
                            "type": "string",
                            "description": "Unique identifier of the entity to update. Required for 'update' action only. For 'configuration_items', this is 'ci_id'. For 'ci_client_assignments', this is 'assignment_id'."
                        }
                    },
                    "required": ["action", "entity_type"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageIncidentsProblemsConfigurationItems(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        entity_type: str,
        association_data: Optional[Dict[str, Any]] = None,
        association_id: Optional[str] = None
    ) -> str:
        """
        Create or update incident-CI and problem-CI association records.

        Actions:
        - create: Create a new association record (requires entity_type and association_data)
        - update: Update an existing association record (requires entity_type, association_id and association_data)
        
        Entity Types:
        - incident_ci: For incident_configuration_items associations
        - problem_ci: For problem_configuration_items associations
        """

        def generate_id(table: Dict[str, Any], prefix: str) -> str:
            if not table:
                return f"{prefix}1"
            max_id = 0
            for k in table.keys():
                try:
                    num = int(k[len(prefix):])
                    if num > max_id:
                        max_id = num
                except ValueError:
                    continue
            return f"{prefix}{max_id + 1}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if entity_type not in ["incident_ci", "problem_ci"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'incident_ci' or 'problem_ci'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        configuration_items = data.get("configuration_items", {})

        if entity_type == "incident_ci":
            associations = data.get("incident_configuration_items", {})
            incidents = data.get("incidents", {})
            parent_key = "incident_id"
            parent_table = incidents
            parent_name = "Incident"
            id_field = "incident_ci_id"
            prefix = ""
        else:  # problem_ci
            associations = data.get("problem_configuration_items", {})
            problem_tickets = data.get("problem_tickets", {})
            parent_key = "problem_id"
            parent_table = problem_tickets
            parent_name = "Problem"
            id_field = "problem_ci_id"
            prefix = ""

        if action == "create":
            if not association_data:
                return json.dumps({
                    "success": False,
                    "error": "association_data is required for create action"
                })

            # Validate required fields
            required_fields = [parent_key, "ci_id"]
            missing_fields = [field for field in required_fields if field not in association_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not association_data[field] or (isinstance(association_data[field], str) and str(association_data[field]).strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate parent FK (incident_id or problem_id)
            parent_id = str(association_data[parent_key]).strip().strip('"')
            if parent_id not in parent_table:
                return json.dumps({
                    "success": False,
                    "error": f"{parent_name} '{parent_id}' not found"
                })

            # Validate ci_id FK
            ci_id = str(association_data["ci_id"]).strip().strip('"')
            if ci_id not in configuration_items:
                return json.dumps({
                    "success": False,
                    "error": f"Configuration item '{ci_id}' not found"
                })

            # Check for duplicate association (unique constraint on parent_id + ci_id)
            for assoc in associations.values():
                if assoc[parent_key] == parent_id and assoc["ci_id"] == ci_id:
                    return json.dumps({
                        "success": False,
                        "error": f"Association between {parent_name.lower()} '{parent_id}' and CI '{ci_id}' already exists"
                    })

            new_id = generate_id(associations, prefix)
            new_association = {
                id_field: new_id,
                parent_key: parent_id,
                "ci_id": ci_id,
                "created_at": timestamp
            }
            associations[new_id] = new_association
            return json.dumps({
                "success": True,
                "action": "create",
                "association_id": new_id,
                "association_data": new_association
            })

        elif action == "update":
            if not association_id:
                return json.dumps({
                    "success": False,
                    "error": "association_id is required for update action"
                })
            association_id = str(association_id).strip().strip('"')
            if association_id not in associations:
                return json.dumps({
                    "success": False,
                    "error": f"Association '{association_id}' not found"
                })

            if not association_data:
                return json.dumps({
                    "success": False,
                    "error": "association_data is required for update action"
                })

            # Allowed fields for update (only parent_id and ci_id can be updated)
            allowed_fields = [parent_key, "ci_id"]
            invalid_fields = [field for field in association_data if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for update: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields
            for field, value in association_data.items():
                if value is None or (isinstance(value, str) and str(value).strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate parent FK if provided
            if parent_key in association_data:
                parent_id = str(association_data[parent_key]).strip().strip('"')
                if parent_id not in parent_table:
                    return json.dumps({
                        "success": False,
                        "error": f"{parent_name} '{parent_id}' not found"
                    })
                association_data[parent_key] = parent_id

            # Validate ci_id FK if provided
            if "ci_id" in association_data:
                ci_id = str(association_data["ci_id"]).strip().strip('"')
                if ci_id not in configuration_items:
                    return json.dumps({
                        "success": False,
                        "error": f"Configuration item '{ci_id}' not found"
                    })
                association_data["ci_id"] = ci_id

            # Check for duplicate association if updating
            updated_parent_id = association_data.get(parent_key, associations[association_id][parent_key])
            updated_ci_id = association_data.get("ci_id", associations[association_id]["ci_id"])
            
            for existing_id, assoc in associations.items():
                if existing_id != association_id and assoc[parent_key] == updated_parent_id and assoc["ci_id"] == updated_ci_id:
                    return json.dumps({
                        "success": False,
                        "error": f"Association between {parent_name.lower()} '{updated_parent_id}' and CI '{updated_ci_id}' already exists"
                    })

            updated_association = associations[association_id].copy()
            for key, value in association_data.items():
                updated_association[key] = value
            
            associations[association_id] = updated_association
            return json.dumps({
                "success": True,
                "action": "update",
                "association_id": association_id,
                "association_data": updated_association
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_incidents_problems_configuration_items",
                "description": "Create or update associations between incidents/problems and configuration items. Links incidents or problems to the CIs they affect or are related to. Enforces unique constraints to prevent duplicate associations.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to add a new association, 'update' to modify an existing association."
                        },
                        "entity_type": {
                            "type": "string",
                            "description": "Type of association to manage: 'incident_ci' for incident-CI associations, 'problem_ci' for problem-CI associations.",
                            "enum": ["incident_ci", "problem_ci"]
                        },
                        "association_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating or updating an association.",
                            "properties": {
                                "incident_id": {
                                    "type": "string",
                                    "description": "The ID of the incident (required for create when entity_type is 'incident_ci', cannot be empty). Must refer to an existing incident. Updatable."
                                },
                                "problem_id": {
                                    "type": "string",
                                    "description": "The ID of the problem (required for create when entity_type is 'problem_ci', cannot be empty). Must refer to an existing problem. Updatable."
                                },
                                "ci_id": {
                                    "type": "string",
                                    "description": "The ID of the configuration item (required for create, cannot be empty). Must refer to an existing CI. Updatable."
                                }
                            }
                        },
                        "association_id": {
                            "type": "string",
                            "description": "The unique identifier of the association to update. Required for 'update' action only."
                        }
                    },
                    "required": ["action", "entity_type"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageApprovalRequests(Tool):
    """
    Create and update approval requests for escalations, bridges, changes, rollbacks, RCAs, and incident closures.
    """
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        approval_id: Optional[str] = None,
        reference_id: Optional[str] = None,
        reference_type: Optional[str] = None,
        requested_by: Optional[str] = None,
        requested_action: Optional[str] = None,
        approver: Optional[str] = None,
        status: Optional[str] = None
    ) -> str:
        """
        Create or update approval request records.

        Actions:
        - create: Create new approval request (requires reference_id, reference_type, requested_by, requested_action, approver)
        - update: Update existing approval request (requires approval_id; optional: status)
        """
        def generate_id(table: Dict[str, Any]) -> str:
            """Generates a new unique ID for a record."""
            if not table:
                return "1"
            return str(max(int(k) for k in table.keys()) + 1)

        timestamp = "2025-10-01T12:00:00"
        approvals = data.get("approval_requests", {})
        users = data.get("users", {})

        valid_reference_types = ["escalation", "bridge", "change", "rollback", "rca", "incident_closure"]
        valid_requested_actions = [
            "create_escalation", "initiate_bridge", "create_change_request",
            "create_rollback_request", "conduct_rca", "close_incident"
        ]
        valid_statuses = ["pending", "approved", "denied"]

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": "Invalid action. Must be 'create' or 'update'"
            })

        if action == "update" and not approval_id:
            return json.dumps({
                "success": False,
                "error": "approval_id is required for update action"
            })

        if action == "create":
            if not all([reference_id, reference_type, requested_by, requested_action, approver]):
                return json.dumps({
                    "success": False,
                    "error": "reference_id, reference_type, requested_by, requested_action, and approver are required for create action"
                })

            # Validate users exist and are active
            for user_id in [requested_by, approver]:
                if user_id not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"User with ID {user_id} not found"
                    })
                if users[user_id]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"User with ID {user_id} is not active"
                    })

            if reference_type not in valid_reference_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid reference_type. Must be one of: {', '.join(valid_reference_types)}"
                })

            # Validate requested_action
            if requested_action not in valid_requested_actions:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid requested_action. Must be one of: {', '.join(valid_requested_actions)}"
                })

            new_id = generate_id(approvals)
            new_approval = {
                "approval_id": new_id,
                "reference_id": reference_id,
                "reference_type": reference_type,
                "requested_by": requested_by,
                "requested_action": requested_action,
                "approver": approver,
                "status": "pending",
                "requested_at": timestamp,
                "responded_at": None
            }
            approvals[new_id] = new_approval

            return json.dumps({
                "success": True,
                "action": "create",
                "approval_id": new_id,
                "approval_data": new_approval
            })

        if action == "update":
            if approval_id not in approvals:
                return json.dumps({
                    "success": False,
                    "error": f"Approval request with ID {approval_id} not found"
                })

            # Validate at least one field is being updated
            if status is None:
                return json.dumps({
                    "success": False,
                    "error": "status must be provided for update"
                })

            existing_approval = approvals[approval_id]

            if status is not None:
                if status not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
                    })
                existing_approval["status"] = status
                if status in ["approved", "denied"]:
                    existing_approval["responded_at"] = timestamp

            return json.dumps({
                "success": True,
                "action": "update",
                "approval_id": approval_id,
                "approval_data": existing_approval
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        """
        Returns comprehensive information about the tool's capabilities, parameters, and data schema.
        """
        return {
            "type": "function",
            "function": {
                "name": "manage_approval_requests",
                "description": "Create/update approval requests for various items requiring approval. Supports escalations, bridges, changes, rollbacks, RCAs, and incident closures. Actions: 'create' (requires reference_id, reference_type, requested_by, requested_action, approver), 'update' (requires approval_id; optional: status).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' or 'update'",
                            "enum": ["create", "update"]
                        },
                        "approval_id": {
                            "type": "string",
                            "description": "Required for update. ID of the approval request to update"
                        },
                        "reference_id": {
                            "type": "string",
                            "description": "Required for create. ID of the item needing approval (e.g., escalation_id, bridge_id, change_id)"
                        },
                        "reference_type": {
                            "type": "string",
                            "description": "Required for create. Type of item requiring approval",
                            "enum": ["escalation", "bridge", "change", "rollback", "rca", "incident_closure"]
                        },
                        "requested_by": {
                            "type": "string",
                            "description": "Required for create. ID of the active user requesting approval"
                        },
                        "requested_action": {
                            "type": "string",
                            "description": "Required for create. Specific action being requested",
                            "enum": ["create_escalation", "initiate_bridge", "create_change_request", "create_rollback_request", "conduct_rca", "close_incident"]
                        },
                        "approver": {
                            "type": "string",
                            "description": "Required for create. ID of the active user who needs to approve"
                        },
                        "status": {
                            "type": "string",
                            "description": "For update only. New status of the approval request",
                            "enum": ["pending", "approved", "denied"]
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageImprovement(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, action: str, improvement_data: Dict[str, Any] = None, rca_id: str = None, review_id: str = None) -> str:
        """
        Create or update root cause analysis records or post incident review records.

        Entity Types:
        - root_cause_analyses
        - post_incident_reviews
        
        Actions:
        - create: Create new RCA or new PIR
        - update: Update existing RCA (requires rca_id and fields to update) or PIR (requires review_id and fields to update)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        def generate_rca_number(rca_id: int) -> str:
            return f"RCA{str(rca_id).zfill(7)}"
        
        if entity_type not in ["root_cause_analyses", "post_incident_reviews"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'root_cause_analyses' or 'post_incident_reviews'"
            })
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })
        
        # get existing data tables
        root_cause_analyses = data.get("root_cause_analyses", {})
        post_incident_reviews = data.get("post_incident_reviews", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        # allowed enums
        valid_methods = ["5_whys", "fishbone", "timeline", "fault_tree", "kepner_tregoe"]
        valid_statuses = ["assigned", "in_progress", "completed", "approved"]
        valid_pir_statuses = ["scheduled", "completed", "cancelled"]

        # valid values
        required_incident_statuses = ["resolved", "closed"]
        required_incident_statuses_pir = ["closed"]
        required_incident_severity = ["P1", "P2"]
        required_user_status = ["active"]
        

        # Handle root_cause_analyses
        if entity_type == "root_cause_analyses":
            # for create action
            if action == "create":
                if not improvement_data:
                    return json.dumps({
                        "success": False,
                        "error": "improvement_data is required for create action"
                    })

                # Validate required fields
                required_fields = ["associated_incident_id", "rca_title", "assigned_to", "due_date", "reported_by"]

                missing_fields = [field for field in required_fields if field not in improvement_data]
                if missing_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Missing required fields for create action: {', '.join(missing_fields)}"
                    })
                
                # Validate non-empty required fields
                for field in required_fields:
                    if not improvement_data[field] or str(improvement_data[field]).strip() == "":
                        return json.dumps({
                            "success": False,
                            "error": f"Field '{field}' cannot be empty"
                        })
                
                # Allowed fields
                allowed_fields = ["associated_incident_id", "rca_title", "assigned_to", "due_date", "reported_by", "analysis_method", "root_cause_summary", "status"]

                rca_fields = [field for field in improvement_data if field not in allowed_fields]
                if rca_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Unrecognized fields in improvement_data: {', '.join(rca_fields)}"
                    })
                
                # Validate that associated_incident exists
                if str(improvement_data["associated_incident_id"]) not in incidents:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Incident not found"
                    })
                
                # Validate that associated_incident status is resolved or closed
                incident_status = incidents[str(improvement_data["associated_incident_id"])]["status"]
                if incident_status not in required_incident_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Incident status must be one of: {', '.join(required_incident_statuses)}"
                    })
                
                # Validate that associated_incident severity is P1 or P2
                incident_severity = incidents[str(improvement_data["associated_incident_id"])]["severity"]
                if incident_severity not in required_incident_severity:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Incident severity must be one of: {', '.join(required_incident_severity)}"
                    })
                
                # Validate that assigned_to user exists
                if str(improvement_data["assigned_to"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User assigned_to not found"
                    })
                
                # Validate that assigned_to user is active
                if users[str(improvement_data["assigned_to"])]["status"] not in required_user_status: 
                    return json.dumps({ 
                        "success": False, 
                        "error": "Halt: User assigned_to must be active" 
                    })
                
                # Validate that reported_by user exists
                if str(improvement_data["reported_by"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User reported_by not found"
                    })
                
                # Validate that reported_by user is active
                if users[str(improvement_data["reported_by"])]["status"] not in required_user_status: 
                    return json.dumps({ 
                        "success": False, 
                        "error": "Halt: User reported_by must be active" 
                    })
                
                # Validate analysis_method if provided
                analysis_method = improvement_data.get("analysis_method")
                if analysis_method and analysis_method not in valid_methods:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid analysis method - must be one of: {', '.join(valid_methods)}"
                    })
                
                # Validate optional fields are not empty if provided
                optional_fields = ["root_cause_summary"]
                for field in optional_fields:
                    if field in improvement_data and improvement_data[field] is not None:
                        if str(improvement_data[field]).strip() == "":
                            return json.dumps({
                                "success": False,
                                "error": f"Field '{field}' cannot be empty if provided"
                            })
                
                # Validate status
                status = improvement_data.get("status", "assigned")
                if status not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid status - must be one of: {', '.join(valid_statuses)}"
                    })
                
                # Generate new RCA ID
                new_rca_id = generate_id(root_cause_analyses)
                rca_number = generate_rca_number(new_rca_id)
                
                # Create new RCA record
                new_rca = {
                    "rca_id": str(new_rca_id),
                    "rca_number": str(rca_number),
                    "associated_incident_id": str(improvement_data["associated_incident_id"]),
                    "rca_title": improvement_data["rca_title"],
                    "assigned_to": str(improvement_data["assigned_to"]),
                    "due_date": improvement_data["due_date"],
                    "analysis_method": analysis_method if analysis_method else None,
                    "root_cause_summary": improvement_data["root_cause_summary"] if improvement_data.get("root_cause_summary") not in (None, "") else None,
                    "status": status,
                    "completed_at": None,
                    "approved_by": None,
                    "reported_by": str(improvement_data["reported_by"]),
                    "created_at": "2025-10-07T00:00:00",
                    "updated_at": "2025-10-07T00:00:00"
                }
                
                root_cause_analyses[str(new_rca_id)] = new_rca
                
                return json.dumps({
                    "success": True,
                    "action": "create",
                    "rca_id": str(new_rca_id),
                    "message": f"RCA {new_rca_id} created successfully",
                    "improvement_data": new_rca
                })
            
            # for update action
            elif action == "update":
                if not rca_id:
                    return json.dumps({
                        "success": False,
                        "error": "rca_id is required for update action"
                    })
                
                if str(rca_id) not in root_cause_analyses:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: RCA not found"
                    })
                
                if not improvement_data:
                    return json.dumps({
                        "success": False,
                        "error": "improvement_data is required for update action"
                    })
                
                # Validate at least one optional field is provided
                update_fields = ["rca_title", "assigned_to", "analysis_method", "root_cause_summary", "status", "due_date", "completed_at", "approved_by"]

                provided_fields = [field for field in update_fields if field in improvement_data]
                if not provided_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"At least one optional field must be provided for updates {', '.join(update_fields)}"
                    })
                
                # Validate only allowed fields for updates
                invalid_fields = [field for field in improvement_data.keys() if field not in update_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields for RCA updating: {', '.join(invalid_fields)}"
                    })
                
                # Validate non-empty fields
                for field, value in improvement_data.items():
                    if field not in ["analysis_method", "root_cause_summary", "completed_at", "approved_by"] and value is not None and str(value).strip() == "":
                        return json.dumps({
                            "success": False,
                            "error": f"Field '{field}' cannot be empty"
                        })
                    elif field in ["analysis_method", "root_cause_summary", "completed_at", "approved_by"] and value is not None and str(value).strip() == "":
                        return json.dumps({
                            "success": False,
                            "error": f"Field '{field}' cannot be empty if provided"
                        })
                    
                if "assigned_to" in improvement_data:
                    # Validate that assigned_to user exists if provided
                    if str(improvement_data["assigned_to"]) not in users:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: User assigned_to not found"
                        })

                    # Validate that assigned_to user is active if provided
                    if users[str(improvement_data["assigned_to"])]["status"] not in required_user_status: 
                        return json.dumps({ 
                            "success": False, 
                            "error": "Halt: User assigned_to must be active" 
                        })
                    
                # Validate analysis_method if provided
                analysis_method = improvement_data.get("analysis_method")
                if analysis_method and analysis_method not in valid_methods:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid analysis method - must be one of: {', '.join(valid_methods)}"
                    })
                
                # Validate status if provided
                status = improvement_data.get("status")
                if status and status not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid status - must be one of: {', '.join(valid_statuses)}"
                    })
                
                approved_by = improvement_data.get("approved_by")
                if approved_by:  
                    # Validate that approved_by user exists if provided
                    if str(approved_by) not in users:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: User approved_by not found"
                        })
                
                    # Validate that approved_by user is active if provided
                    if users[str(approved_by)]["status"] not in required_user_status: 
                        return json.dumps({ 
                            "success": False, 
                            "error": "Halt: User approved_by must be active" 
                        })
                
                # If status is approved, approved_by is required
                if status == "approved" and not approved_by:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: approved_by is required when status is approved"
                    })
                
                # Get current RCA record
                current_rca = root_cause_analyses[str(rca_id)]
                # Update RCA record with modified information
                updated_rca = current_rca.copy()
                for key, value in improvement_data.items():
                    if key in ["analysis_method", "root_cause_summary", "completed_at", "approved_by"]:
                        updated_rca[key] = str(value) if value not in (None, "") else None
                    elif key == "assigned_to":
                        updated_rca[key] = str(value)
                    else:
                        updated_rca[key] = value
                
                updated_rca["updated_at"] = "2025-10-07T00:00:00"

                root_cause_analyses[str(rca_id)] = updated_rca
                
                return json.dumps({
                    "success": True,
                    "action": "update",
                    "rca_id": str(rca_id),
                    "message": f"RCA {rca_id} updated successfully",
                    "improvement_data": updated_rca
                })
        
        # Handle post_incident_reviews
        elif entity_type == "post_incident_reviews":
            # for create action
            if action == "create":
                if not improvement_data:
                    return json.dumps({
                        "success": False,
                        "error": "improvement_data is required for create action"
                    })
                
                # Validate required fields for create
                required_fields = ["incident_id", "scheduled_date", "facilitator", "review_notes", "lessons_learned", "action_items", "created_by"]
                
                missing_fields = [field for field in required_fields if field not in improvement_data]
                if missing_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Missing required fields for create action: {', '.join(missing_fields)}"
                    })
                
                # Validate non-empty required fields
                for field in required_fields:
                    if not improvement_data[field] or str(improvement_data[field]).strip() == "":
                        return json.dumps({
                            "success": False,
                            "error": f"Field '{field}' cannot be empty"
                        })
                
                # Allowed fields
                allowed_fields = ["incident_id", "scheduled_date", "facilitator", "review_notes", "lessons_learned", "action_items", "status", "created_by"]

                pir_fields = [field for field in improvement_data if field not in allowed_fields]
                if pir_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Unrecognized fields in improvement_data: {', '.join(pir_fields)}"
                    })
                
                # Validate that incident exists
                if str(improvement_data["incident_id"]) not in incidents:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: Incident not found"
                        })
                
                # Validate that incident status is closed
                incident_status = incidents[str(improvement_data["incident_id"])]["status"]
                if incident_status not in required_incident_statuses_pir:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Incident status must be closed"
                    })
                
                # Validate facilitator user exists
                if str(improvement_data["facilitator"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User 'facilitator' not found"
                    })
                
                # Validate that facilitator user is active
                if users[str(improvement_data["facilitator"])]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User 'facilitator' must be active"
                    })
                
                # Validate status enum
                status = improvement_data.get("status", "scheduled")
                if status not in valid_pir_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid pir status - must be one of: {', '.join(valid_pir_statuses)}"
                    })
                
                # Validate created_by user exists
                if str(improvement_data["created_by"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User 'created_by' not found"
                    })
                
                # Validate that created_by user is active
                if users[str(improvement_data["created_by"])]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User 'created_by' must be active"
                    })
                
                # Generate new PIR ID
                new_pir_id = generate_id(post_incident_reviews)

                # Create new pir record
                new_pir = {
                    "review_id": str(new_pir_id),
                    "incident_id": str(improvement_data["incident_id"]),
                    "scheduled_date": improvement_data["scheduled_date"],
                    "facilitator": str(improvement_data["facilitator"]),
                    "review_notes": improvement_data["review_notes"],
                    "lessons_learned": improvement_data["lessons_learned"],
                    "action_items": improvement_data["action_items"],
                    "status": status,
                    "created_by": str(improvement_data["created_by"]),
                    "created_at": "2025-10-07T00:00:00"
                }

                post_incident_reviews[str(new_pir_id)] = new_pir

                return json.dumps({
                    "success": True,
                    "action": "create",
                    "review_id": str(new_pir_id),
                    "message": f"Post incident review {new_pir_id} created successfully",
                    "improvement_data": new_pir
                })
            
            # for update action
            elif action == "update":
                if not review_id:
                    return json.dumps({
                        "success": False,
                        "error": "review_id is required for update action"
                    })
                
                if str(review_id) not in post_incident_reviews:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Post incident review not found"
                    })
                
                if not improvement_data:
                    return json.dumps({
                        "success": False,
                        "error": "improvement_data is required for update action"
                    })
                
                # Validate at least one optional field is provided
                update_fields = ["incident_id", "scheduled_date", "facilitator", "review_notes", "lessons_learned", "action_items", "status"]

                provided_fields = [field for field in update_fields if field in improvement_data]
                if not provided_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"At least one optional field must be provided for updates {', '.join(update_fields)}"
                    })
                
                # Validate only allowed fields for updates
                invalid_fields = [field for field in improvement_data.keys() if field not in update_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields for pir updating: {', '.join(invalid_fields)}"
                    })
                
                # Validate non-empty fields
                for field, value in improvement_data.items():
                    if value is not None and str(value).strip() == "":
                        return json.dumps({
                            "success": False,
                            "error": f"Field '{field}' cannot be empty"
                        })
                    
                if "facilitator" in improvement_data:
                    if str(improvement_data["facilitator"]) not in users:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: User 'facilitator' not found"
                        })
                    
                    if users[str(improvement_data["facilitator"])]["status"] != "active":
                        return json.dumps({
                            "success": False,
                            "error": "Halt: User 'facilitator' must be active"
                        })
                    
                if "status" in improvement_data:
                    if improvement_data["status"] not in valid_pir_statuses:
                        return json.dumps({
                            "success": False,
                            "error": f"Halt: Invalid status. Must be one of: {', '.join(valid_pir_statuses)}"
                        })
                    
                # Get current PIR record
                current_pir = post_incident_reviews[str(review_id)]
                # Update PIR record with modified information
                updated_pir = current_pir.copy()
                for key, value in improvement_data.items():
                    if key == "facilitator":
                        updated_pir[key] = str(value)
                    else:
                        updated_pir[key] = value

                post_incident_reviews[str(review_id)] = updated_pir

                return json.dumps({
                    "success": True,
                    "action": "update",
                    "review_id": str(review_id),
                    "message": f"Post incident review {review_id} updated successfully",
                    "improvement_data": updated_pir
                })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_improvement",
                "description": "Create or update root cause analysis or post incident review records in the incident management system. For root cause analyses, manages RCA workflow including assignment, analysis methods, and approval processes. For post incident reviews, handles review scheduling, facilitation, and documentation of lessons learned.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Entity type to manage: 'root_cause_analyses' for root cause analyses, 'post_incident_reviews' for post incident reviews"
                        },
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to create new record, 'update' to modify existing record"
                        },
                        "improvement_data": {
                            "type": "object",
                            "description": "Improvement data object containing fields for creating or updating RCA or PIR records",
                            "properties": {
                                "associated_incident_id": {
                                    "type": "string",
                                    "description": "Related incident identifier for RCA (required for RCA create, cannot be empty, must exist and be resolved/closed with P1/P2 severity)"
                                },
                                "rca_title": {
                                    "type": "string",
                                    "description": "Title of the root cause analysis (required for RCA create, cannot be empty)"
                                },
                                "assigned_to": {
                                    "type": "string",
                                    "description": "User identifier assigned to conduct the analysis (required for RCA create, cannot be empty, must be active user)"
                                },
                                "due_date": {
                                    "type": "string",
                                    "description": "Date by which analysis should be completed (required for RCA create, cannot be empty)"
                                },
                                "reported_by": {
                                    "type": "string",
                                    "description": "User identifier who reported the need for RCA (required for RCA create, cannot be empty, must be active user)"
                                },
                                "analysis_method": {
                                    "type": "string",
                                    "description": "Analysis methodology used (optional for RCA). Must be one of: 5_whys, fishbone, timeline, fault_tree, kepner_tregoe"
                                },
                                "root_cause_summary": {
                                    "type": "string",
                                    "description": "Summary of identified root cause (optional for RCA, cannot be empty if provided)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status (optional, defaults based on entity type). For RCA: assigned, in_progress, completed, approved. For PIR: scheduled, completed, cancelled"
                                },
                                "completed_at": {
                                    "type": "string",
                                    "description": "Timestamp when analysis was completed (optional for RCA, cannot be empty if provided)"
                                },
                                "approved_by": {
                                    "type": "string",
                                    "description": "User identifier who approved the analysis (optional for RCA, required when status is approved, must be active user)"
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "Related incident identifier for PIR (required for PIR create, cannot be empty, must exist and be closed)"
                                },
                                "scheduled_date": {
                                    "type": "string",
                                    "description": "Date for the post-incident review (required for PIR create, cannot be empty)"
                                },
                                "facilitator": {
                                    "type": "string",
                                    "description": "User who will facilitate the review (required for PIR create, cannot be empty, must be active user)"
                                },
                                "review_notes": {
                                    "type": "string",
                                    "description": "Notes for the review (required for PIR create, cannot be empty)"
                                },
                                "lessons_learned": {
                                    "type": "string",
                                    "description": "Lessons learned from the incident (required for PIR create, cannot be empty)"
                                },
                                "action_items": {
                                    "type": "string",
                                    "description": "Action items identified (required for PIR create, cannot be empty)"
                                },
                                "created_by": {
                                    "type": "string",
                                    "description": "User identifier who created the post incident review (required for PIR create, cannot be empty, must be active user)"
                                }
                            }
                        },
                        "rca_id": {
                            "type": "string",
                            "description": "Unique identifier of the RCA. Required for RCA update action only."
                        },
                        "review_id": {
                            "type": "string",
                            "description": "Unique identifier of the PIR. Required for PIR update action only."
                        }
                    },
                    "required": ["entity_type", "action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageAttachments(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        attachment_data: Optional[Dict[str, Any]] = None,
        attachment_id: Optional[str] = None # Although attachments are typically immutable, including for consistency if a delete action were added later.
    ) -> str:
        """
        Create new attachment records.

        Actions:
        - create: Create a new attachment record (requires attachment_data)
        """

        def generate_id(table: Dict[str, Any], prefix: str) -> str:
            if not table:
                return f"{prefix}1"
            max_id = 0
            for k in table.keys():
                try:
                    num = int(k[len(prefix):])
                    if num > max_id:
                        max_id = num
                except ValueError:
                    continue
            return f"{prefix}{max_id + 1}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create"]: # Attachments are typically created and then immutable, not updated.
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        attachments = data.get("attachments", {})
        users = data.get("users", {})
        
        # Tables that can be referenced by attachments
        reference_tables = {
            "incident": data.get("incidents", {}),
            "change": data.get("change_requests", {}),
            "rca": data.get("root_cause_analyses", {}),
            "report": data.get("incident_reports", {}),
            "pir": data.get("post_incident_reviews", {}),
            "communication": data.get("communications", {}),
            "work_order": data.get("work_orders", {}),
            "problem": data.get("problem_tickets", {})
        }

        # Define valid enums based on DBML schema
        valid_reference_types = [
            "incident", "change", "rca", "report", "pir", "communication", "work_order", "problem"
        ]

        if action == "create":
            if not attachment_data:
                return json.dumps({
                    "success": False,
                    "error": "attachment_data is required for create action"
                })

            # Validate required fields as per DBML
            required_fields = [
                "reference_id", "reference_type", "file_name", "file_url",
                "file_type", "file_size_bytes", "uploaded_by"
            ]
            missing_fields = [field for field in required_fields if field not in attachment_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if (isinstance(attachment_data[field], str) and str(attachment_data[field]).strip() == "") or attachment_data[field] is None:
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty or null"
                    })

            # Validate reference_type enum
            reference_type = attachment_data["reference_type"]
            if reference_type not in valid_reference_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid reference_type '{reference_type}'. Must be one of: {', '.join(valid_reference_types)}"
                })

            # Validate uploaded_by FK
            uploaded_by = str(attachment_data["uploaded_by"]).strip().strip('"')
            if uploaded_by not in users:
                return json.dumps({
                    "success": False,
                    "error": f"Uploaded by user '{uploaded_by}' not found"
                })
            if users[uploaded_by]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"Uploaded by user '{uploaded_by}' is not active"
                })

            # Validate reference_id FK based on reference_type
            reference_id = str(attachment_data["reference_id"]).strip().strip('"')
            target_table = reference_tables.get(reference_type)
            if not target_table:
                return json.dumps({
                    "success": False,
                    "error": f"Reference type '{reference_type}' does not map to a known table for validation."
                })
            if reference_id not in target_table:
                return json.dumps({
                    "success": False,
                    "error": f"Reference ID '{reference_id}' not found in '{reference_type}' table."
                })
            
            # Validate file_size_bytes is a positive integer
            file_size_bytes = attachment_data["file_size_bytes"]
            if not isinstance(file_size_bytes, int) or file_size_bytes < 0:
                return json.dumps({
                    "success": False,
                    "error": f"file_size_bytes must be a non-negative integer."
                })

            new_id = generate_id(attachments, "ATT")
            new_attachment = {
                "attachment_id": new_id,
                "reference_id": reference_id,
                "reference_type": reference_type,
                "file_name": attachment_data["file_name"],
                "file_url": attachment_data["file_url"],
                "file_type": attachment_data["file_type"],
                "file_size_bytes": file_size_bytes,
                "uploaded_by": uploaded_by,
                "uploaded_at": timestamp
            }
            attachments[new_id] = new_attachment
            return json.dumps({
                "success": True,
                "action": "create",
                "attachment_id": new_id,
                "attachment_data": new_attachment
            })
        
        # No 'update' action for attachments as per schema (no updated_at field, implies immutability)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_attachments",
                "description": "Create new attachment records in the system. Attachments are associated with various record types like incidents, changes, or problem tickets.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to add a new attachment."
                        },
                        "attachment_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating an attachment.",
                            "properties": {
                                "reference_id": {
                                    "type": "string",
                                    "description": "The ID of the record this attachment belongs to (e.g., incident_id, change_id). Required for create, cannot be empty. Must refer to an existing record of the specified reference_type."
                                },
                                "reference_type": {
                                    "type": "string",
                                    "description": "The type of record this attachment is linked to (e.g., incident, change, rca). Required for create. Must be one of: incident, change, rca, report, pir, communication, work_order, problem.",
                                    "enum": ["incident", "change", "rca", "report", "pir", "communication", "work_order", "problem"]
                                },
                                "file_name": {
                                    "type": "string",
                                    "description": "The name of the attached file (e.g., 'screenshot.png'). Required for create, cannot be empty."
                                },
                                "file_url": {
                                    "type": "string",
                                    "description": "The URL or path where the file is stored (e.g., 'https://storage.example.com/files/abc.png'). Required for create, cannot be empty."
                                },
                                "file_type": {
                                    "type": "string",
                                    "description": "The MIME type or extension of the file (e.g., 'image/png', 'application/pdf'). Required for create, cannot be empty."
                                },
                                "file_size_bytes": {
                                    "type": "integer",
                                    "description": "The size of the file in bytes. Required for create, must be a non-negative integer."
                                },
                                "uploaded_by": {
                                    "type": "string",
                                    "description": "The user ID of the person who uploaded the attachment. Required for create. Must refer to an existing active user."
                                }
                            }
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverAudit(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover audit entities (audit_trails). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - audit_trails: Audit Trail records
        """
        if entity_type not in ["audit_trails"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'audit_trails'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "audit_id": entity_id})
            else:
                results.append({**entity_data, "audit_id": entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_audit",
                "description": "Discover audit entities (audit trails). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'audit_trails'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "audit_id": {
                                    "type": "string",
                                    "description": "Audit trail ID"
                                },
                                "reference_id": {
                                    "type": "string",
                                    "description": "ID of the record that was changed"
                                },
                                "reference_type": {
                                    "type": "string",
                                    "description": "Type of record: 'user', 'client', 'sla', 'ci', 'incident', 'escalation', 'bridge', 'change', 'rollback', 'work_order', 'problem', 'incident_ci', 'problem_ci', 'client_ci'"
                                },
                                "action": {
                                    "type": "string",
                                    "description": "Action performed: 'create', 'update'"
                                },
                                "user_id": {
                                    "type": "string",
                                    "description": "User ID who performed the action"
                                },
                                "field_name": {
                                    "type": "string",
                                    "description": "Name of the field that was changed"
                                },
                                "old_value": {
                                    "type": "string",
                                    "description": "Previous value before change"
                                },
                                "new_value": {
                                    "type": "string",
                                    "description": "New value after change"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverContracts(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover contract entities (sla_agreements). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - sla_agreements: SLA Agreement records
        """
        if entity_type not in ["sla_agreements"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'sla_agreements'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "sla_id": entity_id})
            else:
                results.append({**entity_data, "sla_id": entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_contracts",
                "description": "Discover contract entities (SLA agreements). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'sla_agreements'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "sla_id": {
                                    "type": "string",
                                    "description": "SLA agreement ID"
                                },
                                "client_id": {
                                    "type": "string",
                                    "description": "Client ID"
                                },
                                "tier": {
                                    "type": "string",
                                    "description": "SLA tier: 'premium', 'standard', 'basic'"
                                },
                                "support_coverage": {
                                    "type": "string",
                                    "description": "Support coverage: '24x7', 'business_hours', 'on_call'"
                                },
                                "effective_date": {
                                    "type": "string",
                                    "description": "Effective date in YYYY-MM-DD format"
                                },
                                "expiration_date": {
                                    "type": "string",
                                    "description": "Expiration date in YYYY-MM-DD format"
                                },
                                "created_by": {
                                    "type": "string",
                                    "description": "User ID who created the SLA"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status: 'active', 'inactive', 'expired'"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                },
                                "updated_at": {
                                    "type": "string",
                                    "description": "Update timestamp in YYYY-MM-DD format"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverParties(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover party entities (clients, users). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - clients: Client records
        - users: User records
        """
        if entity_type not in ["clients", "users"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'clients' or 'users'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            # Create a copy of the entity data to avoid modifying the original
            result_data = entity_data.copy()
            
            # Remove the 'role' field from users if it exists
            if entity_type == "users" and "role" in result_data:
                del result_data["role"]
            
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    # Check against original entity_data for filtering (including role)
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    if entity_type == "clients":
                        id_field = "client_id"
                    else:  # users
                        id_field = "user_id"
                    results.append({**result_data, id_field: entity_id})
            else:
                if entity_type == "clients":
                    id_field = "client_id"
                else:  # users
                    id_field = "user_id"
                results.append({**result_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_parties",
                "description": "Discover party entities (clients, users). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results. Note: The 'role' field is excluded from user results but can still be used for filtering.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'clients' or 'users'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "client_id": {
                                    "type": "string",
                                    "description": "Client ID (for clients)"
                                },
                                "client_name": {
                                    "type": "string",
                                    "description": "Client name (for clients)"
                                },
                                "registration_number": {
                                    "type": "string",
                                    "description": "Registration number (for clients)"
                                },
                                "company_type": {
                                    "type": "string",
                                    "description": "Company type: 'enterprise', 'mid_market', 'smb', 'startup' (for clients)"
                                },
                                "primary_address": {
                                    "type": "string",
                                    "description": "Primary address (for clients)"
                                },
                                "support_coverage": {
                                    "type": "string",
                                    "description": "Support coverage: '24x7', 'business_hours', 'on_call' (for clients)"
                                },
                                "preferred_communication": {
                                    "type": "string",
                                    "description": "Preferred communication: 'email', 'portal', 'phone', 'slack' (for clients)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status: 'active', 'inactive'"
                                },
                                "user_id": {
                                    "type": "string",
                                    "description": "User ID (for users)"
                                },
                                "first_name": {
                                    "type": "string",
                                    "description": "First name (for users)"
                                },
                                "last_name": {
                                    "type": "string",
                                    "description": "Last name (for users)"
                                },
                                "email": {
                                    "type": "string",
                                    "description": "Email address (for users)"
                                },
                                "role": {
                                    "type": "string",
                                    "description": "User role: 'incident_manager', 'technical_support', 'account_manager', 'executive', 'system_administrator', 'client_contact' (for users - can be used for filtering but won't appear in results)"
                                },
                                "timezone": {
                                    "type": "string",
                                    "description": "Timezone (for users)"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                },
                                "updated_at": {
                                    "type": "string",
                                    "description": "Update timestamp in YYYY-MM-DD format"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverChangeControl(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover change control entities (change_requests, rollback_requests). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - change_requests: Change Request records
        - rollback_requests: Rollback Request records
        """
        if entity_type not in ["change_requests", "rollback_requests"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'change_requests' or 'rollback_requests'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    if entity_type == "change_requests":
                        id_field = "change_id"
                    else:  # rollback_requests
                        id_field = "rollback_id"
                    results.append({**entity_data, id_field: entity_id})
            else:
                if entity_type == "change_requests":
                    id_field = "change_id"
                else:  # rollback_requests
                    id_field = "rollback_id"
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_change_control",
                "description": "Discover change control entities (change requests, rollback requests). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'change_requests' or 'rollback_requests'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "change_id": {
                                    "type": "string",
                                    "description": "Change request ID (for change_requests)"
                                },
                                "change_number": {
                                    "type": "string",
                                    "description": "Change request number, e.g., CHG0001234 (for change_requests)"
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "Associated incident ID"
                                },
                                "problem_ticket_id": {
                                    "type": "string",
                                    "description": "Associated problem ticket ID (for change_requests)"
                                },
                                "title": {
                                    "type": "string",
                                    "description": "Change/rollback title"
                                },
                                "description": {
                                    "type": "string",
                                    "description": "Change description (for change_requests)"
                                },
                                "change_type": {
                                    "type": "string",
                                    "description": "Type of change: 'standard', 'normal', 'emergency' (for change_requests)"
                                },
                                "risk_level": {
                                    "type": "string",
                                    "description": "Risk level of change: 'low', 'medium', 'high', 'critical' (for change_requests)"
                                },
                                "requested_by": {
                                    "type": "string",
                                    "description": "User ID who requested the change/rollback"
                                },
                                "approved_by": {
                                    "type": "string",
                                    "description": "User ID who approved the change (for change_requests)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status of the change/rollback"
                                },
                                "implementation_date": {
                                    "type": "string",
                                    "description": "Implementation date in YYYY-MM-DD format (for change_requests)"
                                },
                                "rollback_id": {
                                    "type": "string",
                                    "description": "Rollback request ID (for rollback_requests)"
                                },
                                "rollback_number": {
                                    "type": "string",
                                    "description": "Rollback request number, e.g., RBK0001234 (for rollback_requests)"
                                },
                                "rollback_reason": {
                                    "type": "string",
                                    "description": "Reason for rollback (for rollback_requests)"
                                },
                                "executed_at": {
                                    "type": "string",
                                    "description": "Execution timestamp in YYYY-MM-DD format (for rollback_requests)"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                },
                                "updated_at": {
                                    "type": "string",
                                    "description": "Update timestamp in YYYY-MM-DD format (for change_requests)"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageClients(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        client_data: Optional[Dict[str, Any]] = None,
        client_id: Optional[str] = None
    ) -> str:
        """
        Create or update client records.

        Actions:
        - create: Create a new client record (requires client_data)
        - update: Update an existing client record (requires client_id and client_data)
        """

        def generate_id(table: Dict[str, Any]) -> str:
            if not table:
                return "CLI1"
            max_id = 0
            for k in table.keys():
                try:
                    num = int(k[3:]) # Assuming format 'CLIX'
                    if num > max_id:
                        max_id = num
                except ValueError:
                    continue
            return f"CLI{max_id + 1}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        clients = data.get("clients", {})
        # No 'users' needed for primary_contact_id validation as per this schema for clients table

        # Define valid enums based on DBML schema
        valid_company_types = ["enterprise", "mid_market", "smb", "startup"]
        valid_support_coverages = ["24x7", "business_hours", "on_call"]
        valid_preferred_communications = ["email", "portal", "phone", "slack"]
        valid_statuses = ["active", "inactive"]

        if action == "create":
            if not client_data:
                return json.dumps({
                    "success": False,
                    "error": "client_data is required for create action"
                })

            # Validate required fields as per DBML
            # client_name, company_type, support_coverage, preferred_communication are NOT NULL
            required_fields = ["client_name", "company_type", "support_coverage", "preferred_communication"]
            missing_fields = [field for field in required_fields if field not in client_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not client_data[field] or (isinstance(client_data[field], str) and str(client_data[field]).strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate client_name uniqueness
            client_name = str(client_data["client_name"]).strip()
            for client in clients.values():
                if client["client_name"].lower() == client_name.lower():
                    return json.dumps({
                        "success": False,
                        "error": f"Client with name '{client_name}' already exists."
                    })

            # Validate registration_number uniqueness if provided
            registration_number = client_data.get("registration_number")
            if registration_number:
                registration_number = str(registration_number).strip()
                for client in clients.values():
                    if client.get("registration_number") and client["registration_number"].lower() == registration_number.lower():
                        return json.dumps({
                            "success": False,
                            "error": f"Client with registration number '{registration_number}' already exists."
                        })
            
            # Validate enums
            if client_data["company_type"] not in valid_company_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid company_type '{client_data['company_type']}'. Must be one of: {', '.join(valid_company_types)}"
                })
            if client_data["support_coverage"] not in valid_support_coverages:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid support_coverage '{client_data['support_coverage']}'. Must be one of: {', '.join(valid_support_coverages)}"
                })
            if client_data["preferred_communication"] not in valid_preferred_communications:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid preferred_communication '{client_data['preferred_communication']}'. Must be one of: {', '.join(valid_preferred_communications)}"
                })
            
            # Status is 'active' by default, if provided, must be valid
            status = client_data.get("status", "active")
            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{status}'. Must be one of: {', '.join(valid_statuses)}"
                })

            new_id = generate_id(clients)
            new_client = {
                "client_id": new_id,
                "client_name": client_name,
                "registration_number": registration_number if registration_number else None, # Nullable
                "company_type": client_data["company_type"],
                "primary_address": client_data.get("primary_address"), # Nullable
                "support_coverage": client_data["support_coverage"],
                "preferred_communication": client_data["preferred_communication"],
                "status": status,
                "created_at": timestamp,
                "updated_at": timestamp
            }
            clients[new_id] = new_client
            return json.dumps({
                "success": True,
                "action": "create",
                "client_id": new_id,
                "client_data": new_client
            })

        elif action == "update":
            if not client_id:
                return json.dumps({
                    "success": False,
                    "error": "client_id is required for update action"
                })
            client_id = str(client_id).strip().strip('"')
            if client_id not in clients:
                return json.dumps({
                    "success": False,
                    "error": f"Client '{client_id}' not found"
                })

            if not client_data:
                return json.dumps({
                    "success": False,
                    "error": "client_data is required for update action"
                })

            # Allowed fields for update
            allowed_fields = [
                "client_name", "registration_number", "company_type", "primary_address",
                "support_coverage", "preferred_communication", "status"
            ]
            invalid_fields = [field for field in client_data if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for update: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields (if provided, they shouldn't be empty strings, but nullable fields can be None)
            # Note: company_type, support_coverage, preferred_communication, status are NOT NULL, so cannot be empty string/None if provided for update
            nullable_fields = ["registration_number", "primary_address"]
            for field, value in client_data.items():
                if field not in nullable_fields and (value is None or (isinstance(value, str) and value.strip() == "")):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
                elif field in nullable_fields and (isinstance(value, str) and value.strip() == ""):
                    client_data[field] = None # Treat empty string as null for nullable fields

            # Validate client_name uniqueness if updated
            if "client_name" in client_data:
                updated_client_name = str(client_data["client_name"]).strip()
                for existing_client_id, client in clients.items():
                    if existing_client_id != client_id and client["client_name"].lower() == updated_client_name.lower():
                        return json.dumps({
                            "success": False,
                            "error": f"Client with name '{updated_client_name}' already exists."
                        })
                client_data["client_name"] = updated_client_name

            # Validate registration_number uniqueness if updated
            if "registration_number" in client_data and client_data["registration_number"] is not None:
                updated_reg_num = str(client_data["registration_number"]).strip()
                for existing_client_id, client in clients.items():
                    if existing_client_id != client_id and client.get("registration_number") and client["registration_number"].lower() == updated_reg_num.lower():
                        return json.dumps({
                            "success": False,
                            "error": f"Client with registration number '{updated_reg_num}' already exists."
                        })
                client_data["registration_number"] = updated_reg_num
            elif "registration_number" in client_data and client_data["registration_number"] is None:
                client_data["registration_number"] = None # Allow setting to null

            # Validate enums if provided
            if "company_type" in client_data and client_data["company_type"] not in valid_company_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid company_type '{client_data['company_type']}'. Must be one of: {', '.join(valid_company_types)}"
                })
            if "support_coverage" in client_data and client_data["support_coverage"] not in valid_support_coverages:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid support_coverage '{client_data['support_coverage']}'. Must be one of: {', '.join(valid_support_coverages)}"
                })
            if "preferred_communication" in client_data and client_data["preferred_communication"] not in valid_preferred_communications:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid preferred_communication '{client_data['preferred_communication']}'. Must be one of: {', '.join(valid_preferred_communications)}"
                })
            if "status" in client_data and client_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{client_data['status']}'. Must be one of: {', '.join(valid_statuses)}"
                })

            updated_client = clients[client_id].copy()
            for key, value in client_data.items():
                updated_client[key] = value
            updated_client["updated_at"] = timestamp
            clients[client_id] = updated_client
            return json.dumps({
                "success": True,
                "action": "update",
                "client_id": client_id,
                "client_data": updated_client
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_clients",
                "description": "Create or update client records in the system. This tool allows for managing client details, including their company type, support coverage, and communication preferences.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to add a new client, 'update' to modify an existing client."
                        },
                        "client_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating or updating a client.",
                            "properties": {
                                "client_name": {
                                    "type": "string",
                                    "description": "The unique name of the client (required for create, must be unique, cannot be empty). Updatable."
                                },
                                "registration_number": {
                                    "type": "string",
                                    "description": "The client's unique registration number (optional, must be unique if provided). Updatable, can be set to null."
                                },
                                "company_type": {
                                    "type": "string",
                                    "description": "The type of company (required for create). Must be one of: enterprise, mid_market, smb, startup. Updatable.",
                                    "enum": ["enterprise", "mid_market", "smb", "startup"]
                                },
                                "primary_address": {
                                    "type": "string",
                                    "description": "The client's primary physical address (optional). Updatable, can be set to null."
                                },
                                "support_coverage": {
                                    "type": "string",
                                    "description": "The level of support coverage for the client (required for create). Must be one of: 24x7, business_hours, on_call. Updatable.",
                                    "enum": ["24x7", "business_hours", "on_call"]
                                },
                                "preferred_communication": {
                                    "type": "string",
                                    "description": "The client's preferred method of communication (required for create). Must be one of: email, portal, phone, slack. Updatable.",
                                    "enum": ["email", "portal", "phone", "slack"]
                                },
                                "status": {
                                    "type": "string",
                                    "description": "The operational status of the client (optional for create, defaults to 'active'). Must be one of: active, inactive. Updatable.",
                                    "enum": ["active", "inactive"]
                                }
                            }
                        },
                        "client_id": {
                            "type": "string",
                            "description": "The unique identifier of the client to update. Required for 'update' action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageWorkOrders(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        work_order_data: Optional[Dict[str, Any]] = None,
        work_order_id: Optional[str] = None
    ) -> str:
        """
        Create or update work order records.

        Actions:
        - create: Create a new work order record (requires work_order_data)
        - update: Update an existing work order record (requires work_order_id and work_order_data)
        """

        def generate_id(table: Dict[str, Any], prefix: str) -> str:
            if not table:
                return f"{prefix}1"
            max_id = 0
            for k in table.keys():
                try:
                    num = int(k[len(prefix):])
                    if num > max_id:
                        max_id = num
                except ValueError:
                    continue
            return f"{prefix}{max_id + 1}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        work_orders = data.get("work_orders", {})
        users = data.get("users", {})
        change_requests = data.get("change_requests", {})
        incidents = data.get("incidents", {})

        # Define valid enums based on DBML schema
        valid_statuses = ["pending", "in_progress", "completed", "cancelled"]

        if action == "create":
            if not work_order_data:
                return json.dumps({
                    "success": False,
                    "error": "work_order_data is required for create action"
                })

            # Validate required fields as per DBML schema
            required_fields = [
                "work_order_number", "title", "description", "assigned_to", "scheduled_date"
            ]
            missing_fields = [field for field in required_fields if field not in work_order_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not work_order_data[field] or (isinstance(work_order_data[field], str) and str(work_order_data[field]).strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate work_order_number uniqueness
            work_order_number = str(work_order_data["work_order_number"]).strip()
            for work_order in work_orders.values():
                if work_order["work_order_number"].lower() == work_order_number.lower():
                    return json.dumps({
                        "success": False,
                        "error": f"Work order with number '{work_order_number}' already exists."
                    })

            # Status is 'pending' by default, if provided, must be valid
            status = work_order_data.get("status", "pending")
            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{status}'. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate assigned_to FK
            assigned_to = str(work_order_data["assigned_to"]).strip().strip('"')
            if assigned_to not in users:
                return json.dumps({
                    "success": False,
                    "error": f"Assigned to user '{assigned_to}' not found"
                })
            if users[assigned_to]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"Assigned to user '{assigned_to}' is not active"
                })

            # Validate change_id FK if provided (nullable)
            change_id = work_order_data.get("change_id")
            if change_id:
                change_id = str(change_id).strip().strip('"')
                if change_id not in change_requests:
                    return json.dumps({
                        "success": False,
                        "error": f"Change request '{change_id}' not found"
                    })

            # Validate incident_id FK if provided (nullable)
            incident_id = work_order_data.get("incident_id")
            if incident_id:
                incident_id = str(incident_id).strip().strip('"')
                if incident_id not in incidents:
                    return json.dumps({
                        "success": False,
                        "error": f"Incident '{incident_id}' not found"
                    })

            new_id = generate_id(work_orders, "WO")
            new_work_order = {
                "work_order_id": new_id,
                "work_order_number": work_order_number,
                "change_id": change_id if change_id else None,
                "incident_id": incident_id if incident_id else None,
                "title": work_order_data["title"],
                "description": work_order_data["description"],
                "assigned_to": assigned_to,
                "status": status,
                "scheduled_date": work_order_data["scheduled_date"],
                "completed_at": work_order_data.get("completed_at"),  # Nullable
                "created_at": timestamp
            }
            work_orders[new_id] = new_work_order
            return json.dumps({
                "success": True,
                "action": "create",
                "work_order_id": new_id,
                "work_order_data": new_work_order
            })

        elif action == "update":
            if not work_order_id:
                return json.dumps({
                    "success": False,
                    "error": "work_order_id is required for update action"
                })
            work_order_id = str(work_order_id).strip().strip('"')
            if work_order_id not in work_orders:
                return json.dumps({
                    "success": False,
                    "error": f"Work order '{work_order_id}' not found"
                })

            if not work_order_data:
                return json.dumps({
                    "success": False,
                    "error": "work_order_data is required for update action"
                })

            # Allowed fields for update (all except work_order_id, created_at)
            allowed_fields = [
                "work_order_number", "change_id", "incident_id", "title", 
                "description", "assigned_to", "status", "scheduled_date", "completed_at"
            ]
            invalid_fields = [field for field in work_order_data if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for update: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields (nullable fields can be None)
            # NOT NULL fields: work_order_number, title, description, assigned_to, scheduled_date
            nullable_fields = ["change_id", "incident_id", "completed_at"]
            for field, value in work_order_data.items():
                if field not in nullable_fields and (value is None or (isinstance(value, str) and str(value).strip() == "")):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
                elif field in nullable_fields and (isinstance(value, str) and str(value).strip() == ""):
                    work_order_data[field] = None  # Treat empty string as null for nullable fields

            # Validate work_order_number uniqueness if updated
            if "work_order_number" in work_order_data:
                updated_work_order_number = str(work_order_data["work_order_number"]).strip()
                for existing_work_order_id, work_order in work_orders.items():
                    if existing_work_order_id != work_order_id and work_order["work_order_number"].lower() == updated_work_order_number.lower():
                        return json.dumps({
                            "success": False,
                            "error": f"Work order with number '{updated_work_order_number}' already exists."
                        })
                work_order_data["work_order_number"] = updated_work_order_number

            # Validate status enum if provided
            if "status" in work_order_data and work_order_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{work_order_data['status']}'. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate assigned_to FK if provided
            if "assigned_to" in work_order_data:
                assigned_to = str(work_order_data["assigned_to"]).strip().strip('"')
                if assigned_to not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Assigned to user '{assigned_to}' not found"
                    })
                if users[assigned_to]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Assigned to user '{assigned_to}' is not active"
                    })
                work_order_data["assigned_to"] = assigned_to

            # Validate change_id FK if provided
            if "change_id" in work_order_data and work_order_data["change_id"] is not None:
                change_id = str(work_order_data["change_id"]).strip().strip('"')
                if change_id not in change_requests:
                    return json.dumps({
                        "success": False,
                        "error": f"Change request '{change_id}' not found"
                    })
                work_order_data["change_id"] = change_id

            # Validate incident_id FK if provided
            if "incident_id" in work_order_data and work_order_data["incident_id"] is not None:
                incident_id = str(work_order_data["incident_id"]).strip().strip('"')
                if incident_id not in incidents:
                    return json.dumps({
                        "success": False,
                        "error": f"Incident '{incident_id}' not found"
                    })
                work_order_data["incident_id"] = incident_id

            updated_work_order = work_orders[work_order_id].copy()
            for key, value in work_order_data.items():
                updated_work_order[key] = value
            
            work_orders[work_order_id] = updated_work_order
            return json.dumps({
                "success": True,
                "action": "update",
                "work_order_id": work_order_id,
                "work_order_data": updated_work_order
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_work_orders",
                "description": "Create or update work order records in the system. Work orders represent scheduled tasks or maintenance activities that may be related to change requests or incidents.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to add a new work order, 'update' to modify an existing work order."
                        },
                        "work_order_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating or updating a work order.",
                            "properties": {
                                "work_order_number": {
                                    "type": "string",
                                    "description": "A unique identifier for the work order (required for create, must be unique, cannot be empty). Updatable."
                                },
                                "change_id": {
                                    "type": "string",
                                    "description": "The ID of the related change request (optional). Must refer to an existing change request if provided. Updatable, can be set to null."
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "The ID of the related incident (optional). Must refer to an existing incident if provided. Updatable, can be set to null."
                                },
                                "title": {
                                    "type": "string",
                                    "description": "A brief, descriptive title for the work order (required for create, cannot be empty). Updatable."
                                },
                                "description": {
                                    "type": "string",
                                    "description": "A detailed description of the work order (required for create, cannot be empty). Updatable."
                                },
                                "assigned_to": {
                                    "type": "string",
                                    "description": "The user ID of the person assigned to complete the work order (required for create). Must refer to an existing active user. Updatable."
                                },
                                "status": {
                                    "type": "string",
                                    "description": "The current status of the work order (optional for create, defaults to 'pending'). Must be one of: pending, in_progress, completed, cancelled. Updatable.",
                                    "enum": ["pending", "in_progress", "completed", "cancelled"]
                                },
                                "scheduled_date": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the work order is scheduled to be executed (required for create, cannot be empty). Updatable."
                                },
                                "completed_at": {
                                    "type": "string",
                                    "format": "date-time",
                                    "description": "The timestamp when the work order was completed (optional). Updatable, can be set to null."
                                }
                            }
                        },
                        "work_order_id": {
                            "type": "string",
                            "description": "The unique identifier of the work order to update. Required for 'update' action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageIncidentReports(Tool):
    """
    Create and update incident reports for tracking and documenting incidents.
    """
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        report_id: Optional[str] = None,
        incident_id: Optional[str] = None,
        report_title: Optional[str] = None,
        report_type: Optional[str] = None,
        report_content: Optional[str] = None,
        generated_by: Optional[str] = None,
        report_status: Optional[str] = None
    ) -> str:
        """
        Create or update incident report records.

        Actions:
        - create: Create new incident report (requires incident_id, report_title, report_type, report_content, generated_by)
        - update: Update existing incident report (requires report_id and at least one field to update)
        """
        def generate_id(table: Dict[str, Any]) -> str:
            """Generates a new unique ID for a record."""
            if not table:
                return "1"
            return str(max(int(k) for k in table.keys()) + 1)

        def generate_report_number(report_id: str) -> str:
            """Generate a formatted report number."""
            return f"RPT{report_id.zfill(7)}"

        timestamp = "2025-10-01T12:00:00"
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })
        
        reports = data.get("incident_reports", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        valid_report_types = ["post_incident_review", "client_impact", "compliance"]
        valid_statuses = ["draft", "completed", "approved", "archived"]
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": "Invalid action. Must be 'create' or 'update'"
            })

        if action == "create":
            # Validate required fields are provided
            if not all([incident_id, report_title, report_type, report_content, generated_by]):
                missing_fields = []
                if not incident_id: missing_fields.append("incident_id")
                if not report_title: missing_fields.append("report_title")
                if not report_type: missing_fields.append("report_type")
                if not report_content: missing_fields.append("report_content")
                if not generated_by: missing_fields.append("generated_by")
                
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })

            # Validate non-empty required fields
            if not str(incident_id).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'incident_id' cannot be empty"
                })
            
            if not str(report_title).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'report_title' cannot be empty"
                })
            
            if not str(report_type).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'report_type' cannot be empty"
                })
            
            if not str(report_content).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'report_content' cannot be empty"
                })
            
            if not str(generated_by).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'generated_by' cannot be empty"
                })

            # Validate incident exists
            if str(incident_id) not in incidents:
                return json.dumps({
                    "success": False,
                    "error": f"Incident with ID {incident_id} not found"
                })

            # Validate user exists and is active
            if str(generated_by) not in users:
                return json.dumps({
                    "success": False,
                    "error": f"User with ID {generated_by} not found"
                })
            if users[str(generated_by)]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"User with ID {generated_by} is not active"
                })

            if report_type not in valid_report_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid report_type. Must be one of: {', '.join(valid_report_types)}"
                })

            new_id = generate_id(reports)
            report_number = generate_report_number(new_id)
            new_report = {
                "report_id": new_id,
                "report_number": report_number,
                "report_title": report_title,
                "incident_id": str(incident_id),
                "report_type": report_type,
                "report_content": report_content,
                "generated_by": str(generated_by),
                "generation_date": timestamp,
                "report_status": "draft"
            }
            reports[new_id] = new_report

            return json.dumps({
                "success": True,
                "action": "create",
                "report_id": new_id,
                "report_number": report_number,
                "report_data": new_report
            })

        elif action == "update":
            if not report_id:
                return json.dumps({
                    "success": False,
                    "error": "report_id is required for update action"
                })

            if str(report_id) not in reports:
                return json.dumps({
                    "success": False,
                    "error": f"Report with ID {report_id} not found"
                })

            # Validate at least one field is being updated
            if all(v is None for v in [report_title, report_type, report_content, report_status]):
                return json.dumps({
                    "success": False,
                    "error": "At least one field must be provided for update"
                })

            existing_report = reports[str(report_id)]

            # Validate non-empty fields
            if report_title is not None and not str(report_title).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'report_title' cannot be empty"
                })

            if report_type is not None and not str(report_type).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'report_type' cannot be empty"
                })

            if report_content is not None and not str(report_content).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'report_content' cannot be empty"
                })

            if report_status is not None and not str(report_status).strip():
                return json.dumps({
                    "success": False,
                    "error": "Field 'report_status' cannot be empty"
                })

            if report_type is not None:
                if report_type not in valid_report_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid report_type. Must be one of: {', '.join(valid_report_types)}"
                    })
                existing_report["report_type"] = report_type

            if report_title is not None:
                existing_report["report_title"] = report_title

            if report_content is not None:
                existing_report["report_content"] = report_content

            if report_status is not None:
                if report_status not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid report_status. Must be one of: {', '.join(valid_statuses)}"
                    })
                existing_report["report_status"] = report_status

            return json.dumps({
                "success": True,
                "action": "update",
                "report_id": str(report_id),
                "report_number": existing_report["report_number"],
                "report_data": existing_report
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_incident_reports",
                "description": "Create or update incident reports for formal documentation and tracking. Manages comprehensive incident reporting including post-incident reviews, client impact assessments, and compliance documentation. Validates report types, user permissions, and maintains report status workflow.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to create new report or 'update' to modify existing report"
                        },
                        "report_id": {
                            "type": "string",
                            "description": "Unique identifier of the report. Required for update action only."
                        },
                        "incident_id": {
                            "type": "string",
                            "description": "Identifier of the incident this report belongs to (required for create, cannot be empty, must exist in system)"
                        },
                        "report_title": {
                            "type": "string",
                            "description": "Title or summary of the report (required for create, cannot be empty)"
                        },
                        "report_type": {
                            "type": "string",
                            "description": "Type of incident report (required for create). Must be one of: post_incident_review, client_impact, compliance"
                        },
                        "report_content": {
                            "type": "string",
                            "description": "Detailed content of the report (required for create, cannot be empty)"
                        },
                        "generated_by": {
                            "type": "string",
                            "description": "User identifier who created the report (required for create, cannot be empty, must be active user)"
                        },
                        "report_status": {
                            "type": "string",
                            "description": "Status of the report (optional for update). Must be one of: draft, completed, approved, archived"
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageChangeControl(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        change_request_data: Optional[Dict[str, Any]] = None,
        change_id: Optional[str] = None
    ) -> str:
        """
        Create or update change request records.

        Actions:
        - create: Create a new change request record (requires change_request_data)
        - update: Update an existing change request record (requires change_id and change_request_data)
        """

        def generate_id(table: Dict[str, Any], prefix: str) -> str:
            if not table:
                return f"{prefix}1"
            max_id = 0
            for k in table.keys():
                try:
                    num = int(k[len(prefix):])
                    if num > max_id:
                        max_id = num
                except ValueError:
                    continue
            return f"{prefix}{max_id + 1}"

        def generate_change_number(table: Dict[str, Any]) -> str:
            if not table:
                return "CHG0000001"
            max_num = 0
            for change in table.values():
                change_num = change.get("change_number", "")
                if change_num.startswith("CHG"):
                    try:
                        num = int(change_num[3:])
                        if num > max_num:
                            max_num = num
                    except ValueError:
                        continue
            return f"CHG{max_num + 1:07d}"

        timestamp = "2025-10-01T00:00:00"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })

        change_requests = data.get("change_requests", {})
        users = data.get("users", {})
        incidents = data.get("incidents", {})
        problem_tickets = data.get("problem_tickets", {})

        # Define valid enums based on DBML schema
        valid_change_types = ["standard", "normal", "emergency"]
        valid_risk_levels = ["low", "medium", "high", "critical"]
        valid_statuses = ["requested", "approved", "denied", "scheduled", "implemented", "cancelled"]

        if action == "create":
            if not change_request_data:
                return json.dumps({
                    "success": False,
                    "error": "change_request_data is required for create action"
                })

            # Validate required fields as per DBML
            required_fields = ["title", "description", "change_type", "risk_level", "requested_by"]
            missing_fields = [field for field in required_fields if field not in change_request_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate non-empty required fields
            for field in required_fields:
                if not change_request_data[field] or (isinstance(change_request_data[field], str) and change_request_data[field].strip() == ""):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })

            # Validate enums
            if change_request_data["change_type"] not in valid_change_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid change_type '{change_request_data['change_type']}'. Must be one of: {', '.join(valid_change_types)}"
                })
            if change_request_data["risk_level"] not in valid_risk_levels:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid risk_level '{change_request_data['risk_level']}'. Must be one of: {', '.join(valid_risk_levels)}"
                })
            
            # Status defaults to 'requested' if not provided
            status = change_request_data.get("status", "requested")
            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{status}'. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate requested_by user exists and is active
            requested_by = str(change_request_data["requested_by"]).strip().strip('"')
            if requested_by not in users:
                return json.dumps({
                    "success": False,
                    "error": f"User '{requested_by}' not found"
                })
            if users[requested_by]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"User '{requested_by}' is not active"
                })
            
            # Validate optional approved_by if provided
            approved_by = change_request_data.get("approved_by")
            if approved_by:
                approved_by = str(approved_by).strip().strip('"')
                if approved_by not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Approved by user '{approved_by}' not found"
                    })
                if users[approved_by]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Approved by user '{approved_by}' is not active"
                    })
            
            # Validate optional incident_id if provided
            incident_id = change_request_data.get("incident_id")
            if incident_id:
                incident_id = str(incident_id).strip().strip('"')
                if incident_id not in incidents:
                    return json.dumps({
                        "success": False,
                        "error": f"Incident '{incident_id}' not found"
                    })
            
            # Validate optional problem_ticket_id if provided
            problem_ticket_id = change_request_data.get("problem_ticket_id")
            if problem_ticket_id:
                problem_ticket_id = str(problem_ticket_id).strip().strip('"')
                if problem_ticket_id not in problem_tickets:
                    return json.dumps({
                        "success": False,
                        "error": f"Problem ticket '{problem_ticket_id}' not found"
                    })

            new_id = generate_id(change_requests, "")
            new_change_number = generate_change_number(change_requests)
            
            new_cr = {
                "change_id": new_id,
                "change_number": new_change_number,
                "incident_id": incident_id if incident_id else None,
                "problem_ticket_id": problem_ticket_id if problem_ticket_id else None,
                "title": change_request_data["title"],
                "description": change_request_data["description"],
                "change_type": change_request_data["change_type"],
                "risk_level": change_request_data["risk_level"],
                "requested_by": requested_by,
                "approved_by": approved_by if approved_by else None,
                "status": status,
                "implementation_date": change_request_data.get("implementation_date"),
                "created_at": timestamp,
                "updated_at": timestamp
            }
            change_requests[new_id] = new_cr
            return json.dumps({
                "success": True,
                "action": "create",
                "change_id": new_id,
                "change_request_data": new_cr
            })

        elif action == "update":
            if not change_id:
                return json.dumps({
                    "success": False,
                    "error": "change_id is required for update action"
                })
            change_id = str(change_id).strip().strip('"')
            if change_id not in change_requests:
                return json.dumps({
                    "success": False,
                    "error": f"Change request '{change_id}' not found"
                })

            if not change_request_data:
                return json.dumps({
                    "success": False,
                    "error": "change_request_data is required for update action"
                })

            # Allowed fields for update (change_id, change_number, created_at are not updatable)
            allowed_fields = [
                "title", "description", "change_type", "risk_level", "status",
                "requested_by", "approved_by", "implementation_date",
                "incident_id", "problem_ticket_id"
            ]
            invalid_fields = [field for field in change_request_data if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for update: {', '.join(invalid_fields)}"
                })
            
            # Validate non-empty fields (if provided, they shouldn't be empty strings, but nullable fields can be None)
            nullable_fields = ["approved_by", "implementation_date", "incident_id", "problem_ticket_id"]
            for field, value in change_request_data.items():
                if field not in nullable_fields and (value is None or (isinstance(value, str) and value.strip() == "")):
                    return json.dumps({
                        "success": False,
                        "error": f"Field '{field}' cannot be empty"
                    })
                elif field in nullable_fields and (isinstance(value, str) and value.strip() == ""):
                    change_request_data[field] = None # Treat empty string as null for nullable fields

            # Validate enums if provided
            if "change_type" in change_request_data and change_request_data["change_type"] not in valid_change_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid change_type. Must be one of: {', '.join(valid_change_types)}"
                })
            if "risk_level" in change_request_data and change_request_data["risk_level"] not in valid_risk_levels:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid risk_level. Must be one of: {', '.join(valid_risk_levels)}"
                })
            if "status" in change_request_data and change_request_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate user fields if provided
            for user_field in ["requested_by", "approved_by"]:
                if user_field in change_request_data and change_request_data[user_field] is not None:
                    user_id = str(change_request_data[user_field]).strip().strip('"')
                    if user_id not in users:
                        return json.dumps({
                            "success": False,
                            "error": f"User '{user_id}' for field '{user_field}' not found"
                        })
                    if users[user_id]["status"] != "active":
                        return json.dumps({
                            "success": False,
                            "error": f"User '{user_id}' for field '{user_field}' is not active"
                        })
                    change_request_data[user_field] = user_id
                elif user_field in change_request_data and change_request_data[user_field] is None:
                    change_request_data[user_field] = None # Allow setting to null

            # Validate incident_id if provided
            if "incident_id" in change_request_data and change_request_data["incident_id"] is not None:
                incident_id = str(change_request_data["incident_id"]).strip().strip('"')
                if incident_id not in incidents:
                    return json.dumps({
                        "success": False,
                        "error": f"Incident '{incident_id}' not found"
                    })
                change_request_data["incident_id"] = incident_id
            elif "incident_id" in change_request_data and change_request_data["incident_id"] is None:
                change_request_data["incident_id"] = None # Allow setting to null
            
            # Validate problem_ticket_id if provided
            if "problem_ticket_id" in change_request_data and change_request_data["problem_ticket_id"] is not None:
                problem_ticket_id = str(change_request_data["problem_ticket_id"]).strip().strip('"')
                if problem_ticket_id not in problem_tickets:
                    return json.dumps({
                        "success": False,
                        "error": f"Problem ticket '{problem_ticket_id}' not found"
                    })
                change_request_data["problem_ticket_id"] = problem_ticket_id
            elif "problem_ticket_id" in change_request_data and change_request_data["problem_ticket_id"] is None:
                change_request_data["problem_ticket_id"] = None # Allow setting to null

            updated_cr = change_requests[change_id].copy()
            for key, value in change_request_data.items():
                updated_cr[key] = value
            updated_cr["updated_at"] = timestamp
            change_requests[change_id] = updated_cr
            return json.dumps({
                "success": True,
                "action": "update",
                "change_id": change_id,
                "change_request_data": updated_cr
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_change_control",
                "description": "Create or update change request records in the change management system. This tool supports documenting, categorizing, and tracking changes to IT services and infrastructure.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish a new change request, 'update' to modify an existing change request."
                        },
                        "change_request_data": {
                            "type": "object",
                            "description": "Data object containing fields for creating or updating a change request.",
                            "properties": {
                                "title": {
                                    "type": "string",
                                    "description": "Brief title or summary of the change (required for create, cannot be empty). Updatable."
                                },
                                "description": {
                                    "type": "string",
                                    "description": "Detailed description of the change, including its purpose and scope (required for create, cannot be empty). Updatable."
                                },
                                "change_type": {
                                    "type": "string",
                                    "description": "Classification of the change (required for create). Must be one of: standard, normal, emergency. Updatable.",
                                    "enum": ["standard", "normal", "emergency"]
                                },
                                "risk_level": {
                                    "type": "string",
                                    "description": "Risk level of the change (required for create). Must be one of: low, medium, high, critical. Updatable.",
                                    "enum": ["low", "medium", "high", "critical"]
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Current status of the change request (optional for create, defaults to 'requested'). Must be one of: requested, approved, denied, scheduled, implemented, cancelled. Updatable.",
                                    "enum": ["requested", "approved", "denied", "scheduled", "implemented", "cancelled"]
                                },
                                "requested_by": {
                                    "type": "string",
                                    "description": "User ID of the person who requested the change (required for create, must be an active user). Updatable."
                                },
                                "approved_by": {
                                    "type": "string",
                                    "description": "User ID of the person who approved the change (optional, must be an active user if provided). Updatable, can be set to null."
                                },
                                "implementation_date": {
                                    "type": "string",
                                    "description": "Date the change was implemented in YYYY-MM-DDTHH:MM:SS format (optional). Updatable, can be set to null."
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "Related incident ID (optional, must exist if provided). Updatable, can be set to null."
                                },
                                "problem_ticket_id": {
                                    "type": "string",
                                    "description": "Related problem ticket ID (optional, must exist if provided). Updatable, can be set to null."
                                }
                            }
                        },
                        "change_id": {
                            "type": "string",
                            "description": "The unique identifier of the change request to update. Required for 'update' action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# Policy:
# **Incident Management Policy & SOPs**

The current time is 2025-10-04 12:00:00 UTC

## **Introduction**

This document defines the operational guide for an Incident Management automation agent. It is designed for single-turn execution: each procedure must be self-contained and completed in one interaction.

**Validation first**: All inputs must be validated. If any required element is missing or invalid, the process halts with a clear error message.

**Logging**: Every INSERT, UPDATE, or DELETE operation must generate an audit_log entry with entity_type, entity_id, operation_type, changed_by_id, field_name, old_value, and new_value. .

**Role-based permissions**: Only designated roles may perform an action; other roles may do so only with explicit approval from a role authorized to perform it.

### **What is "Halt"?**

When a process halts, the agent immediately stops execution of the current SOP and returns a message to the user that says "cannot continue the process" \- therefore no further steps within that SOP are performed. The agent will use the **transfer_to_human** tool to transfer the request to a human agent.

## **Standard Operating Procedures**

### **Entities Lookup / Discovery**

Use this whenever you need to find, search, or verify entities; fetch details for validation or reporting; or when another SOP needs entity information first.

1. **Obtain:**  
* **Required**: entity_type  
* **Optional**: Include any filters for that entity (e.g., ID, status, dates) used to narrow the search.  
2. **Pick one discovery tool that matches the entity type:**  
* For clients, call **discover_clients** (filter by client_id, client_name, client_type, industry, country, status)  
* For **vendors**, call **discover_vendors** (filter by vendor_id, vendor_name, vendor_type, status)  
* For **users**, call **discover_users**  (filter by user_id, email, role, client_id, vendor_id, status)  
* For **products**, call **discover_products**  (filter by product_id, product_name, product_type, version, vendor_support_id, status)  
* For **infrastructure components**, call **discover_components** (filter by component_id, product_id, component_name, component_type, environment, location, port_number, status)  
* For **client subscriptions,** **sla agreements** call **discover_subscription_agreements** (filter by subscription_id, client_id, product_id, subscription_type, start_date, end_date, sla_tier, rto_hours, status, sla_id, subscription_id, severity_level, response_time_minutes, resolution_time_hours, availability_percentage).  
* For **incidents, post incident reviews** call **discover_incident_entities** (filter by incident_id, incident_code, client_id, component_id, reporter_id, assigned_manager_id, severity, status, category, detection_source, detected_at, impact, urgency).  
* For **workarounds**, call **discover_workaround_entities** (filter by workaround_id, incident_id, implemented_by_id, effectiveness, status, implemented_at)  
* For **root cause analysis**, call **discover_rca_entities** (filter by rca_id, incident_id, analysis_method, conducted_by_id, completed_at, status)  
* For **escalations**, call **discover_escalation_entities** (filter by escalation_id, escalation_code, incident_id, escalated_by_id, escalated_to_id, escalation_reason, escalation_level, escalated_at, acknowledged_at, resolved_at, status)  
* For **change requests, rollback requests**, call **discover_change_entities** (filter by change_id, change_code, rollback_id, incident_id, requested_by_id, approved_by_id, change_type, status)  
* For **metrics**, call **discover_metrics_entities** (filter by metric_id, incident_id, metric_type, value_minutes, target_minutes, recorded_at)  
* For **incident reports**, call **discover_incident_entities** (filter by report_id, incident_id, report_type, generated_by_id, generated_at, status)  
* For communications, call **discover_communication_entities** (filter by communication_id, incident_id, sender_id, recipient_id, recipient_type, communication_type, sent_at, delivery_status, pir_id, incident_id, facilitator_id, scheduled_date, timeline_accuracy_rating, communication_effectiveness_rating, technical_response_rating)  
* For **knowledge base articles**, call **discover_kb_article_entities** (filter by article_id, incident_id, created_by_id, reviewed_by_id, article_type, category, view_count, status)  
3. **Run the selected discovery tool and wait for the results.**  
4. **Acquire the result** \- whether it is a single match, multiple matches, or none.

**Halt, and use transfer_to_human if any of these occur:**

* The entity_type is missing or invalid  
* The requester is not authorized  
* The discovery tool fails to execute

---

## **Client Management Operations**

### **Create Client Record**

1. **Obtain:**  
* **Required**: client_name, client_type (enterprise, mid_market, small_business, startup), country  
* **Optional**: registration_number, contact_email, industry, status (active, inactive, suspended)  
* **Validate** that client_name and registration_number (if provided) are unique using **discover_clients**.  
2. **Create** the client record using **manage_clients**.  
3. **Create** an audit entry for client creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Client name or registration number already exists  
* Invalid client_type or country  
* Client creation failed  
* Audit trail logging failure

---

### **Update Client Information**

**1.   Obtain:**

* **Required**: client_id  
* **Optional**: client_name, registration_number, contact_email, client_type (enterprise, mid_market, small_business, startup), industry, country, status (active, inactive, suspended) (at least one must be provided)  
* **Validate** that client exists and is accessible to the user using **discover_clients**.

2**. Verify** that the approval to conduct the action is present using **check_approval**    (system_administrator or incident_manager or account_manager approval required). 

**3. If updating** client_name or registration_number, validate uniqueness using **discover_clients**.

**4. Update** the client record using **manage_clients**.

**5. Create** an audit entry for client update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Client not found  
* User not authorized for client updates  
* New client_name or registration_number already exists  
* Invalid client_type or status  
* Client update failed  
* Audit trail logging failure

---

**User Management Operations**

### **Create User Account**

1. **Obtain:**  
* **Required**: first_name, last_name, email, role (incident_manager, technical_support, account_manager, executive, vendor_contact, system_administrator, client_contact), timezone  
* **Optional**: phone, department, client_id, vendor_id, status (active, inactive, on_leave)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager approval required).  
3. **Validate** that email is unique using **discover_users**.  
4. **If client_id provided**, validate that client exists and has active status using **discover_clients**.  
5. **If vendor_id provided**, validate that vendor exists and has active status using **discover_vendors**.  
6. **Create** the user account using **manage_users**.  
7. **Create** an audit entry for user creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Email already exists  
* Client or vendor not found or inactive  
* Invalid role or timezone  
* Approval missing for elevated role creation  
* User creation failed  
* Audit trail logging failure

---

### **Update User Information**

1. **Obtain:**  
* **Required**: user_id  
* **Optional**: first_name, last_name, email, phone, role (incident_manager, technical_support, account_manager, executive, vendor_contact, system_administrator, client_contact), department, client_id, vendor_id, timezone, status (active, inactive, on_leave) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager approval required).  
3. **Validate** that user exists using **discover_users**.  
4. **If updating email**, validate uniqueness using **discover_users**.  
5. **Update** the user record using **manage_users**.  
6. **Create** an audit entry for user update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing approval for updating user information  
* User not found  
* New email already exists  
* Invalid role or status  
* Approval missing for role elevation  
* User update failed  
* Audit trail logging failure

---

## **Vendor Management Operations**

### **Create Vendor Record**

1. **Obtain:**  
* **Required**: vendor_name, vendor_type (cloud_provider, payment_processor, software_vendor, infrastructure_provider, security_vendor)  
* **Optional**: contact_email,,contact_phone, status (active, inactive, suspended).  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager or executive approval required)  
3. **Validate** that vendor_name is unique using **discover_vendors**.  
4. **Create** the vendor record using **manage_vendors**.  
5. **Create** an audit entry for vendor creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for vendor creation  
* Missing or invalid inputs  
* Vendor name already exists  
* Invalid vendor_type  
* Vendor creation failed  
* Audit trail logging failure

---

### **Update Vendor Information**

1. **Obtain:**  
* **Required**: vendor_id  
* **Optional**: vendor_name, vendor_type (cloud_provider, payment_processor, software_vendor, infrastructure_provider, security_vendor), contact_email, contact_phone, status (active, inactive, suspended) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager or executive approval required).  
3. **Validate** that vendor exists using **discover_vendors**.  
4. **If updating vendor_name**, validate uniqueness using **discover_vendors**.  
5. **Update** the vendor record using **manage_vendors**.  
6. **Create** an audit entry for vendor update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for vendor update  
* Vendor not found  
* New vendor_name already exists  
* Invalid vendor_type or status  
* Vendor update failed  
* Audit trail logging failure

---

## **Product and Infrastructure Operations**

### **Create Product Record**

1. **Obtain:**  
* **Required**: product_name, product_type (payment_processing, banking_system, api_gateway, data_integration, reporting_platform, security_service, backup_service, monitoring_tool)  
* **Optional**: version, vendor_support_id, status (active, deprecated, maintenance)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager or executive approval required)  
3. **Validate** that product_name is unique using **discover_products**.  
4. **If vendor_support_id provided**, validate that vendor exists and has active status using **discover_vendors**.  
5. **Create** the product record using **manage_products**.  
6. **Create** an audit entry for product creation using **log_audit_records**

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Product name already exists  
* Vendor not found or inactive  
* Invalid product_type  
* Product creation failed  
* Audit trail logging failure

## **Update Product Record**

1. **Obtain:**  
* **Required**: product_id  
* **Optional**: product_name, product_type (payment_processing, banking_system, api_gateway, data_integration, reporting_platform, security_service, backup_service, monitoring_tool), version, vendor_support_id, status (active, deprecated, maintenance) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager or executive approval required).  
3. **Validate** that product exists using **discover_products**.  
4. **If updating product_name**, validate uniqueness using **discover_products**.  
5. **If updating vendor_support_id**, validate that vendor exists and has active status using **discover_vendors**.  
6. **Update** the product record using **manage_products**.  
7. **Create** an audit entry for product update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for product update  
* Product not found  
* New product_name already exists  
* Vendor not found or inactive (if updating vendor_support_id)  
* Invalid product_type or status  
* Product update failed  
* Audit trail logging failure

---

## **Create Infrastructure Component**

1. **Obtain:**  
* **Required**: component_name, component_type (sftp_server, api_endpoint, database, load_balancer, firewall, authentication_service, payment_gateway, file_storage, monitoring_system), environment (production, staging, development, test)  
* **Optional**: product_id, location, port_number, status (online, offline, maintenance, degraded)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or technical_support or incident_manager approval required).  
3. **Validate** that component_name is unique within the specified product using **discover_components**.  
4. **If product_id provided**, validate that product exists and has active status using **discover_products**.  
5. **Create** the infrastructure component using **manage_components**.  
6. **Create** an audit entry for component creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for component creation  
* Missing or invalid inputs  
* Product not found or inactive (if product_id specified)  
* Component name already exists within product  
* Invalid component_type, environment, or status  
* Component creation failed  
* Audit trail logging failure

## **Update Infrastructure Component**

1. **Obtain:**  
* **Required**: component_id  
* **Optional**: component_name, component_type (sftp_server, api_endpoint, database, load_balancer, firewall, authentication_service, payment_gateway, file_storage, monitoring_system), product_id, environment (production, staging, development, test), location, port_number, status (online, offline, maintenance, degraded) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or technical_support or incident_manager approval required).  
3. **Validate** that component exists using **discover_components**.  
4. **If updating component_name**, validate uniqueness within the specified product using **discover_components**.  
5. **If updating product_id**, validate that product exists and has active status using **discover_products**.  
6. **Update** the infrastructure component using **manage_components**.  
7. **Create** an audit entry for component update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for component update  
* Component not found  
* Product not found or inactive (if updating product_id)  
* New component_name already exists within product  
* Invalid component_type, environment, or status  
* Component update failed  
* Audit trail logging failure

---

## **Subscription and Service Level Management**

### **Create Client Subscription**

1. **Obtain:**  
* **Required**: client_id, product_id, subscription_type (full_service, limited_service, trial, custom), start_date, sla_tier (premium, standard, basic), rto_hours  
* **Optional**: end_date, status (active, expired, cancelled, suspended)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (account_manager or incident_manager or executive approval required).  
3. **Validate** that client exists and has active status using **discover_clients**.  
4. **Validate** that product exists and has active status using **discover_products**.  
5. **Create** the subscription record using **manage_client_subscriptions**.  
6. **Create** an audit entry for subscription creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for subscription creation  
* Missing or invalid inputs  
* Client not found or inactive  
* Product not found or inactive  
* Invalid subscription_type, sla_tier, or rto_hours  
* Subscription creation failed  
* Audit trail logging failure

---

### **Update Client Subscription**

1. **Obtain:**  
* **Required**: subscription_id  
* **Optional**: subscription_type (full_service, limited_service, trial, custom), start_date, end_date, sla_tier (premium, standard, basic), rto_hours, status (active, expired, cancelled, suspended) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (account_manager or incident_manager or executive approval required).  
3. **Validate** that subscription exists using **discover_subscription_agreements**.  
4. **Update** the subscription record using **manage_client_subscriptions**.  
5. **Create** an audit entry for subscription update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for subscription update  
* Subscription not found  
* Invalid subscription_type, sla_tier, status, or dates  
* Subscription update failed  
* Audit trail logging failure

---

### **Create SLA Agreement**

1. **Obtain:**  
* **Required**: subscription_id, severity_level (P1, P2, P3, P4), response_time_minutes, resolution_time_hours  
* **Optional**: availability_percentage  
2. **Verify** that the approval to conduct the action is present using **check_approval** (account_manager or system_administrator or executive approval required).  
3. **Validate** that subscription exists and has active status using **discover_subscription_agreements**.  
4. **Validate** that response and resolution times align with subscription tier using the following guidelines:  
* **Premium tier**: P1: 15-30 min response, 2-4 hrs resolution; P2: 1-2 hrs response, 8-24 hrs resolution; P3: 4-8 hrs response, 48-72 hrs resolution; P4: 24-48 hrs response, 128 hrs resolution  
* **Standard tier**: P1: 1-2 hrs response, 8-24 hrs resolution; P2: 4-8 hrs response, 24-48 hrs resolution; P3: 24 hrs response, 72-120 hrs resolution; P4: 48-72 hrs response, 168 hrs resolution  
* **Basic tier**: P1: 4-8 hrs response, 24-48 hrs resolution; P2: 24 hrs response, 72-120 hrs resolution; P3: 48-72 hrs response, 5-10 days resolution; P4: 5-7 days response, 2 weeks resolution  
5. **Create** the SLA agreement using **manage_sla_agreements**.  
6. **Create** an audit entry for SLA creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for SLA creation  
* Missing or invalid inputs  
* Subscription not found or inactive  
* Response/resolution times don't align with subscription tier  
* Invalid severity_level or availability_percentage  
* SLA creation failed  
* Audit trail logging failure

### **Update SLA Agreement**

1. **Obtain:**  
* **Required**: sla_id  
* **Optional**: severity_level (P1, P2, P3, P4), response_time_minutes, resolution_time_hours, availability_percentage (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (account_manager or system_administrator or executive approval required).  
3. **Validate** that SLA agreement exists using **discover_subscription_agreements**.  
4. **Retrieve** the associated subscription to determine subscription tier.  
5. **If updating response_time_minutes or resolution_time_hours**, validate that new times align with subscription tier using the following guidelines:  
* **Premium tier**: P1: 15-30 min response, 2-4 hrs resolution; P2: 1-2 hrs response, 8-24 hrs resolution; P3: 4-8 hrs response, 48-72 hrs resolution; P4: 24-48 hrs response, 128 hrs resolution  
* **Standard tier**: P1: 1-2 hrs response, 8-24 hrs resolution; P2: 4-8 hrs response, 24-48 hrs resolution; P3: 24 hrs response, 72-120 hrs resolution; P4: 48-72 hrs response, 168 hrs resolution  
* **Basic tier**: P1: 4-8 hrs response, 24-48 hrs resolution; P2: 24 hrs response, 72-120 hrs resolution; P3: 48-72 hrs response, 5-10 days resolution; P4: 5-7 days response, 2 weeks resolution  
6. **Update** the SLA agreement using **manage_sla_agreements**.  
7. **Create** an audit entry for SLA update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for SLA update  
* SLA agreement not found  
* Response/resolution times don't align with subscription tier  
* Invalid severity_level or availability_percentage  
* SLA update failed  
* Audit trail logging failure

---

## **Incident Operations**

### **Create Incident**

1. **Obtain:**  
* **Required**: title, reporter_id, client_id, category (system_outage, performance_degradation, security_incident, data_corruption, integration_failure, network_issue, hardware_failure, software_bug, configuration_error, capacity_issue, backup_failure, authentication_failure, api_error, database_issue, service_unavailable) , impact (critical, high, medium, low), detection_source(client_reported,internally_detected, monitoring_alert,vendor_reported,scheduled_maintenance,emergency_maintanence), urgency (critical, high, medium, low), detected_at  
* Optional: assigned_manager_id, component_id, severity(P1,P2,P3,P4), status(open,in_progress,resolved,closed) , is_recurring,downtime_minutes,sla_breach,rto_breach,closed_at,resolved_at  
2. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or technical_support or system_administrator or executive approval required).  
3. **Validate** that reporter exists and has active status using **discover_users**.  
4. **Validate** that client exists and has active status using **discover_clients**.  
5. **If component_id provided**, validate that component exists using **discover_products**.  
6. **If assigned_manager_id provided**, validate that user exists using **discover_users**.  
7. **Create** the incident record using **manage_incidents.**  
8. **Create** an audit entry for incident creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for creating an incident  
* Missing or invalid inputs  
* Reporter not found or inactive  
* Client not found or inactive  
* Component not found  
* Assigned manager not found  
* Invalid category, impact, urgency, or severity  
* Incident creation failed  
* Audit trail logging failure

---

### **Update Incident**

1. **Obtain:**  
* **Required**: incident_id  
2. **Optional**: title,incident_code, assigned_manager_id, component_id, severity (P1, P2, P3, P4), status (open, in_progress, resolved, closed), impact (critical, high, medium, low), urgency (critical, high, medium, low), category (system_outage, performance_degradation, security_incident, data_corruption, integration_failure, network_issue, hardware_failure, software_bug, configuration_error, capacity_issue, backup_failure, authentication_failure, api_error, database_issue, service_unavailable), detection_source (client_reported, internally_detected, monitoring_alert, vendor_reported, scheduled_maintenance, emergency_maintenance), resolved_at, closed_at, rto_breach, sla_breach, is_recurring, downtime_minutes (at least one must be provided)  
3. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or technical_support or system_administrator or executive approval required)  
4. **Validate** that incident exists using **discover_incident_entities**.  
5. **If updating assigned_manager_id**, validate that user exists using **discover_users**.  
6. **Update** the incident record using **manage_incidents**.  
7. **Create** an audit entry for incident update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing to update incident  
* Incident not found  
* Assigned manager not found or has invalid role  
* Invalid severity, impact, urgency, category, or timestamps  
* Incident update failed  
* Audit trail logging failure

---

### **Resolve Incident**

1. **Obtain:**  
* **Required**: incident_id  
2. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or technical_support or executive approval required)  
3. **Validate** that incident exists and has status of in_progress or open using **discover_incident_entities**.  
4. **Update** incident status to resolved and set resolved_at timestamp using **manage_incidents**.  
5. **Create** an audit entry for incident resolution using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing approval to resolve incident  
* Incident not found or invalid status  
* Report generation failed  
* Incident resolution update failed  
* Audit trail logging failure

---

### **Close Incident**

1. **Obtain:**  
* **Required**: incident_id  
2. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or executive approval required).  
3. **Validate** that incident exists and has status of resolved using **discover_incident_entities**.  
4. **Update** incident status to closed and set closed_at timestamp using **manage_incidents**.  
5. **Create** an audit entry for incident closure using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing to close incident  
* Incident not found or status not resolved  
* Incident closure failed  
* Audit trail logging failure

---

## **Communication Management**

### **Create Communication**

1. **Obtain:**  
* **Required**: incident_id, sender_id, recipient_id, recipient_type (client, internal_team, executive, vendor, regulatory), communication_type (email, sms, phone_call, status_page, portal_update)  
* **Optional**: delivery_status (sent, delivered, failed, pending), sent_at  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( incident_manager or technical_support or system_administrator or account_manager approval required).  
3. **Validate** that incident exists using **discover_incident_entities**.  
4. **Validate** that sender and recipient exists and has active status using **discover_users**.  
5. **Create** the communication record using **manage_communications**.  
6. **Create** an audit entry for communication using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing approval  for creating communication record  
* Missing or invalid inputs  
* Incident not found  
* Sender not found or inactive  
* Recipient not found (if specified)  
* Invalid recipient_type or communication_type  
* Communication recording failed  
* Audit trail logging failure

## **Update Communication**

1. **Obtain:**  
* **Required**: communication_id  
* **Optional**: incident_id, sender_id, recipient_id, recipient_type (client, internal_team, executive, vendor, regulatory), communication_type (email, sms, phone_call, status_page, portal_update), delivery_status (sent, delivered, failed, pending), sent_at (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( incident_manager or technical_support or system_administrator or account_manager approval required).  
3. **Validate** that communication record exists using **discover_communication_entities**.  
4. If updating incident_id, sender_id, or recipient_id, validate that the communication record has delivery_status of "pending" using **discover_communication_entities**. These fields can only be updated when delivery_status is "pending".  
5. **If updating incident_id**, validate that incident exists using **discover_incident_entities**.  
6. **If updating sender_id**, validate that sender exists and has active status using **discover_users**.  
7. **If updating recipient_id**, validate that recipient exists using **discover_users**.  
8. **Update** the communication record using **manage_communications**.  
9. **Create** an audit entry for communication update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing to update communication record  
* Communication record not found  
* Incident not found (if updating incident_id)  
* Sender not found or inactive (if updating sender_id)  
* Recipient not found (if updating recipient_id)  
* Invalid recipient_type, communication_type, or delivery_status  
* Communication update failed  
* Audit trail logging failure

---

## **Workaround and Resolution Management**

### **Create Workaround**

1. **Obtain:**  
* **Required**: incident_id, implemented_by_id, effectiveness (complete, partial, minimal),implemented_at  
* **Optional**: status (active, inactive, replaced)   
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that incident exists and has status of open or in_progress using **discover_incident_entities**.  
4. **Create** the workaround record using **manage_work_arounds**.  
5. **Create** an audit entry for workaround implementation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Incident not found or invalid status  
* Implementing user not found or has invalid role  
* Invalid effectiveness level  
* Workaround creation failed  
* Audit trail logging failure

---

## **Update Workaround**

1. **Obtain:**  
* **Required**: workaround_id  
* **Optional**: effectiveness (complete, partial, minimal), status (active, inactive, replaced) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that workaround record exists using **discover_workaround_entities**.  
4. **Update** the workaround record using **manage_work_arounds**.  
5. **Create** an audit entry for workaround update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for workaround update  
* Workaround not found  
* Invalid effectiveness level or status  
* Workaround update failed  
* Audit trail logging failure

---

### **Conduct Root Cause Analysis**

1. **Obtain:**  
* **Required**: incident_id, conducted_by_id, analysis_method (five_whys, fishbone, timeline_analysis, fault_tree)  
* **Optional**: completed_at, status (in_progress, completed, approved)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that incident exists and has status of resolved or closed using **discover_incident_entities**.  
4. **Create** the root cause analysis record using **manage_root_cause_analysis**.  
5. **Create** an audit entry for RCA initiation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for conduct root cause analysis  
* Missing or invalid inputs  
* Incident not found or invalid status  
* Invalid analysis_method  
* RCA creation failed  
* Audit trail logging failure

---

### **Update Root Cause Analysis**

1. **Obtain:**  
* **Required**: rca_id  
* **Optional**: analysis_method (five_whys, fishbone, timeline_analysis, fault_tree), completed_at, status (in_progress, completed, approved) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that RCA record exists using **discover_rca_entities**.  
4. **Update** the RCA record using **manage_root_cause_analysis**.  
5. **Create** an audit entry for RCA update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for updating rca  
* RCA not found  
* Invalid analysis_method or status  
* RCA update failed  
* Audit trail logging failure

---

## **Escalation Management**

### **Create Escalation**

1. **Obtain:**  
* **Required**: incident_id, escalated_by_id, escalated_to_id, escalation_reason (sla_breach, severity_increase, resource_unavailable, executive_request, client_demand), escalated_at ,escalation_level (technical, management, executive, vendor)  
* **Optional**: acknowledged_at, resolved_at, status (open, acknowledged, resolved)  
2. **Validate** that incident exists and has status of open or in_progress using **discover_incident_entities**.  
3. **Validate** that escalated_by and escalated_to  user exists and has active status using **discover_users**.  
4. **Create** the escalation record using **manage_escalations**.  
5. **Create** an audit entry for escalation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Incident not found or invalid status  
* Escalating user not found or inactive  
* Escalation target user not found or has invalid role for level  
* Invalid escalation_reason or escalation_level  
* Escalation creation failed  
* Audit trail logging failure

---

### **Update Escalation Status**

1. **Obtain:**  
* **Required**: escalation_id  
* **Optional**: escalation_code, acknowledged_at, resolved_at, status (open, acknowledged, resolved) (at least one must be provided)  
2. **Validate** that escalation exists using **discover_escalation_entities**.  
3. **Update** the escalation record using **manage_escalations**.  
4. **Create** an audit entry for escalation update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Escalation not found  
* User not authorized to update escalation  
* Invalid status or timestamps  
* Escalation update failed  
* Audit trail logging failure

---

## **Change Management Operations**

### **Create Change Request**

1. **Obtain:**  
* **Required**: title, change_type (emergency, standard, normal), requested_by_id, risk_level (high, medium, low)  
* **Optional**: incident_id, approved_by_id, scheduled_start, scheduled_end, actual_start, actual_end, status (requested, approved, scheduled, in_progress, completed, failed, rolled_back)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required)..  
3. **If incident_id provided**, validate that incident exists using **discover_incident_entities**  
4. **Create** the change request record using **manage_change_requests**.  
5. **Create** an audit entry for change request using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing Approval for creating a change request  
* Missing or invalid inputs  
* Incident not found (if specified)  
* Invalid change_type, risk_level, or status  
* Change request creation failed  
* Audit trail logging failure

---

### **Update Change Request**

1. **Obtain:**  
* **Required**: change_id  
* **Optional**: title,change_code, change_type (emergency, standard, normal), approved_by_id, risk_level (high, medium, low), scheduled_start, scheduled_end, actual_start, actual_end, status (requested, approved, scheduled, in_progress, completed, failed, rolled_back) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that change request exists using **discover_change_entities**.  
4. **Update** the change request using **manage_change_requests**.  
5. **Create** an audit entry for change update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for update change request  
* Change request not found  
* User not authorized  
* Invalid change_type, risk_level, status, or timestamps  
* Change request update failed  
* Audit trail logging failure

---

### **Create Rollback Request**

1. **Obtain:**  
* **Required**: change_id, requested_by_id  
* **Optional**: incident_id, approved_by_id, executed_at, validation_completed, status (requested, approved, in_progress, completed, failed).  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or executive approval required)  
3. **Validate** that change request exists using **discover_change_entities**.  
4. **If incident_id provided**, validate that incident exists using **discover_incident_entities**.  
5. **Create** the rollback request using **manage_rollback_requests**.  
6. **Create** an audit entry for rollback request using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for rollback request  
* Missing or invalid inputs  
* Change request not found  
* Requesting user not found or has invalid role  
* Incident not found (if specified)  
* Rollback request creation failed  
* Audit trail logging failure

---

### **Update Rollback Request**

1. **Obtain:**  
* **Required**: rollback_id  
* **Optional**: rollback_code , approved_by_id, executed_at, validation_completed, status (requested, approved, in_progress, completed, failed) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (  incident_manager or system_administrator or executive approval required).  
3. **Validate** that rollback request exists using **discover_change_entities**.  
4. **Update** the rollback request using **manage_rollback_requests**.  
5. **Create** an audit entry for rollback update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing Approval for rollback request  
* Rollback request not found  
* User not authorized  
* Invalid status or timestamps  
* Rollback update failed  
* Audit trail logging failure

---

## **Metrics and Reporting Operations**

### **Record Performance Metrics**

1. **Obtain:**  
* **Required**: incident_id, metric_type (MTTA, MTTD, MTTR, MTTM, FTR), value_minutes  
* **Optional**: target_minutes, recorded_at  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( incident_manager or system_administrator approval required).  
3. **Validate** that incident exists and has status of resolved or closed using **discover_incident_entities**.  
4. **Create** the metrics record using **manage_metrics**.  
5. **Create** an audit entry for metrics recording using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Incident not found or invalid status  
* User not authorized  
* Invalid metric_type or value_minutes  
* Metrics recording failed  
* Audit trail logging failure

---

### **Generate Incident Report**

1. **Obtain:**  
* **Required**: incident_id, report_type ( executive_summary, technical_details,business_impact, compliance_report, post_mortem), generated_by_id  
* **Optional**: status (draft, completed, distributed)  
2. **Validate** that generating user exists and has appropriate role (incident_manager, executive) using **discover_users**..  
3. **Generate** the report using **manage_incident_reports**.  
4. **Create** an audit entry for report generation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing approval for generating report  
* Missing or invalid inputs  
* Invalid report_type or status  
* Incident not resolved/closed for post_mortem  
* Report generation failed  
* Audit trail logging failure

---

## **Knowledge Management Operations**

### **Create Knowledge Base Article**

1. **Obtain:**  
* **Required**: title, article_type (troubleshooting, resolution_steps, prevention_guide, faq), created_by_id, category(authentication_issues, payment_processing, api_integration, data_synchronization, system_outages, performance_degradation, security_incidents, backup_recovery, user_management, billing_issues, compliance_procedures, vendor_escalations, configuration_changes, monitoring_alerts, network_connectivity, database_issues, file_transfer_problems, reporting_errors, mobile_app_issues, browser_compatibility, third_party_integrations, scheduled_maintenance, emergency_procedures, client_onboarding, account_provisioning, sla_management, incident_response, change_management, capacity_planning, disaster_recovery)  
* **Optional**: incident_id, reviewed_by_id, view_count, status (draft, published, archived)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager approval required).  
3. **If incident_id provided**, validate that incident exists and is resolved or closed using **discover_incident_entities**.  
4. **If reviewed_by_id provided**, validate that reviewer exists and has appropriate role using **discover_users**.  
5. **Create** the knowledge base article using **manage_kb_articles**.  
6. **Create** an audit entry for article creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Creating user not found or has invalid role  
* Incident not found or invalid status (if specified)  
* Reviewer not found (if specified)  
* Invalid article_type, category, or status  
* Knowledge article creation failed  
* Audit trail logging failure

---

### **Update Knowledge Base Article**

1. **Obtain:**  
* **Required**: article_id  
* **Optional**: title, article_type (troubleshooting, resolution_steps, prevention_guide, faq), incident_id, reviewed_by_id, category, view_count, status (draft, published, archived) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager approval required).  
3. **Validate** that article exists using **discover_kb_article_entities**.  
4. **If updating reviewed_by_id**, validate that reviewer exists using **discover_users**.  
5. **Update** the knowledge article using **manage_kb_articles**.  
6. **Create** an audit entry for article update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Article not found  
* User not authorized  
* Reviewer not found (if specified)  
* Invalid article_type, category, or status  
* Article update failed  
* Audit trail logging failure

---

### **Create Post-Incident Review**

1. **Obtain:**  
* **Required**: incident_id, scheduled_date, facilitator_id  
* **Optional**: timeline_accuracy_rating, communication_effectiveness_rating, technical_response_rating, status (scheduled, completed, cancelled)   
2. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or executive approval required).  
3. **Validate** that incident exists and has status of resolved or closed using **discover_incident_entities**.  
4. **Validate** that facilitator exists and has an appropriate role (incident_manager, executive) using **discover_users**.  
5. **Create** the post-incident review record using **manage_post_incident_reviews**.  
6. **Create** an audit entry for PIR creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for PIR creation  
* Missing or invalid inputs  
* Incident not found or invalid status  
* Facilitator not found or has invalid role  
* Invalid scheduled_date or ratings  
* PIR creation failed  
* Audit trail logging failure

---

### **Update Post-Incident Review**

1. **Obtain:**  
* **Required**: pir_id  
* **Optional**: scheduled_date, facilitator_id, timeline_accuracy_rating, communication_effectiveness_rating, technical_response_rating, status (scheduled, completed, cancelled) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( incident_manager or executive approval required).  
3. **Validate** that PIR exists using **discover_incident_entities**..  
4. **Update** the post-incident review using **manage_post_incident_review**.  
5. **Create** an audit entry for PIR update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing  
* PIR not found  
* User not authorized  
* Invalid scheduled_date, ratings, or status  
* PIR update failed  
* Audit trail logging failure

---

## **Authority and Access Controls**

**Permission Validation**

All operations verify user authority based on:

* **role** field (incident_manager, technical_support, account_manager, executive, vendor_contact, system_administrator, client_contact)  
* **client_id** association through client_id field in users table  
* **vendor_id** association through vendor_id field in users table  
* **status** field must be active in users table

Operations requiring elevated permissions use a check_approval tool to verify proper authorization before proceeding.

# Database Schema:
// Use DBML to define your database structure
// Docs: https://dbml.dbdiagram.io/docs

// B2B Incident Management Database Schema
// This schema represents a comprehensive database for managing incidents,
// clients, products, infrastructure, and operational processes

Table clients {
  client_id string [primary key]
  client_name varchar(100) [not null]
  registration_number varchar(100)
  contact_email string
  client_type enum('enterprise','mid_market','small_business','startup') [not null]
  industry varchar(100)
  country varchar(100)
  status enum('active','inactive','suspended') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table vendors {
  vendor_id string [primary key]
  vendor_name varchar(100) [not null]
  vendor_type enum('cloud_provider','payment_processor','software_vendor','infrastructure_provider','security_vendor') [not null]
  contact_email varchar(100)
  contact_phone varchar(20)
  // escalation_contact varchar(100)
  status enum('active','inactive','suspended') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table users {
  user_id string [primary key]
  client_id string
  vendor_id string
  first_name varchar(100) [not null]
  last_name varchar(100) [not null]
  email varchar(320) [not null, unique]
  phone varchar(20)
  role enum('incident_manager','technical_support', 'account_manager','executive','vendor_contact','system_administrator', 'client_contact') [not null]
  department varchar(100)
  timezone varchar(50) [not null]
  status enum('active','inactive','on_leave') [not null, default: 'active']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table products {
  product_id string [primary key]
  product_name varchar(100) [not null]
  product_type enum('payment_processing','banking_system','api_gateway','data_integration','reporting_platform','security_service','backup_service','monitoring_tool') [not null]
  version varchar(50)
  vendor_support_id string // references vendors.vendor_id
  // internal_team_lead_id string // references users.user_id
  status enum('active','deprecated','maintenance') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table infrastructure_components {
  component_id string [primary key]
  product_id string
  component_name varchar(100) [not null]
  component_type enum('sftp_server','api_endpoint','database','load_balancer','firewall','authentication_service','payment_gateway','file_storage','monitoring_system') [not null]
  environment enum('production','staging','development','test') [not null]
  location varchar(100)
  port_number int
  status enum('online','offline','maintenance','degraded') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table client_subscriptions {
  subscription_id string [primary key]
  client_id string [not null]
  product_id string [not null]
  subscription_type enum('full_service','limited_service','trial','custom') [not null]
  start_date date [not null]
  end_date date
  sla_tier enum('premium','standard','basic') [not null]
  rto_hours int [not null] // Recovery Time Objective
  status enum('active','expired','cancelled','suspended') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table sla_agreements {
  sla_id string [primary key]
  subscription_id string [not null]
  severity_level enum('P1','P2','P3','P4') [not null]
  response_time_minutes int [not null]
  resolution_time_hours int [not null]
  availability_percentage decimal(5,2)
  created_at timestamp [not null, default: `NOW()`]
}

Table incidents {
  incident_id string [primary key]
  incident_code varchar(50) [unique, not null] // e.g., 'INC-2024-00123', 'INCIDENT-001234'
  title varchar(100) [not null]
  reporter_id string [not null]
  assigned_manager_id string
  client_id string [not null]
  component_id string
  // vendor_id string // For vendor-related incidents
  // vendor_ticket_id varchar(100) // Vendor's ticket reference
  // vendor_status varchar(100) // Status from vendor side
  // vendor_estimated_resolution timestamp // Vendor's ETA
  severity enum('P1','P2','P3','P4') [not null]
  status enum('open','in_progress','resolved','closed') [not null]
  impact enum('critical','high','medium','low') [not null]
  urgency enum('critical','high','medium','low') [not null]
  // category enum('client_onboarding','client_support','client_escalation','data_update','system_outage','security_breach','performance_issue','integration_failure','vendor_issue') [not null]
  
  // Technical categories - WHAT went wrong
  category enum(
    'system_outage',
    'performance_degradation',
    'security_incident',
    'data_corruption',
    'integration_failure',
    'network_issue',
    'hardware_failure',
    'software_bug',
    'configuration_error',
    'capacity_issue',
    'backup_failure',
    'authentication_failure',
    'api_error',
    'database_issue',
    'service_unavailable'
  ) [not null]
  
  // Business/operational context - WHO is affected and WHY it matters
  detection_source enum(
    'client_reported',
    'internally_detected',
    'monitoring_alert',
    'vendor_reported',
    'scheduled_maintenance',
    'emergency_maintenance'
  ) [not null]
  
  detected_at timestamp [not null]
  resolved_at timestamp
  closed_at timestamp
  rto_breach boolean [default: false]
  sla_breach boolean [default: false]
  is_recurring boolean [default: false]
  downtime_minutes int
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

// Table incident_updates {
//   update_id string [primary key]
//   incident_id string [not null]
//   updated_by_id string [not null]
//   update_type enum('status_change','severity_change','assignment','workaround','resolution','communication') [not null]
//   field_name varchar(50) [not null]
//   old_value varchar(100)
//   new_value varchar(100)
//   created_at timestamp [not null, default: `NOW()`]
// }

Table audit_log {
  audit_id string [primary key]
  entity_type varchar(100) [not null] // Which table was modified (e.g., 'incidents', 'clients', 'users')
  entity_id string [not null] // ID of the record that changed
  operation_type enum('INSERT','UPDATE','DELETE') [not null]
  changed_by_id string [not null] // User who made the change
  field_name varchar(100) // Specific field that changed (can be null for multi-field updates)
  old_value text // Previous value
  new_value text // New value
  created_at timestamp [not null, default: `NOW()`]
}

Table workarounds {
  workaround_id string [primary key]
  incident_id string [not null]
  implemented_by_id string [not null]
  effectiveness enum('complete','partial','minimal') [not null]
  status enum('active','inactive','replaced') [not null]
  implemented_at timestamp [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table root_cause_analysis {
  rca_id string [primary key]
  incident_id string [not null]
  analysis_method enum('five_whys','fishbone','timeline_analysis','fault_tree') [not null]
  conducted_by_id string [not null]
  completed_at timestamp
  status enum('in_progress','completed','approved') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table communications {
  communication_id string [primary key]
  incident_id string [not null]
  sender_id string [not null]
  recipient_id string
  recipient_type enum('client','internal_team','executive','vendor','regulatory') [not null]
  communication_type enum('email','sms','phone_call','status_page','portal_update') [not null]
  sent_at timestamp [not null]
  delivery_status enum('sent','delivered','failed','pending') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table escalations {
  escalation_id string [primary key]
  escalation_code varchar(50) [unique, not null] // e.g., 'ESC-2024-00789', 'ESCALATION-001234'
  incident_id string [not null]
  escalated_by_id string [not null]
  escalated_to_id string [not null]
  escalation_reason enum('sla_breach','severity_increase','resource_unavailable','executive_request','client_demand') [not null]
  escalation_level enum('technical','management','executive','vendor') [not null]
  escalated_at timestamp [not null]
  acknowledged_at timestamp
  resolved_at timestamp
  status enum('open','acknowledged','resolved') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table change_requests {
  change_id string [primary key]
  change_code varchar(50) [unique, not null] // e.g., 'CHG-2024-00456', 'CR-001234'
  incident_id string
  title varchar(100) [not null]
  change_type enum('emergency','standard','normal') [not null]
  requested_by_id string [not null]
  approved_by_id string
  risk_level enum('high','medium','low') [not null]
  scheduled_start timestamp
  scheduled_end timestamp
  actual_start timestamp
  actual_end timestamp
  status enum('requested','approved','scheduled','in_progress','completed','failed','rolled_back') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table rollback_requests {
  rollback_id string [primary key]
  rollback_code varchar(50) [unique, not null] // e.g., 'RBK-2024-00321', 'ROLLBACK-001234'
  change_id string [not null]
  incident_id string
  requested_by_id string [not null]
  approved_by_id string
  executed_at timestamp
  validation_completed boolean [default: false]
  status enum('requested','approved','in_progress','completed','failed') [not null]
  created_at timestamp [not null, default: `NOW()`]
}



// Vendor incidents are now handled directly in the incidents table
// with vendor_id and vendor_ticket_id fields

Table metrics {
  metric_id string [primary key]
  incident_id string [not null]
  metric_type enum('MTTA','MTTD','MTTR','MTTM','FTR') [not null]
  value_minutes int [not null]
  target_minutes int
  recorded_at timestamp [not null]
  created_at timestamp [not null, default: `NOW()`]
}

// Table compliance_events {
//   compliance_id string [primary key]
//   incident_id string [not null]
//   regulation_type enum('GDPR','HIPAA','SOX','PCI_DSS','FFIEC','CCPA','FCC','NERC') [not null]
//   event_type enum('breach_assessment','notification_required','reporting_deadline','audit_trigger') [not null]
//   deadline timestamp
//   completed_at timestamp
//   responsible_party_id string [not null]
//   status enum('pending','in_progress','completed','overdue') [not null]
//   created_at timestamp [not null, default: `NOW()`]
// }

Table incident_reports {
  report_id string [primary key]
  incident_id string [not null]
  report_type enum('executive_summary','technical_details','business_impact','compliance_report','post_mortem') [not null]
  generated_by_id string [not null]
  generated_at timestamp [not null]
  status enum('draft','completed','distributed') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table knowledge_base_articles {
  article_id string [primary key]
  // article_code varchar(50) [unique, not null] // e.g., 'KB-00741'
  incident_id string
  title varchar(100) [not null]
  article_type enum('troubleshooting','resolution_steps','prevention_guide','faq') [not null]
  created_by_id string [not null]
  reviewed_by_id string
  category enum(
    'authentication_issues',
    'payment_processing', 
    'api_integration',
    'data_synchronization',
    'system_outages',
    'performance_degradation',
    'security_incidents',
    'backup_recovery',
    'user_management',
    'billing_issues',
    'compliance_procedures',
    'vendor_escalations',
    'configuration_changes',
    'monitoring_alerts',
    'network_connectivity',
    'database_issues',
    'file_transfer_problems',
    'reporting_errors',
    'mobile_app_issues',
    'browser_compatibility',
    'third_party_integrations',
    'scheduled_maintenance',
    'emergency_procedures',
    'client_onboarding',
    'account_provisioning',
    'sla_management',
    'incident_response',
    'change_management',
    'capacity_planning',
    'disaster_recovery'
  )
  view_count int [default: 0]
  status enum('draft','published','archived') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table post_incident_reviews {
  pir_id string [primary key]
  incident_id string [not null]
  scheduled_date timestamp [not null]
  facilitator_id string [not null]
  timeline_accuracy_rating int
  communication_effectiveness_rating int
  technical_response_rating int
  status enum('scheduled','completed','cancelled') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

// Relationships
Ref: users.client_id > clients.client_id
Ref: users.vendor_id > vendors.vendor_id
// Ref: products.internal_team_lead_id > users.user_id
Ref: products.vendor_support_id > vendors.vendor_id
Ref: client_subscriptions.client_id > clients.client_id
Ref: client_subscriptions.product_id > products.product_id
Ref: sla_agreements.subscription_id > client_subscriptions.subscription_id
Ref: incidents.reporter_id > users.user_id
Ref: incidents.assigned_manager_id > users.user_id
Ref: incidents.client_id > clients.client_id
Ref: incidents.component_id > infrastructure_components.component_id
// Ref: incidents.vendor_id > vendors.vendor_id
// Ref: incident_updates.incident_id > incidents.incident_id
// Ref: incident_updates.updated_by_id > users.user_id
Ref: workarounds.incident_id > incidents.incident_id
Ref: workarounds.implemented_by_id > users.user_id
Ref: root_cause_analysis.incident_id > incidents.incident_id
Ref: root_cause_analysis.conducted_by_id > users.user_id
Ref: communications.incident_id > incidents.incident_id
Ref: communications.sender_id > users.user_id
Ref: escalations.incident_id > incidents.incident_id
Ref: escalations.escalated_by_id > users.user_id
Ref: escalations.escalated_to_id > users.user_id
Ref: change_requests.incident_id > incidents.incident_id
Ref: change_requests.requested_by_id > users.user_id
Ref: change_requests.approved_by_id > users.user_id
Ref: rollback_requests.change_id > change_requests.change_id
Ref: rollback_requests.incident_id > incidents.incident_id
Ref: rollback_requests.requested_by_id > users.user_id
Ref: rollback_requests.approved_by_id > users.user_id
Ref: metrics.incident_id > incidents.incident_id
// Ref: compliance_events.incident_id > incidents.incident_id
// Ref: compliance_events.responsible_party_id > users.user_id
Ref: incident_reports.incident_id > incidents.incident_id
Ref: incident_reports.generated_by_id > users.user_id
Ref: knowledge_base_articles.incident_id > incidents.incident_id
Ref: knowledge_base_articles.created_by_id > users.user_id
Ref: knowledge_base_articles.reviewed_by_id > users.user_id
Ref: post_incident_reviews.incident_id > incidents.incident_id
Ref: post_incident_reviews.facilitator_id > users.user_id
Ref: infrastructure_components.product_id > products.product_id

You have to provide the json file for each function separately including all the tests for that function in the actions part. You are going to provide the bash script that will create and populate those json files in a folder named tools_regression_tests/interface_1/.

Note: ids are just numeric strings "1", "2", ...
