Assume you are an experienced tester. I am going to give you python functions and you are going to give me the inputs to test this function. The inputs are provided in the form of actions. You have to provide two tests for each function with the most number of parameters as possible (if applicable). However, you have to follow the format that I provide to you below.

# Format:
{
    "env": "incident_management_experts",
    "interface_num": 1,
    "task": {
        "actions": [
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            },
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            }
        ]
    }
}

where the name of action is the function name and the arguments are the parameters of the function. You have to provide multiple actions for a single file in a single test if applicable. 

# Functions:
import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverKnowledgeArticleEntities(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover knowledge base article entities.
        
        Supported entities:
        - knowledge_base_articles: Knowledge base article records
        """
        if entity_type not in ["knowledge_base_articles"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'knowledge_base_articles'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get("knowledge_base_articles", {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "article_id": str(entity_id)})
            else:
                results.append({**entity_data, "article_id": str(entity_id)})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_knowledge_article_entities",
                "description": "Discover knowledge base article entities. Entity types: 'knowledge_base_articles' (knowledge base article records; filterable by article_id (string), incident_id (string), title (string), article_type (enum: 'troubleshooting', 'resolution_steps', 'prevention_guide', 'faq'), created_by_id (string), reviewed_by_id (string), category (enum: 'authentication_issues', 'payment_processing', 'api_integration', 'data_synchronization', 'system_outages', 'performance_degradation', 'security_incidents', 'backup_recovery', 'user_management', 'billing_issues', 'compliance_procedures', 'vendor_escalations', 'configuration_changes', 'monitoring_alerts', 'network_connectivity', 'database_issues', 'file_transfer_problems', 'reporting_errors', 'mobile_app_issues', 'browser_compatibility', 'third_party_integrations', 'scheduled_maintenance', 'emergency_procedures', 'client_onboarding', 'account_provisioning', 'sla_management', 'incident_response', 'change_management', 'capacity_planning', 'disaster_recovery'), view_count (int), status (enum: 'draft', 'published', 'archived'), created_at (timestamp), updated_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'knowledge_base_articles'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For knowledge_base_articles, filters are: article_id (string), incident_id (string), title (string), article_type (enum: 'troubleshooting', 'resolution_steps', 'prevention_guide', 'faq'), created_by_id (string), reviewed_by_id (string), category (enum: 'authentication_issues', 'payment_processing', 'api_integration', 'data_synchronization', 'system_outages', 'performance_degradation', 'security_incidents', 'backup_recovery', 'user_management', 'billing_issues', 'compliance_procedures', 'vendor_escalations', 'configuration_changes', 'monitoring_alerts', 'network_connectivity', 'database_issues', 'file_transfer_problems', 'reporting_errors', 'mobile_app_issues', 'browser_compatibility', 'third_party_integrations', 'scheduled_maintenance', 'emergency_procedures', 'client_onboarding', 'account_provisioning', 'sla_management', 'incident_response', 'change_management', 'capacity_planning', 'disaster_recovery'), view_count (int), status (enum: 'draft', 'published', 'archived'), created_at (timestamp), updated_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverIncidentEntities(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover incident-related entities.
        
        Supported entities:
        - incidents: Incident records
        - incident_reports: Incident report records
        - post_incident_reviews: Post-incident review records
        """
        if entity_type not in ["incidents", "incident_reports", "post_incident_reviews"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'incidents', 'incident_reports', or 'post_incident_reviews'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        # Determine the ID field based on entity type
        id_field_map = {
            "incidents": "incident_id",
            "incident_reports": "report_id",
            "post_incident_reviews": "pir_id"
        }
        id_field = id_field_map[entity_type]
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, id_field: str(entity_id)})
            else:
                results.append({**entity_data, id_field: str(entity_id)})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_incident_entities",
                "description": "Discover incident-related entities. Entity types: 'incidents' (incident records; filterable by incident_id (string), incident_code (string), title (string), reporter_id (string), assigned_manager_id (string), client_id (string), component_id (string), severity (enum: 'P1', 'P2', 'P3', 'P4'), status (enum: 'open', 'in_progress', 'resolved', 'closed'), impact (enum: 'critical', 'high', 'medium', 'low'), urgency (enum: 'critical', 'high', 'medium', 'low'), category (enum: 'system_outage', 'performance_degradation', 'security_incident', 'data_corruption', 'integration_failure', 'network_issue', 'hardware_failure', 'software_bug', 'configuration_error', 'capacity_issue', 'backup_failure', 'authentication_failure', 'api_error', 'database_issue', 'service_unavailable'), detection_source (enum: 'client_reported', 'internally_detected', 'monitoring_alert', 'vendor_reported', 'scheduled_maintenance', 'emergency_maintenance'), detected_at (timestamp), resolved_at (timestamp), closed_at (timestamp), rto_breach (boolean: True/False), sla_breach (boolean: True/False), is_recurring (boolean: True/False), downtime_minutes (int), created_at (timestamp), updated_at (timestamp)); 'incident_reports' (incident report records; filterable by report_id (string), incident_id (string), report_type (enum: 'executive_summary', 'technical_details', 'business_impact', 'compliance_report', 'post_mortem'), generated_by_id (string), generated_at (timestamp), status (enum: 'draft', 'completed', 'distributed'), created_at (timestamp)); 'post_incident_reviews' (post-incident review records; filterable by pir_id (string), incident_id (string), scheduled_date (timestamp), facilitator_id (string), timeline_accuracy_rating (int), communication_effectiveness_rating (int), technical_response_rating (int), status (enum: 'scheduled', 'completed', 'cancelled'), created_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'incidents', 'incident_reports', or 'post_incident_reviews'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For incidents, filters are: incident_id (string), incident_code (string), title (string), reporter_id (string), assigned_manager_id (string), client_id (string), component_id (string), severity (enum: 'P1', 'P2', 'P3', 'P4'), status (enum: 'open', 'in_progress', 'resolved', 'closed'), impact (enum: 'critical', 'high', 'medium', 'low'), urgency (enum: 'critical', 'high', 'medium', 'low'), category (enum: 'system_outage', 'performance_degradation', 'security_incident', 'data_corruption', 'integration_failure', 'network_issue', 'hardware_failure', 'software_bug', 'configuration_error', 'capacity_issue', 'backup_failure', 'authentication_failure', 'api_error', 'database_issue', 'service_unavailable'), detection_source (enum: 'client_reported', 'internally_detected', 'monitoring_alert', 'vendor_reported', 'scheduled_maintenance', 'emergency_maintenance'), detected_at (timestamp), resolved_at (timestamp), closed_at (timestamp), rto_breach (boolean: True/False), sla_breach (boolean: True/False), is_recurring (boolean: True/False), downtime_minutes (int), created_at (timestamp), updated_at (timestamp). For incident_reports, filters are: report_id (string), incident_id (string), report_type (enum: 'executive_summary', 'technical_details', 'business_impact', 'compliance_report', 'post_mortem'), generated_by_id (string), generated_at (timestamp), status (enum: 'draft', 'completed', 'distributed'), created_at (timestamp). For post_incident_reviews, filters are: pir_id (string), incident_id (string), scheduled_date (timestamp), facilitator_id (string), timeline_accuracy_rating (int), communication_effectiveness_rating (int), technical_response_rating (int), status (enum: 'scheduled', 'completed', 'cancelled'), created_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageKbArticles(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, article_data: Dict[str, Any] = None, article_id: str = None) -> str:
        """
        Create or update knowledge base articles.

        Actions:
        - create: requires article_data with title, article_type, created_by_id, category
        - update: requires article_id and article_data with fields to update
        """

        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        kb_articles = data.get("knowledge_base_articles", {})
        users = data.get("users", {})
        incidents = data.get("incidents", {})

        valid_article_types = ["troubleshooting", "resolution_steps", "prevention_guide", "faq"]
        valid_categories = [
            "authentication_issues", "payment_processing", "api_integration", "data_synchronization",
            "system_outages", "performance_degradation", "security_incidents", "backup_recovery",
            "user_management", "billing_issues", "compliance_procedures", "vendor_escalations",
            "configuration_changes", "monitoring_alerts", "network_connectivity", "database_issues",
            "file_transfer_problems", "reporting_errors", "mobile_app_issues", "browser_compatibility",
            "third_party_integrations", "scheduled_maintenance", "emergency_procedures", "client_onboarding",
            "account_provisioning", "sla_management", "incident_response", "change_management",
            "capacity_planning", "disaster_recovery"
        ]
        valid_statuses = ["draft", "published", "archived"]

        if action == "create":
            if not article_data:
                return json.dumps({
                    "success": False,
                    "error": "article_data is required for create action"
                })

            required_fields = ["title", "article_type", "created_by_id", "category"]
            missing = [f for f in required_fields if f not in article_data or not article_data.get(f)]
            if missing:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields for article creation: {', '.join(missing)}"
                })

            title = article_data["title"]
            article_type = article_data["article_type"]
            created_by_id = str(article_data["created_by_id"])
            category = article_data["category"]
            incident_id = article_data.get("incident_id")
            reviewed_by_id = article_data.get("reviewed_by_id")
            view_count = article_data.get("view_count", 0)
            status = article_data.get("status", "draft")

            # Validations
            if article_type not in valid_article_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid article_type. Must be one of: {', '.join(valid_article_types)}"
                })

            if category not in valid_categories:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid category. Must be one of: {', '.join(valid_categories)}"
                })

            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
                })

            if incident_id:
                if incident_id not in incidents:
                    return json.dumps({"success": False, "error": f"Incident {incident_id} not found"})
                if incidents[incident_id].get("status") not in ["resolved", "closed"]:
                    return json.dumps({"success": False, "error": f"Incident must be resolved or closed"})

            if reviewed_by_id and reviewed_by_id not in users:
                return json.dumps({"success": False, "error": f"Reviewer {reviewed_by_id} not found"})

            if not isinstance(view_count, int) or view_count < 0:
                return json.dumps({"success": False, "error": "view_count must be a non-negative integer"})

            new_article_id = generate_id(kb_articles)
            new_article = {
                "article_id": str(new_article_id),
                "incident_id": incident_id,
                "title": title,
                "article_type": article_type,
                "created_by_id": created_by_id,
                "reviewed_by_id": reviewed_by_id,
                "category": category,
                "view_count": view_count,
                "status": status,
                "created_at": "2025-10-02T12:00:00",
                "updated_at": "2025-10-02T12:00:00"
            }

            kb_articles[str(new_article_id)] = new_article
            return json.dumps({
                "success": True, 
                "action": "create", 
                "article_id": str(new_article_id),
                "message": f"KB article {new_article_id} created successfully", 
                "article_data": new_article
            })

        elif action == "update":
            if not article_id:
                return json.dumps({"success": False, "error": "article_id is required for update action"})
            if article_id not in kb_articles:
                return json.dumps({"success": False, "error": f"Knowledge base article {article_id} not found"})
            if not article_data:
                return json.dumps({"success": False, "error": "article_data is required for update action"})

            current_article = kb_articles[article_id].copy()
            for key in ["title", "article_type", "incident_id", "reviewed_by_id", "category", "view_count", "status"]:
                if key in article_data:
                    value = article_data[key]
                    # Validation for certain fields
                    if key == "article_type" and value not in valid_article_types:
                        return json.dumps({"success": False, "error": f"Invalid article_type. Must be one of: {', '.join(valid_article_types)}"})
                    if key == "category" and value not in valid_categories:
                        return json.dumps({"success": False, "error": f"Invalid category. Must be one of: {', '.join(valid_categories)}"})
                    if key == "status" and value not in valid_statuses:
                        return json.dumps({"success": False, "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"})
                    if key == "incident_id" and value and value not in incidents:
                        return json.dumps({"success": False, "error": f"Incident {value} not found"})
                    if key == "reviewed_by_id" and value and value not in users:
                        return json.dumps({"success": False, "error": f"Reviewer {value} not found"})
                    if key == "view_count" and (not isinstance(value, int) or value < 0):
                        return json.dumps({"success": False, "error": "view_count must be a non-negative integer"})
                    current_article[key] = value

            current_article["updated_at"] = "2025-10-02T12:00:00"
            kb_articles[article_id] = current_article
            return json.dumps({
                "success": True, 
                "action": "update", 
                "article_id": article_id,
                "message": f"KB article {article_id} updated successfully",
                "article_data": current_article
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_kb_articles",
                "description": "Create or update knowledge base articles in the incident management system. Supports creation with proper role validation and article categorization, and updates with field-level validation.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {"type": "string", "enum": ["create", "update"], "description": "Action to perform"},
                        "article_id": {"type": "string", "description": "ID of the KB article (required for update)"},
                        "article_data": {"type": "object", "description": "Article fields for create or update"}
                    },
                    "required": ["action"]
                }
            }
        }


# -----------------

# Copyright Sierra

from typing import Any, Dict
from tau_bench.envs.tool import Tool


class TransferToHuman(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        summary: str,
    ) -> str:
        return "Transfer successful"

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "transfer_to_human",
                "description": "Transfer the user to a human agent, with a summary of the user's issue. Only transfer if the user explicitly asks for a human agent, or if the user's issue cannot be resolved by the agent with the available tools.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "summary": {
                            "type": "string",
                            "description": "A summary of the user's issue.",
                        },
                    },
                    "required": [
                        "summary",
                    ],
                },
            },
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverWorkaroundEntities(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover workaround entities.
        
        Supported entities:
        - workarounds: Workaround records
        """
        if entity_type not in ["workarounds"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'workarounds'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get("workarounds", {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "workaround_id": str(entity_id)})
            else:
                results.append({**entity_data, "workaround_id": str(entity_id)})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_workaround_entities",
                "description": "Discover workaround entities. Entity types: 'workarounds' (workaround records; filterable by workaround_id (string), incident_id (string), implemented_by_id (string), effectiveness (enum: 'complete', 'partial', 'minimal'), status (enum: 'active', 'inactive', 'replaced'), implemented_at (timestamp), created_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'workarounds'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For workarounds, filters are: workaround_id (string), incident_id (string), implemented_by_id (string), effectiveness (enum: 'complete', 'partial', 'minimal'), status (enum: 'active', 'inactive', 'replaced'), implemented_at (timestamp), created_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

from .discover_clients import DiscoverClients
from .discover_vendors import DiscoverVendors
from .discover_users import DiscoverUsers
from .discover_products import DiscoverProducts
from .discover_components import DiscoverComponents
from .discover_subscription_agreements import DiscoverSubscriptionAgreements
from .discover_change_entities import DiscoverChangeEntities
from .discover_incident_entities import DiscoverIncidentEntities
from .discover_knowledge_article_entities import DiscoverKnowledgeArticleEntities
from .discover_metrics_entities import DiscoverMetricsEntities
from .discover_root_cause_analysis_entities import DiscoverRootCauseAnalysisEntities
from .discover_workaround_entities import DiscoverWorkaroundEntities

from .manage_clients import ManageClients
from .manage_vendors import ManageVendors
from .manage_users import ManageUsers
from .manage_products import ManageProducts
from .manage_components import ManageComponents
from .manage_client_subscriptions import ManageClientSubscriptions
from .manage_sla_agreements import ManageSlaAgreements
from .manage_change_requests import ManageChangeRequests
from .manage_communications import ManageCommunications
from .manage_escalations import ManageEscalations
from .manage_incident_reports import ManageIncidentReports
from .manage_kb_articles import ManageKbArticles
from .manage_metrics import ManageMetrics
from .manage_post_incident_reviews import ManagePostIncidentReviews
from .manage_rollback_requests import ManageRollbackRequests
from .log_audit_records import LogAuditRecords
from .manage_incidents import ManageIncidents
from .manage_root_cause_analysis import ManageRootCauseAnalysis
from .manage_work_arounds import ManageWorkArounds

ALL_TOOLS_INTERFACE_1 = [
    DiscoverClients,
    DiscoverVendors,
    DiscoverUsers,
    DiscoverProducts,
    DiscoverComponents,
    DiscoverSubscriptionAgreements,
    DiscoverChangeEntities,
    DiscoverIncidentEntities,
    DiscoverKnowledgeArticleEntities,
    DiscoverMetricsEntities,
    DiscoverRootCauseAnalysisEntities,
    DiscoverWorkaroundEntities,
    ManageClients,
    ManageVendors,
    ManageUsers,
    ManageProducts,
    ManageComponents,
    ManageClientSubscriptions,
    ManageSlaAgreements,
    ManageChangeRequests,
    ManageCommunications,
    ManageEscalations,
    ManageIncidentReports,
    ManageKbArticles,
    ManageMetrics,
    ManagePostIncidentReviews,
    ManageRollbackRequests,
    LogAuditRecords,
    ManageIncidents,
    ManageRootCauseAnalysis,
    ManageWorkArounds,
]


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageRollbackRequests(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, rollback_data: Dict[str, Any], rollback_id: str = None) -> str:
        """
        Create or update rollback request records.

        rollback_data must include:
        - action (required): 'create' or 'update'
        For create:
            - change_id (required)
            - requested_by_id (required)
            - Optional: incident_id, approved_by_id, executed_at, validation_completed, status
        For update:
            - rollback_id (required)
            - Optional: approved_by_id, executed_at, validation_completed, status
        """

        def generate_id(table:  Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        def generate_code(prefix: str, table: Dict[str, Any]) -> str:
            max_num = 0
            for record in table.values():
                code = record.get("rollback_code", "")
                if code.startswith(prefix):
                    try:
                        num = int(code.split("-")[-1])
                        max_num = max(max_num, num)
                    except:
                        pass
            return f"{prefix}-{str(max_num + 1).zfill(5)}"

        rollback_requests = data.get("rollback_requests", {})
        change_requests = data.get("change_requests", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        change_id = rollback_data.get("change_id")
        requested_by_id = rollback_data.get("requested_by_id")
        incident_id = rollback_data.get("incident_id")
        approved_by_id = rollback_data.get("approved_by_id")
        executed_at = rollback_data.get("executed_at")
        validation_completed = rollback_data.get("validation_completed")
        status = rollback_data.get("status")

        valid_statuses = ["requested", "approved", "in_progress", "completed", "failed"]

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False, 
                "error": f"Invalid {action}. Must be 'create' or 'update'"
            })

        if action == "create":
            if not all([change_id, requested_by_id]):
                return json.dumps({"success": False, "error": "change_id and requested_by_id are required for create"})

            if change_id not in change_requests:
                return json.dumps({"success": False, "error": f"Change request {change_id} not found"})

            if requested_by_id not in users:
                return json.dumps({"success": False, "error": f"Requesting user {requested_by_id} not found"})

            if users[requested_by_id].get("role") not in ["system_administrator", "executive", "incident_manager"]:
                return json.dumps({"success": False, "error": f"Invalid role for requesting user {requested_by_id}"})

            if incident_id and incident_id not in incidents:
                return json.dumps({"success": False, "error": f"Incident {incident_id} not found"})

            if status and status not in valid_statuses:
                return json.dumps({"success": False, "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"})

            new_id = generate_id(rollback_requests)
            rollback_code = generate_code("RBK-2025", rollback_requests)

            new_request = {
                "rollback_id": str(new_id),
                "rollback_code": rollback_code,
                "change_id": change_id,
                "incident_id": incident_id,
                "requested_by_id": requested_by_id,
                "approved_by_id": approved_by_id,
                "executed_at": executed_at,
                "validation_completed": validation_completed if validation_completed is not None else False,
                "status": status if status else "requested",
                "created_at": "2025-10-02T12:00:00"
            }

            rollback_requests[str(new_id)] = new_request

            return json.dumps({
                "success": True, 
                "action": "create", 
                "rollback_id": str(new_id),
                "message": f"Rollback request {new_id} created successfully", 
                "rollback_request_data": new_request
            })

        elif action == "update":
            if not rollback_id:
                return json.dumps({"success": False, "error": "rollback_id is required for update"})

            if rollback_id not in rollback_requests:
                return json.dumps({"success": False, "error": f"Rollback request {rollback_id} not found"})

            if not any([approved_by_id is not None, executed_at, validation_completed is not None, status]):
                return json.dumps({"success": False, "error": "At least one field must be provided for update"})

            if status and status not in valid_statuses:
                return json.dumps({"success": False, "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"})

            updated_request = rollback_requests[rollback_id].copy()
            for field, value in [("approved_by_id", approved_by_id), ("executed_at", executed_at),
                                 ("validation_completed", validation_completed), ("status", status)]:
                if value is not None:
                    updated_request[field] = value

            rollback_requests[rollback_id] = updated_request

            return json.dumps({
                "success": True, 
                "action": "update", 
                "rollback_id": rollback_id,
                "message": f"Rollback request {rollback_id} updated successfully", 
                "rollback_request_data": updated_request
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_rollback_requests",
                "description": "Create or update rollback request records in the incident management system. Tracks rollback execution, approvals, validation completion, and status progression. Ensures proper authorization from system administrators, executives, or incident managers. Essential for incident recovery, change management safety, and maintaining system reliability.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {"type": "string", "enum": ["create", "update"], "description": "Action to perform"},
                        "rollback_data": {
                            "type": "object",
                            "description": "Rollback request data",
                            "properties": {
                                "change_id": {"type": "string", "description": "Change request ID (required for create)"},
                                "requested_by_id": {"type": "string", "description": "Requesting user ID (required for create)"},
                                "incident_id": {"type": "string", "description": "Associated incident ID (optional)"},
                                "approved_by_id": {"type": "string", "description": "Approver user ID (optional)"},
                                "executed_at": {"type": "string", "description": "Execution timestamp YYYY-MM-DDTHH:MM:SS (optional)"},
                                "validation_completed": {"type": "boolean", "description": "Validation completed (optional)"},
                                "status": {"type": "string", "enum": ["requested", "approved", "in_progress", "completed", "failed"], "description": "Current status (optional)"}
                            },
                        },
                        "rollback_id": {"type": "string", "description": "ID of the Rollback request (required for update)"},
                    },
                    "required": ["action"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool


class ManageVendors(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, vendor_data: Dict[str, Any] = None, vendor_id: str = None) -> str:
        """
        Create or update vendor records.

        Actions:
        - create: Create new vendor (requires vendor_data with vendor_name, vendor_type)
        - update: Update existing vendor (requires vendor_id and vendor_data with fields to change)
        """
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for vendors"
            })

        vendors = data.get("vendors", {})

        valid_vendor_types = ["cloud_provider", "payment_processor", "software_vendor", "infrastructure_provider", "security_vendor"]
        valid_statuses = ["active", "inactive", "suspended"]

        if action == "create":
            if not vendor_data:
                return json.dumps({
                    "success": False,
                    "error": "vendor_data is required for create action"
                })

            # Required fields
            required_fields = ["vendor_name", "vendor_type"]
            missing = [f for f in required_fields if f not in vendor_data or not vendor_data.get(f)]
            if missing:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields for vendor creation: {', '.join(missing)}"
                })

            vendor_name = vendor_data["vendor_name"]
            vendor_type = vendor_data["vendor_type"]
            contact_email = vendor_data.get("contact_email")
            contact_phone = vendor_data.get("contact_phone")
            status = vendor_data.get("status", "active")

            # Validate vendor_type
            if vendor_type not in valid_vendor_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid vendor_type. Must be one of: {', '.join(valid_vendor_types)}"
                })

            # Validate status
            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
                })

            # Check uniqueness of vendor_name
            for existing_vendor in vendors.values():
                if existing_vendor.get("vendor_name") == vendor_name:
                    return json.dumps({
                        "success": False,
                        "error": f"Vendor name '{vendor_name}' already exists"
                    })

            # Create vendor
            new_id = generate_id(vendors)
            new_vendor = {
                "vendor_id": str(new_id),
                "vendor_name": vendor_name,
                "vendor_type": vendor_type,
                "status": status,
                "created_at": "2025-10-04T12:00:00"
            }

            if contact_email:
                new_vendor["contact_email"] = contact_email
            if contact_phone:
                new_vendor["contact_phone"] = contact_phone

            vendors[str(new_id)] = new_vendor

            return json.dumps({
                "success": True,
                "action": "create",
                "vendor_id": str(new_id),
                "message": f"Vendor {new_id} created successfully",
                "vendor_data": new_vendor
            })

        elif action == "update":
            if not vendor_id:
                return json.dumps({
                    "success": False,
                    "error": "vendor_id is required for update action"
                })

            if vendor_id not in vendors:
                return json.dumps({
                    "success": False,
                    "error": f"Vendor {vendor_id} not found"
                })

            if not vendor_data:
                return json.dumps({
                    "success": False,
                    "error": "vendor_data is required for update action"
                })

            current_vendor = vendors[vendor_id].copy()

            # Validate and update vendor_type
            if "vendor_type" in vendor_data:
                vt = vendor_data["vendor_type"]
                if vt not in valid_vendor_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid vendor_type. Must be one of: {', '.join(valid_vendor_types)}"
                    })
                current_vendor["vendor_type"] = vt

            # Validate and update status
            if "status" in vendor_data:
                st = vendor_data["status"]
                if st not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
                    })
                current_vendor["status"] = st

            # Check uniqueness of vendor_name if updating
            if "vendor_name" in vendor_data:
                new_name = vendor_data["vendor_name"]
                for vid, existing_vendor in vendors.items():
                    if vid != vendor_id and existing_vendor.get("vendor_name") == new_name:
                        return json.dumps({
                            "success": False,
                            "error": f"Vendor name '{new_name}' already exists"
                        })
                current_vendor["vendor_name"] = new_name

            # Update other fields
            for field in ["contact_email", "contact_phone"]:
                if field in vendor_data:
                    current_vendor[field] = vendor_data[field]

            vendors[vendor_id] = current_vendor

            return json.dumps({
                "success": True,
                "action": "update",
                "vendor_id": vendor_id,
                "message": f"Vendor {vendor_id} updated successfully",
                "vendor_data": current_vendor
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_vendors",
                "description": "Create or update vendor records in the incident management system. Validates uniqueness of vendor names. Supports cloud providers, payment processors, software vendors, infrastructure providers, and security vendors.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' or 'update'",
                            "enum": ["create", "update"]
                        },
                        "vendor_data": {
                            "type": "object",
                            "description": "Vendor data object. For create: requires vendor_name, vendor_type. For update: include fields to modify. SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "vendor_name": {"type": "string", "description": "Name of the vendor (required for create)"},
                                "vendor_type": {
                                    "type": "string",
                                    "description": "Type of vendor (required for create)",
                                    "enum": ["cloud_provider", "payment_processor", "software_vendor", "infrastructure_provider", "security_vendor"]
                                },
                                "contact_email": {"type": "string", "description": "Contact email (optional)"},
                                "contact_phone": {"type": "string", "description": "Contact phone (optional)"},
                                "status": {
                                    "type": "string",
                                    "description": "Vendor status (optional)",
                                    "enum": ["active", "inactive", "suspended"]
                                }
                            }
                        },
                        "vendor_id": {"type": "string", "description": "Unique identifier of the vendor (required for update action only)"}
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageCommunications(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, communication_data: Dict[str, Any] = None, communication_id: str = None) -> str:
        """
        Create or update communication records.

        Actions:
        - create: Create new communication (requires communication_data with incident_id, sender_id, recipient_type, communication_type)
        - update: Update existing communication (requires communication_id and communication_data with fields to change)
        """
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for communications"
            })

        communications = data.get("communications", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        # Allowed/enums
        valid_recipient_types = ["client", "internal_team", "executive", "vendor", "regulatory"]
        valid_communication_types = ["email", "sms", "phone_call", "status_page", "portal_update"]
        valid_delivery_statuses = ["sent", "delivered", "failed", "pending"]

        if action == "create":
            if not communication_data:
                return json.dumps({
                    "success": False,
                    "error": "communication_data is required for create action"
                })

            # Validate required fields for creation
            required_fields = ["incident_id", "sender_id", "recipient_type", "communication_type"]
            missing = [f for f in required_fields if f not in communication_data]
            if missing:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields for communication creation: {', '.join(missing)}"
                })

            # # Approval: require at least one of the roles
            # if not (communication_data.get("incident_manager") or communication_data.get("technical_support") or communication_data.get("system_administrator") or communication_data.get("account_manager")):
            #     return json.dumps({
            #         "success": False,
            #         "error": "Missing approval for creating communication record. Required: incident_manager OR technical_support OR system_administrator OR account_manager"
            #     })
            
            # Only allow known fields to be supplied
            allowed_fields = [
                "incident_id", "sender_id", "recipient_id", "recipient_type",
                "communication_type", "delivery_status", "sent_at"
            ]
            invalid_fields = [k for k in communication_data.keys() if k not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for communication creation: {', '.join(invalid_fields)}"
                })

            incident_id = str(communication_data["incident_id"])
            sender_id = str(communication_data["sender_id"])
            recipient_id = communication_data.get("recipient_id")
            recipient_type = communication_data["recipient_type"]
            communication_type = communication_data["communication_type"]
            delivery_status = communication_data.get("delivery_status")
            sent_at = communication_data.get("sent_at")

            # Validate incident exists
            if incident_id not in incidents:
                return json.dumps({
                    "success": False,
                    "error": f"Incident {incident_id} not found"
                })

            # Validate sender exists and is active
            if sender_id not in users:
                return json.dumps({
                    "success": False,
                    "error": f"Sender {sender_id} not found"
                })
            if users[sender_id].get("status") != "active":
                return json.dumps({
                    "success": False,
                    "error": f"Sender {sender_id} is not active"
                })

            # Validate recipient if specified
            if recipient_id and str(recipient_id) not in users:
                return json.dumps({
                    "success": False,
                    "error": f"Recipient {recipient_id} not found"
                })

            # Validate enums
            if recipient_type not in valid_recipient_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid recipient_type. Must be one of: {', '.join(valid_recipient_types)}"
                })

            if communication_type not in valid_communication_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid communication_type. Must be one of: {', '.join(valid_communication_types)}"
                })

            if delivery_status and delivery_status not in valid_delivery_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid delivery_status. Must be one of: {', '.join(valid_delivery_statuses)}"
                })

            # Generate ID and create record
            new_id = generate_id(communications)
            new_comm = {
                "communication_id": str(new_id),
                "incident_id": incident_id,
                "sender_id": sender_id,
                "recipient_id": str(recipient_id) if recipient_id is not None else None,
                "recipient_type": recipient_type,
                "communication_type": communication_type,
                "sent_at": sent_at if sent_at else "2025-10-02T12:00:00",
                "delivery_status": delivery_status if delivery_status else "pending",
                "created_at": "2025-10-02T12:00:00",
                "updated_at": "2025-10-02T12:00:00"
            }

            communications[str(new_id)] = new_comm

            return json.dumps({
                "success": True,
                "action": "create",
                "communication_id": str(new_id),
                "message": f"Communication {new_id} created successfully",
                "communication_data": new_comm
            })

        elif action == "update":
            if not communication_id:
                return json.dumps({
                    "success": False,
                    "error": "communication_id is required for update action"
                })

            if communication_id not in communications:
                return json.dumps({
                    "success": False,
                    "error": f"Communication {communication_id} not found"
                })

            if not communication_data:
                return json.dumps({
                    "success": False,
                    "error": "communication_data is required for update action"
                })

            # # Approval required for updates as well
            # if not (communication_data.get("incident_manager") or communication_data.get("technical_support") or communication_data.get("system_administrator") or communication_data.get("account_manager")):
            #     return json.dumps({
            #         "success": False,
            #         "error": "Missing approval for creating communication record. Required: incident_manager OR technical_support OR system_administrator OR account_manager"
            #     })

            # Only allow known update fields
            allowed_update_fields = [
                "incident_id", "sender_id", "recipient_id", "recipient_type",
                "communication_type", "delivery_status", "sent_at"
            ]
            invalid_fields = [k for k in communication_data.keys() if k not in allowed_update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for communication update: {', '.join(invalid_fields)}"
                })

            # At least one valid field must be present
            if not any(field in communication_data for field in allowed_update_fields):
                return json.dumps({
                    "success": False,
                    "error": "At least one updatable field must be provided in communication_data"
                })

            current_comm = communications[communication_id].copy()

            # Validate fields when present
            if "incident_id" in communication_data:
                incident_id = str(communication_data["incident_id"])
                if incident_id not in incidents:
                    return json.dumps({
                        "success": False,
                        "error": f"Incident {incident_id} not found"
                    })
                current_comm["incident_id"] = incident_id

            if "sender_id" in communication_data:
                sender_id = str(communication_data["sender_id"])
                if sender_id not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Sender {sender_id} not found"
                    })
                if users[sender_id].get("status") != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"Sender {sender_id} is not active"
                    })
                current_comm["sender_id"] = sender_id

            if "recipient_id" in communication_data:
                recipient_id = communication_data["recipient_id"]
                if recipient_id and str(recipient_id) not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Recipient {recipient_id} not found"
                    })
                current_comm["recipient_id"] = str(recipient_id) if recipient_id is not None else None

            if "recipient_type" in communication_data:
                recipient_type = communication_data["recipient_type"]
                if recipient_type not in valid_recipient_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid recipient_type. Must be one of: {', '.join(valid_recipient_types)}"
                    })
                current_comm["recipient_type"] = recipient_type

            if "communication_type" in communication_data:
                communication_type = communication_data["communication_type"]
                if communication_type not in valid_communication_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid communication_type. Must be one of: {', '.join(valid_communication_types)}"
                    })
                current_comm["communication_type"] = communication_type

            if "delivery_status" in communication_data:
                delivery_status = communication_data["delivery_status"]
                if delivery_status not in valid_delivery_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid delivery_status. Must be one of: {', '.join(valid_delivery_statuses)}"
                    })
                current_comm["delivery_status"] = delivery_status

            if "sent_at" in communication_data:
                current_comm["sent_at"] = communication_data["sent_at"]

            current_comm["updated_at"] = "2025-10-02T12:00:00"
            communications[communication_id] = current_comm

            return json.dumps({
                "success": True,
                "action": "update",
                "communication_id": str(communication_id),
                "message": f"Communication {communication_id} updated successfully",
                "communication_data": current_comm
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_communications",
                "description": "Create or update communication records in the incident management system. Tracks emails, SMS, phone calls, status page updates, and portal updates sent to stakeholders. Requires approval from incident managers, technical support, system administrators, or account managers.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new communication record, 'update' to modify existing record",
                            "enum": ["create", "update"]
                        },
                        "communication_data": {
                            "type": "object",
                            "description": "Communication data object. requires incident_id (incident ID), sender_id (sender ID), recipient_type (client/internal_team/executive/vendor/regulatory), communication_type (email/sms/phone_call/status_page/portal_update). For update: include communication fields to change. SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "incident_id": {"type": "string", "description": "ID of associated incident (required for create)"},
                                "sender_id": {"type": "string", "description": "ID of user sending the communication (required for create)"},
                                "recipient_id": {"type": "string", "description": "ID of the recipient user (optional)"},
                                "recipient_type": {
                                    "type": "string",
                                    "description": "Type of recipient (required for create)",
                                    "enum": ["client", "internal_team", "executive", "vendor", "regulatory"]
                                },
                                "communication_type": {
                                    "type": "string",
                                    "description": "Channel used for communication (required for create)",
                                    "enum": ["email", "sms", "phone_call", "status_page", "portal_update"]
                                },
                                "delivery_status": {
                                    "type": "string",
                                    "description": "Delivery status (optional)",
                                    "enum": ["sent", "delivered", "failed", "pending"]
                                },
                                "sent_at": {
                                    "type": "string",
                                    "description": "Timestamp when communication was sent (optional) in YYYY-MM-DDTHH:MM:SS"
                                }
                            }
                        },
                        "communication_id": {
                            "type": "string",
                            "description": "Unique identifier of the communication record (required for update action only)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class LogAuditRecords(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], audit_data: Dict[str, Any]) -> str:
        """
        Create audit log records for tracking changes to system entities.
        
        This tool only supports creation of audit records - no updates are allowed
        as audit logs are immutable for compliance purposes.
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        # Access audit_log data
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for audit_log"
            })
        
        audit_log = data.get("audit_log", {})
        
        if not audit_data:
            return json.dumps({
                "success": False,
                "error": "audit_data is required for audit log creation"
            })
        
        # Validate required fields for creation
        required_fields = ["entity_type", "entity_id", "operation_type", "changed_by_id"]
        missing_fields = [field for field in required_fields if field not in audit_data]
        if missing_fields:
            return json.dumps({
                "success": False,
                "error": f"Missing required fields for audit log creation: {', '.join(missing_fields)}"
            })
        
        # Validate only allowed fields are present
        allowed_fields = ["entity_type", "entity_id", "operation_type", "changed_by_id", "field_name", "old_value", "new_value"]
        invalid_fields = [field for field in audit_data.keys() if field not in allowed_fields]
        if invalid_fields:
            return json.dumps({
                "success": False,
                "error": f"Invalid fields for audit log creation: {', '.join(invalid_fields)}"
            })
        
        # Validate enum fields
        valid_operation_types = ["INSERT", "UPDATE", "DELETE"]
        if audit_data["operation_type"] not in valid_operation_types:
            return json.dumps({
                "success": False,
                "error": f"Invalid operation_type '{audit_data['operation_type']}'. Must be one of: {', '.join(valid_operation_types)}"
            })
        
        # Validate entity_type (should be a valid table name)
        valid_entity_types = ["clients", "vendors", "users", "products", "infrastructure_components", 
                             "client_subscriptions", "sla_agreements", "incidents", "workarounds", 
                             "root_cause_analysis", "communications", "escalations", "change_requests", 
                             "rollback_requests", "metrics", "incident_reports", "knowledge_base_articles", 
                             "post_incident_reviews"]
        if audit_data["entity_type"] not in valid_entity_types:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{audit_data['entity_type']}'. Must be one of: {', '.join(valid_entity_types)}"
            })
        
        # For UPDATE operations, field_name should be provided
        if audit_data["operation_type"] == "UPDATE" and not audit_data.get("field_name"):
            return json.dumps({
                "success": False,
                "error": "field_name is required for UPDATE operations"
            })
        
        # Generate new audit ID
        new_audit_id = generate_id(audit_log)
        
        # Create new audit log record
        new_audit_record = {
            "audit_id": str(new_audit_id),
            "entity_type": audit_data["entity_type"],
            "entity_id": str(audit_data["entity_id"]),
            "operation_type": audit_data["operation_type"],
            "changed_by_id": str(audit_data["changed_by_id"]),
            "field_name": audit_data.get("field_name"),
            "old_value": str(audit_data.get("old_value")) if audit_data.get("old_value") is not None else None,
            "new_value": str(audit_data.get("new_value")) if audit_data.get("new_value") is not None else None,
            "created_at": "2025-10-01T00:00:00"
        }
        
        audit_log[str(new_audit_id)] = new_audit_record
        
        return json.dumps({
            "success": True,
            "action": "create",
            "audit_id": str(new_audit_id),
            "audit_data": new_audit_record
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "log_audit_records",
                "description": "Create audit log records in the incident management system for tracking all changes to system entities. This tool maintains an immutable audit trail for compliance and security purposes by logging all INSERT, UPDATE, and DELETE operations across all system tables. Records include the entity type, entity ID, operation type, user who made the change, and specific field changes for UPDATE operations. Essential for regulatory compliance, security monitoring, change tracking, and forensic analysis. Audit records cannot be modified or deleted once created to maintain data integrity.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "audit_data": {
                            "type": "object",
                            "description": "Audit log data object. Requires entity_type (table name), entity_id (record ID), operation_type, changed_by_id (user ID), with optional field_name (required for UPDATE), old_value, new_value. SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "entity_type": {
                                    "type": "string",
                                    "description": "Name of the database table that was modified: 'clients', 'vendors', 'users', 'products', 'infrastructure_components', 'client_subscriptions', 'sla_agreements', 'incidents', 'workarounds', 'root_cause_analysis', 'communications', 'escalations', 'change_requests', 'rollback_requests', 'metrics', 'incident_reports', 'knowledge_base_articles', 'post_incident_reviews'",
                                    "enum": ["clients", "vendors", "users", "products", "infrastructure_components", "client_subscriptions", "sla_agreements", "incidents", "workarounds", "root_cause_analysis", "communications", "escalations", "change_requests", "rollback_requests", "metrics", "incident_reports", "knowledge_base_articles", "post_incident_reviews"]
                                },
                                "entity_id": {
                                    "type": "string",
                                    "description": "Unique identifier of the record that was changed"
                                },
                                "operation_type": {
                                    "type": "string",
                                    "description": "Type of database operation performed: 'INSERT', 'UPDATE', 'DELETE'",
                                    "enum": ["INSERT", "UPDATE", "DELETE"]
                                },
                                "changed_by_id": {
                                    "type": "string",
                                    "description": "User ID of the person who made the change"
                                },
                                "field_name": {
                                    "type": "string",
                                    "description": "Name of the specific field that was changed (required for UPDATE operations, optional for others)"
                                },
                                "old_value": {
                                    "type": "string",
                                    "description": "Previous value of the field before the change (optional, for UPDATE operations)"
                                },
                                "new_value": {
                                    "type": "string",
                                    "description": "New value of the field after the change (optional, for INSERT and UPDATE operations)"
                                }
                            },
                            "required": ["entity_type", "entity_id", "operation_type", "changed_by_id"]
                        }
                    },
                    "required": ["audit_data"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageUsers(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        approval: bool,
        # For Create
        first_name: Optional[str] = None,
        last_name: Optional[str] = None,
        email: Optional[str] = None,
        role: Optional[str] = None,
        timezone: Optional[str] = None,
        phone: Optional[str] = None,
        department: Optional[str] = None,
        client_id: Optional[str] = None,
        vendor_id: Optional[str] = None,
        status: Optional[str] = "active",
        # For Update
        user_id: Optional[str] = None
    ) -> str:

        users = data.get("users", {})
        clients = data.get("clients", {})
        vendors = data.get("vendors", {})

        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1

        valid_roles = [
            "incident_manager", "technical_support", "account_manager",
            "executive", "vendor_contact", "system_administrator",
            "client_contact"
        ]
        valid_status = ["active", "inactive", "on_leave"]

        # ----- Check Approval -----
        if not approval:
            return json.dumps({
                "success": False,
                "error": "Approval missing for user management action"
            })

        # ----- CREATE -----
        if not user_id:
            # Required fields
            if not first_name or not last_name or not email or not role or not timezone:
                return json.dumps({
                    "success": False,
                    "error": "Missing or invalid inputs"
                })

            if role not in valid_roles:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid role. Must be one of {valid_roles}"
                })

            if status and status not in valid_status:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status. Must be one of {valid_status}"
                })

            # Check email uniqueness
            for user in users.values():
                if user.get("email") == email:
                    return json.dumps({
                        "success": False,
                        "error": "Email already exists"
                    })

            # Validate client
            if client_id:
                client = clients.get(client_id)
                if not client or client.get("status") != "active":
                    return json.dumps({
                        "success": False,
                        "error": "Client not found or inactive"
                    })

            # Validate vendor
            if vendor_id:
                vendor = vendors.get(vendor_id)
                if not vendor or vendor.get("status") != "active":
                    return json.dumps({
                        "success": False,
                        "error": "Vendor not found or inactive"
                    })

            # Create new user
            new_id = str(generate_id(users))
            timestamp = "2025-10-01T00:00:00"

            new_user = {
                "user_id": new_id,
                "first_name": first_name,
                "last_name": last_name,
                "email": email,
                "role": role,
                "timezone": timezone,
                "phone": phone,
                "department": department,
                "client_id": client_id,
                "vendor_id": vendor_id,
                "status": status,
                "created_at": timestamp
            }
            users[new_id] = new_user

            # Simulate audit record logging
            if not data.get("audit_log"):
                data["audit_log"] = []
            data["audit_log"].append({
                "action": "create_user",
                "user_id": new_id,
                "timestamp": timestamp
            })

            return json.dumps(new_user)

        # ----- UPDATE -----
        else:
            if user_id not in users:
                return json.dumps({
                    "success": False,
                    "error": "User not found"
                })

            user = users[user_id]

            if email:
                # Check uniqueness
                for uid, existing in users.items():
                    if uid != user_id and existing.get("email") == email:
                        return json.dumps({
                            "success": False,
                            "error": "New email already exists"
                        })
                user["email"] = email

            if role and role not in valid_roles:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid role. Must be one of {valid_roles}"
                })

            if status and status not in valid_status:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status. Must be one of {valid_status}"
                })

            # Validate client
            if client_id:
                client = clients.get(client_id)
                if not client or client.get("status") != "active":
                    return json.dumps({
                        "success": False,
                        "error": "Client not found or inactive"
                    })
                user["client_id"] = client_id

            # Validate vendor
            if vendor_id:
                vendor = vendors.get(vendor_id)
                if not vendor or vendor.get("status") != "active":
                    return json.dumps({
                        "success": False,
                        "error": "Vendor not found or inactive"
                    })
                user["vendor_id"] = vendor_id

            # Update allowed fields
            for field, val in [
                ("first_name", first_name), ("last_name", last_name),
                ("phone", phone), ("role", role),
                ("department", department), ("timezone", timezone),
                ("status", status)
            ]:
                if val is not None:
                    user[field] = val

            # Simulate audit logging
            timestamp = "2025-10-01T00:00:00"
            if not data.get("audit_log"):
                data["audit_log"] = []
            data["audit_log"].append({
                "action": "update_user",
                "user_id": user_id,
                "timestamp": timestamp
            })

            return json.dumps(user)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_users",
                "description": (
                    "Create or update user accounts in the incident management system. "
                    "Validates uniqueness of email, ensures clients/vendors are active, "
                    "and requires approval from system_administrator or incident_manager. "
                    "Handles user creation and updates with full audit trail logging. "
                    "Errors trigger human handoff if approval is missing, inputs invalid, "
                    "email duplicates, client/vendor issues, role/status invalid, or "
                    "audit logging fails."
                ),
                "parameters": {
                    "type": "object",
                    "properties": {
                        "user_id": {
                            "type": "string",
                            "description": "Existing user ID for updates. "
                                           "If omitted, a new user will be created."
                        },
                        "first_name": {"type": "string"},
                        "last_name": {"type": "string"},
                        "email": {"type": "string"},
                        "phone": {"type": "string"},
                        "role": {
                            "type": "string",
                            "description": "Must be one of: incident_manager, technical_support, "
                                           "account_manager, executive, vendor_contact, "
                                           "system_administrator, client_contact"
                        },
                        "department": {"type": "string"},
                        "client_id": {"type": "string"},
                        "vendor_id": {"type": "string"},
                        "timezone": {"type": "string"},
                        "status": {
                            "type": "string",
                            "description": "User status. Must be one of: active, inactive, on_leave"
                        }
                    }
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverComponents(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover infrastructure component entities.
        
        Supported entities:
        - infrastructure_components: Infrastructure component records by component_id, product_id, component_name, component_type, environment, location, port_number, status
        """
        if entity_type not in ["infrastructure_components"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'infrastructure_components'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get("infrastructure_components", {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "component_id": str(entity_id)})
            else:
                results.append({**entity_data, "component_id": str(entity_id)})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_components",
                "description": "Discover infrastructure component entities. Entity types: 'infrastructure_components' (infrastructure component records; filterable by component_id (string), product_id (string), component_name (string), component_type (enum: 'sftp_server', 'api_endpoint', 'database', 'load_balancer', 'firewall', 'authentication_service', 'payment_gateway', 'file_storage', 'monitoring_system'), environment (enum: 'production', 'staging', 'development', 'test'), location (string), port_number (integer), status (enum: 'online', 'offline', 'maintenance', 'degraded'), created_at (timestamp), updated_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'infrastructure_components'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For infrastructure_components, filters are: component_id (string), product_id (string), component_name (string), component_type (enum: 'sftp_server', 'api_endpoint', 'database', 'load_balancer', 'firewall', 'authentication_service', 'payment_gateway', 'file_storage', 'monitoring_system'), environment (enum: 'production', 'staging', 'development', 'test'), location (string), port_number (integer), status (enum: 'online', 'offline', 'maintenance', 'degraded'), created_at (timestamp), updated_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverMetricsEntities(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover metrics entities.
        
        Supported entities:
        - metrics: Incident metrics records
        """
        if entity_type not in ["metrics"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'metrics'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get("metrics", {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "metric_id": str(entity_id)})
            else:
                results.append({**entity_data, "metric_id": str(entity_id)})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_metrics_entities",
                "description": "Discover metrics entities. Entity types: 'metrics' (incident metrics records; filterable by metric_id (string), incident_id (string), metric_type (enum: 'MTTA', 'MTTD', 'MTTR', 'MTTM', 'FTR'), value_minutes (int), target_minutes (int), recorded_at (timestamp), created_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'metrics'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For metrics, filters are: metric_id (string), incident_id (string), metric_type (enum: 'MTTA', 'MTTD', 'MTTR', 'MTTM', 'FTR'), value_minutes (int), target_minutes (int), recorded_at (timestamp), created_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageWorkArounds(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, workaround_data: Dict[str, Any] = None, workaround_id: str = None) -> str:
        """
        Create or update workaround records.
        
        Actions:
        - create: Create new workaround record (requires workaround_data with incident_id, implemented_by_id, effectiveness, status, implemented_at)
        - update: Update existing workaround record (requires workaround_id and workaround_data with changes)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        # Access workarounds data
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for workarounds"
            })
        
        workarounds = data.get("workarounds", {})
        
        if action == "create":
            if not workaround_data:
                return json.dumps({
                    "success": False,
                    "error": "workaround_data is required for create action"
                })
            
            # Validate required fields for creation
            required_fields = ["incident_id", "implemented_by_id", "effectiveness", "status", "implemented_at"]
            missing_fields = [field for field in required_fields if field not in workaround_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields for workaround creation: {', '.join(missing_fields)}"
                })
            
            # Validate only allowed fields are present
            allowed_fields = ["incident_id", "implemented_by_id", "effectiveness", "status", "implemented_at"]
            invalid_fields = [field for field in workaround_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for workaround creation: {', '.join(invalid_fields)}"
                })
            
            # Validate enum fields
            valid_effectiveness = ["complete", "partial", "minimal"]
            if workaround_data["effectiveness"] not in valid_effectiveness:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid effectiveness '{workaround_data['effectiveness']}'. Must be one of: {', '.join(valid_effectiveness)}"
                })
            
            valid_statuses = ["active", "inactive", "replaced"]
            if workaround_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{workaround_data['status']}'. Must be one of: {', '.join(valid_statuses)}"
                })
            
            # Generate new workaround ID
            new_workaround_id = generate_id(workarounds)
            
            # Create new workaround record
            new_workaround = {
                "workaround_id": str(new_workaround_id),
                "incident_id": str(workaround_data["incident_id"]),
                "implemented_by_id": str(workaround_data["implemented_by_id"]),
                "effectiveness": workaround_data["effectiveness"],
                "status": workaround_data["status"],
                "implemented_at": workaround_data["implemented_at"],
                "created_at": "2025-10-01T00:00:00"
            }
            
            workarounds[str(new_workaround_id)] = new_workaround
            
            return json.dumps({
                "success": True,
                "action": "create",
                "workaround_id": str(new_workaround_id),
                "workaround_data": new_workaround
            })
        
        elif action == "update":
            if not workaround_id:
                return json.dumps({
                    "success": False,
                    "error": "workaround_id is required for update action"
                })
            
            if workaround_id not in workarounds:
                return json.dumps({
                    "success": False,
                    "error": f"Workaround record {workaround_id} not found"
                })
            
            if not workaround_data:
                return json.dumps({
                    "success": False,
                    "error": "workaround_data is required for update action"
                })
            
            # Validate only allowed fields are present for updates
            allowed_update_fields = ["effectiveness", "status"]
            invalid_fields = [field for field in workaround_data.keys() if field not in allowed_update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for workaround update: {', '.join(invalid_fields)}. Cannot update incident_id, implemented_by_id, or implemented_at."
                })
            
            # Validate enum fields if provided
            if "effectiveness" in workaround_data:
                valid_effectiveness = ["complete", "partial", "minimal"]
                if workaround_data["effectiveness"] not in valid_effectiveness:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid effectiveness '{workaround_data['effectiveness']}'. Must be one of: {', '.join(valid_effectiveness)}"
                    })
            
            if "status" in workaround_data:
                valid_statuses = ["active", "inactive", "replaced"]
                if workaround_data["status"] not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status '{workaround_data['status']}'. Must be one of: {', '.join(valid_statuses)}"
                    })
            
            # Get current workaround data
            current_workaround = workarounds[workaround_id].copy()
            
            # Update workaround record
            updated_workaround = current_workaround.copy()
            for key, value in workaround_data.items():
                updated_workaround[key] = value
            
            workarounds[workaround_id] = updated_workaround
            
            return json.dumps({
                "success": True,
                "action": "update",
                "workaround_id": str(workaround_id),
                "workaround_data": updated_workaround
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_work_arounds",
                "description": "Create or update workaround records in the incident management system. This tool manages temporary solutions implemented to mitigate incident impact while permanent fixes are being developed. For creation, establishes new workaround records with comprehensive validation to track implementation details and effectiveness. For updates, modifies existing workaround records while maintaining data integrity. Validates effectiveness levels and status values according to incident management best practices. Essential for incident mitigation tracking, solution effectiveness measurement, and operational continuity during incident resolution.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new workaround record, 'update' to modify existing workaround record",
                            "enum": ["create", "update"]
                        },
                        "workaround_data": {
                            "type": "object",
                            "description": "Workaround data object. For create: requires incident_id, implemented_by_id, effectiveness, status, implemented_at. For update: includes workaround fields to change (incident_id, implemented_by_id, implemented_at cannot be updated). SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "incident_id": {
                                    "type": "string",
                                    "description": "Reference to the incident record (required for create only, cannot be updated)"
                                },
                                "implemented_by_id": {
                                    "type": "string",
                                    "description": "User ID who implemented the workaround (required for create only, cannot be updated)"
                                },
                                "effectiveness": {
                                    "type": "string",
                                    "description": "Effectiveness level of the workaround: 'complete', 'partial', 'minimal'",
                                    "enum": ["complete", "partial", "minimal"]
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Current status of the workaround: 'active', 'inactive', 'replaced'",
                                    "enum": ["active", "inactive", "replaced"]
                                },
                                "implemented_at": {
                                    "type": "string",
                                    "description": "Timestamp when workaround was implemented (required for create only, cannot be updated)"
                                }
                            }
                        },
                        "workaround_id": {
                            "type": "string",
                            "description": "Unique identifier of the workaround record (required for update action only)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageEscalations(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, escalation_data: Dict[str, Any] = None, escalation_id: str = None) -> str:
        """
        Create or update escalation records.

        Actions:
        - create: Create new escalation (requires escalation_data with incident_id, escalated_by_id, escalated_to_id, escalation_reason, escalation_level)
        - update: Update existing escalation (requires escalation_id and escalation_data with fields to change)
        """
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1

        def generate_code(prefix: str, table: Dict[str, Any]) -> str:
            max_num = 0
            for record in table.values():
                code = record.get("escalation_code", "")
                if code.startswith(prefix):
                    try:
                        num = int(code.split("-")[-1])
                        max_num = max(max_num, num)
                    except:
                        pass
            return f"{prefix}-{str(max_num + 1).zfill(5)}"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for escalations"
            })

        escalations = data.get("escalations", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        # Allowed/enums
        valid_levels = ["technical", "management", "executive", "vendor"]
        valid_reasons = ["sla_breach", "severity_increase", "resource_unavailable", "executive_request", "client_demand"]
        valid_statuses = ["open", "acknowledged", "resolved"]

        if action == "create":
            if not escalation_data:
                return json.dumps({
                    "success": False,
                    "error": "escalation_data is required for create action"
                })

            # Required fields
            required_fields = ["incident_id", "escalated_by_id", "escalated_to_id", "escalation_reason", "escalated_at", "escalation_level"]
            missing = [f for f in required_fields if f not in escalation_data]
            if missing:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields for escalation creation: {', '.join(missing)}"
                })
            
            # Only allow known fields to be supplied
            allowed_fields = [
                "incident_id", "escalated_by_id", "escalated_to_id", "escalation_reason",
                "escalated_at", "escalation_level", "acknowledged_at", "resolved_at, status"
            ]
            invalid_fields = [k for k in escalation_data.keys() if k not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for escalation creation: {', '.join(invalid_fields)}"
                })

            incident_id = str(escalation_data["incident_id"])
            escalated_by_id = str(escalation_data["escalated_by_id"])
            escalated_to_id = str(escalation_data["escalated_to_id"])
            escalation_reason = escalation_data["escalation_reason"]
            escalation_level = escalation_data["escalation_level"]
            acknowledged_at = escalation_data.get("acknowledged_at")
            resolved_at = escalation_data.get("resolved_at")
            status = escalation_data.get("status")

            # Validate incident
            if incident_id not in incidents:
                return json.dumps({"success": False, "error": f"Incident {incident_id} not found"})
            if incidents[incident_id].get("status") not in ["open", "in_progress"]:
                return json.dumps({"success": False, "error": "Incident must be open or in_progress"})

            # Validate users
            if escalated_by_id not in users or users[escalated_by_id].get("status") != "active":
                return json.dumps({"success": False, "error": f"Escalating user {escalated_by_id} not found or inactive"})
            if escalated_to_id not in users:
                return json.dumps({"success": False, "error": f"Target user {escalated_to_id} not found"})

            # Validate level/role and enums
            if escalation_level not in valid_levels:
                return json.dumps({"success": False, "error": f"Invalid escalation_level. Must be one of: {', '.join(valid_levels)}"})
            if escalation_reason not in valid_reasons:
                return json.dumps({"success": False, "error": f"Invalid escalation_reason. Must be one of: {', '.join(valid_reasons)}"})
            if status and status not in valid_statuses:
                return json.dumps({"success": False, "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"})

            # Generate and create
            new_id = generate_id(escalations)
            escalation_code = generate_code("ESC-2025", escalations)
            new_escalation = {
                "escalation_id": str(new_id),
                "escalation_code": escalation_code,
                "incident_id": incident_id,
                "escalated_by_id": escalated_by_id,
                "escalated_to_id": escalated_to_id,
                "escalation_reason": escalation_reason,
                "escalation_level": escalation_level,
                "acknowledged_at": acknowledged_at,
                "resolved_at": resolved_at,
                "status": status if status else "open",
                "escalated_at": "2025-10-02T12:00:00",
                "created_at": "2025-10-02T12:00:00",
                "updated_at": "2025-10-02T12:00:00"
            }
            escalations[str(new_id)] = new_escalation

            return json.dumps({
                "success": True,
                "action": "create",
                "escalation_id": str(new_id),
                "message": f"Escalation {new_id} created successfully",
                "escalation_data": new_escalation
            })

        elif action == "update":
            if not escalation_id:
                return json.dumps({"success": False, "error": "escalation_id is required for update action"})
            if escalation_id not in escalations:
                return json.dumps({"success": False, "error": f"Escalation {escalation_id} not found"})
            if not escalation_data:
                return json.dumps({"success": False, "error": "escalation_data is required for update action"})

            current = escalations[escalation_id].copy()

            for field in ["escalation_code", "acknowledged_at", "resolved_at", "status"]:
                if field in escalation_data:
                    value = escalation_data[field]
                    if field == "status" and value not in valid_statuses:
                        return json.dumps({"success": False, "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"})
                    current[field] = value

            current["updated_at"] = "2025-10-02T12:00:00"
            escalations[escalation_id] = current

            return json.dumps({
                "success": True,
                "action": "update",
                "escalation_id": escalation_id,
                "message": f"Escalation {escalation_id} updated successfully",
                "escalation_data": current
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_escalations",
                "description": "Create or update escalation records in the incident management system. Supports multiple escalation levels (technical, management, executive, vendor) with role validation. Tracks escalation reasons and statuses.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {"type": "string", "enum": ["create", "update"], "description": "Action to perform"},
                        "escalation_data": {"type": "object", "description": "Escalation data object for create/update"},
                        "escalation_id": {"type": "string", "description": "Escalation ID for update action only"}
                    },
                    "required": ["action"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageIncidents(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, incident_data: Dict[str, Any] = None, incident_id: str = None) -> str:
        """
        Create or update incident records.
        
        Actions:
        - create: Create new incident record (requires incident_data with title, reporter_id, client_id, category, impact, detection_source, urgency, detected_at)
        - update: Update existing incident record (requires incident_id and incident_data with changes)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        # Access incidents data
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for incidents"
            })
        
        incidents = data.get("incidents", {})
        
        if action == "create":
            if not incident_data:
                return json.dumps({
                    "success": False,
                    "error": "incident_data is required for create action"
                })
            
            # Validate required fields for creation
            required_fields = ["title", "reporter_id", "client_id", "category", "impact", "detection_source", "urgency", "detected_at"]
            missing_fields = [field for field in required_fields if field not in incident_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields for incident creation: {', '.join(missing_fields)}"
                })
            
            # Validate only allowed fields are present (incident_code should NOT be in create)
            allowed_fields = ["title", "reporter_id", "assigned_manager_id", "client_id", "component_id", 
                            "severity", "status", "impact", "urgency", "category", "detection_source", "detected_at", 
                            "resolved_at", "closed_at", "rto_breach", "sla_breach", "is_recurring", "downtime_minutes"]
            invalid_fields = [field for field in incident_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for incident creation: {', '.join(invalid_fields)}"
                })
            
            # Validate enum fields (only if provided for optional fields)
            valid_severities = ["P1", "P2", "P3", "P4"]
            if "severity" in incident_data and incident_data["severity"] not in valid_severities:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid severity '{incident_data['severity']}'. Must be one of: {', '.join(valid_severities)}"
                })
            
            valid_statuses = ["open", "in_progress", "resolved", "closed"]
            if "status" in incident_data and incident_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{incident_data['status']}'. Must be one of: {', '.join(valid_statuses)}"
                })
            
            valid_impacts = ["critical", "high", "medium", "low"]
            if incident_data["impact"] not in valid_impacts:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid impact '{incident_data['impact']}'. Must be one of: {', '.join(valid_impacts)}"
                })
            
            valid_urgencies = ["critical", "high", "medium", "low"]
            if incident_data["urgency"] not in valid_urgencies:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid urgency '{incident_data['urgency']}'. Must be one of: {', '.join(valid_urgencies)}"
                })
            
            valid_categories = ["system_outage", "performance_degradation", "security_incident", "data_corruption", 
                              "integration_failure", "network_issue", "hardware_failure", "software_bug", 
                              "configuration_error", "capacity_issue", "backup_failure", "authentication_failure", 
                              "api_error", "database_issue", "service_unavailable"]
            if incident_data["category"] not in valid_categories:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid category '{incident_data['category']}'. Must be one of: {', '.join(valid_categories)}"
                })
            
            valid_detection_sources = ["client_reported", "internally_detected", "monitoring_alert", "vendor_reported", 
                                     "scheduled_maintenance", "emergency_maintenance"]
            if incident_data["detection_source"] not in valid_detection_sources:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid detection_source '{incident_data['detection_source']}'. Must be one of: {', '.join(valid_detection_sources)}"
                })
            
            # Validate boolean fields if provided
            if "rto_breach" in incident_data and not isinstance(incident_data["rto_breach"], bool):
                return json.dumps({
                    "success": False,
                    "error": "rto_breach must be a boolean (True/False)"
                })
            
            if "sla_breach" in incident_data and not isinstance(incident_data["sla_breach"], bool):
                return json.dumps({
                    "success": False,
                    "error": "sla_breach must be a boolean (True/False)"
                })
            
            if "is_recurring" in incident_data and not isinstance(incident_data["is_recurring"], bool):
                return json.dumps({
                    "success": False,
                    "error": "is_recurring must be a boolean (True/False)"
                })
            
            # Validate downtime_minutes if provided
            if "downtime_minutes" in incident_data:
                downtime = incident_data["downtime_minutes"]
                if downtime is not None and (not isinstance(downtime, int) or downtime < 0):
                    return json.dumps({
                        "success": False,
                        "error": "downtime_minutes must be a non-negative integer"
                    })
            
            # Generate new incident ID
            new_incident_id = generate_id(incidents)
            
            # Auto-generate incident_code
            max_seq = 0
            for existing_incident in incidents.values():
                code = existing_incident.get("incident_code")
                if code and code.startswith("INC-2025-"):
                    try:
                        seq_num = int(code.split("INC-2025-")[1])
                        if seq_num > max_seq:
                            max_seq = seq_num
                    except Exception:
                        continue
            seq = max_seq + 1
            generated_code = f"INC-2025-{seq:05d}"

            new_incident = {
                "incident_id": str(new_incident_id),
                "incident_code": generated_code,
                "title": incident_data["title"],
                "reporter_id": str(incident_data["reporter_id"]),
                "assigned_manager_id": str(incident_data.get("assigned_manager_id")) if incident_data.get("assigned_manager_id") else None,
                "client_id": str(incident_data["client_id"]),
                "component_id": str(incident_data.get("component_id")) if incident_data.get("component_id") else None,
                "severity": incident_data.get("severity"),
                "status": incident_data.get("status", "open"),
                "impact": incident_data["impact"],
                "urgency": incident_data["urgency"],
                "category": incident_data["category"],
                "detection_source": incident_data["detection_source"],
                "detected_at": incident_data["detected_at"],
                "resolved_at": incident_data.get("resolved_at"),
                "closed_at": incident_data.get("closed_at"),
                "rto_breach": incident_data.get("rto_breach", False),
                "sla_breach": incident_data.get("sla_breach", False),
                "is_recurring": incident_data.get("is_recurring", False),
                "downtime_minutes": incident_data.get("downtime_minutes"),
                "created_at": "2025-10-01T00:00:00",
                "updated_at": "2025-10-01T00:00:00"
            }
            
            incidents[str(new_incident_id)] = new_incident
            
            return json.dumps({
                "success": True,
                "action": "create",
                "incident_id": str(new_incident_id),
                "incident_data": new_incident
            })
        
        elif action == "update":
            if not incident_id:
                return json.dumps({
                    "success": False,
                    "error": "incident_id is required for update action"
                })
            
            if incident_id not in incidents:
                return json.dumps({
                    "success": False,
                    "error": f"Incident record {incident_id} not found"
                })
            
            if not incident_data:
                return json.dumps({
                    "success": False,
                    "error": "incident_data is required for update action"
                })
            
            # Validate at least one field is provided for update
            if not incident_data:
                return json.dumps({
                    "success": False,
                    "error": "At least one field must be provided for update"
                })
            
            # Validate only allowed fields are present for updates
            allowed_update_fields = ["title", "incident_code", "assigned_manager_id", "component_id", "severity", "status", "impact", 
                                   "urgency", "category", "detection_source", "resolved_at", "closed_at", 
                                   "rto_breach", "sla_breach", "is_recurring", "downtime_minutes"]
            invalid_fields = [field for field in incident_data.keys() if field not in allowed_update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for incident update: {', '.join(invalid_fields)}. Cannot update reporter_id, client_id, or detected_at."
                })
            
            # Validate incident_code uniqueness if provided
            if "incident_code" in incident_data and incident_data["incident_code"]:
                new_code = incident_data["incident_code"]
                for existing_id, existing in incidents.items():
                    if existing_id != incident_id and existing.get("incident_code") == new_code:
                        return json.dumps({
                            "success": False,
                            "error": f"Incident with code '{new_code}' already exists"
                        })
            
            # Validate enum fields if provided
            if "severity" in incident_data:
                valid_severities = ["P1", "P2", "P3", "P4"]
                if incident_data["severity"] not in valid_severities:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid severity '{incident_data['severity']}'. Must be one of: {', '.join(valid_severities)}"
                    })
            
            if "status" in incident_data:
                valid_statuses = ["open", "in_progress", "resolved", "closed"]
                if incident_data["status"] not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status '{incident_data['status']}'. Must be one of: {', '.join(valid_statuses)}"
                    })
            
            if "impact" in incident_data:
                valid_impacts = ["critical", "high", "medium", "low"]
                if incident_data["impact"] not in valid_impacts:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid impact '{incident_data['impact']}'. Must be one of: {', '.join(valid_impacts)}"
                    })
            
            if "urgency" in incident_data:
                valid_urgencies = ["critical", "high", "medium", "low"]
                if incident_data["urgency"] not in valid_urgencies:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid urgency '{incident_data['urgency']}'. Must be one of: {', '.join(valid_urgencies)}"
                    })
            
            if "category" in incident_data:
                valid_categories = ["system_outage", "performance_degradation", "security_incident", "data_corruption", 
                                  "integration_failure", "network_issue", "hardware_failure", "software_bug", 
                                  "configuration_error", "capacity_issue", "backup_failure", "authentication_failure", 
                                  "api_error", "database_issue", "service_unavailable"]
                if incident_data["category"] not in valid_categories:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid category '{incident_data['category']}'. Must be one of: {', '.join(valid_categories)}"
                    })
            
            if "detection_source" in incident_data:
                valid_detection_sources = ["client_reported", "internally_detected", "monitoring_alert", "vendor_reported", 
                                         "scheduled_maintenance", "emergency_maintenance"]
                if incident_data["detection_source"] not in valid_detection_sources:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid detection_source '{incident_data['detection_source']}'. Must be one of: {', '.join(valid_detection_sources)}"
                    })
            
            # Validate boolean fields if provided
            if "rto_breach" in incident_data and not isinstance(incident_data["rto_breach"], bool):
                return json.dumps({
                    "success": False,
                    "error": "rto_breach must be a boolean (True/False)"
                })
            
            if "sla_breach" in incident_data and not isinstance(incident_data["sla_breach"], bool):
                return json.dumps({
                    "success": False,
                    "error": "sla_breach must be a boolean (True/False)"
                })
            
            if "is_recurring" in incident_data and not isinstance(incident_data["is_recurring"], bool):
                return json.dumps({
                    "success": False,
                    "error": "is_recurring must be a boolean (True/False)"
                })
            
            # Validate downtime_minutes if provided
            if "downtime_minutes" in incident_data:
                downtime = incident_data["downtime_minutes"]
                if downtime is not None and (not isinstance(downtime, int) or downtime < 0):
                    return json.dumps({
                        "success": False,
                        "error": "downtime_minutes must be a non-negative integer"
                    })
            
            # Get current incident data
            current_incident = incidents[incident_id].copy()
            
            # Validate status transitions
            current_status = current_incident.get("status")
            new_status = incident_data.get("status")
            
            if new_status and current_status == "closed" and new_status != "closed":
                return json.dumps({
                    "success": False,
                    "error": "Cannot reopen a closed incident"
                })
            
            # Auto-set resolved_at when status changes to resolved
            if new_status == "resolved" and current_status != "resolved" and "resolved_at" not in incident_data:
                incident_data["resolved_at"] = "2025-10-01T00:00:00"
            
            # Auto-set closed_at when status changes to closed
            if new_status == "closed" and current_status != "closed" and "closed_at" not in incident_data:
                incident_data["closed_at"] = "2025-10-01T00:00:00"
            
            # Update incident record
            updated_incident = current_incident.copy()
            for key, value in incident_data.items():
                if key in ["assigned_manager_id", "component_id"] and value is not None:
                    updated_incident[key] = str(value)
                else:
                    updated_incident[key] = value
            
            updated_incident["updated_at"] = "2025-10-01T00:00:00"
            incidents[incident_id] = updated_incident
            
            return json.dumps({
                "success": True,
                "action": "update",
                "incident_id": str(incident_id),
                "incident_data": updated_incident
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_incidents",
                "description": "Create or update incident records in the incident management system. This tool manages the complete incident lifecycle from initial reporting through resolution and closure. For creation, establishes new incident records with auto-generated incident codes and comprehensive validation to ensure proper categorization, severity assessment, and tracking information. For updates, modifies existing incident records while maintaining data integrity and enforcing proper status transitions. Use update action to resolve (set status='resolved') or close (set status='closed') incidents. Essential for incident tracking, SLA compliance monitoring, and operational reporting.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new incident record with auto-generated incident_code, 'update' to modify existing incident record (including resolving or closing)",
                            "enum": ["create", "update"]
                        },
                        "incident_data": {
                            "type": "object",
                            "description": "Incident data object. For create: requires title, reporter_id, client_id, category, impact, detection_source, urgency, detected_at, with optional assigned_manager_id, component_id, severity, status, is_recurring, downtime_minutes, sla_breach, rto_breach, closed_at, resolved_at. incident_code is auto-generated. For update: requires at least one field from title, incident_code, assigned_manager_id, component_id, severity, status, impact, urgency, category, detection_source, resolved_at, closed_at, rto_breach, sla_breach, is_recurring, downtime_minutes. Cannot update reporter_id, client_id, or detected_at. SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "title": {
                                    "type": "string",
                                    "description": "Brief description of the incident (required for create)"
                                },
                                "reporter_id": {
                                    "type": "string",
                                    "description": "User ID who reported the incident (required for create only, cannot be updated)"
                                },
                                "assigned_manager_id": {
                                    "type": "string",
                                    "description": "User ID of assigned incident manager (optional)"
                                },
                                "client_id": {
                                    "type": "string",
                                    "description": "Client affected by the incident (required for create only, cannot be updated)"
                                },
                                "component_id": {
                                    "type": "string",
                                    "description": "Infrastructure component involved in the incident (optional)"
                                },
                                "severity": {
                                    "type": "string",
                                    "description": "Incident severity level: 'P1', 'P2', 'P3', 'P4' (optional)",
                                    "enum": ["P1", "P2", "P3", "P4"]
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Current incident status: 'open', 'in_progress', 'resolved', 'closed' (optional, defaults to 'open' on create. Closed incidents cannot be reopened)",
                                    "enum": ["open", "in_progress", "resolved", "closed"]
                                },
                                "impact": {
                                    "type": "string",
                                    "description": "Business impact level: 'critical', 'high', 'medium', 'low' (required for create)",
                                    "enum": ["critical", "high", "medium", "low"]
                                },
                                "urgency": {
                                    "type": "string",
                                    "description": "Business urgency level: 'critical', 'high', 'medium', 'low' (required for create)",
                                    "enum": ["critical", "high", "medium", "low"]
                                },
                                "category": {
                                    "type": "string",
                                    "description": "Technical incident category: 'system_outage', 'performance_degradation', 'security_incident', 'data_corruption', 'integration_failure', 'network_issue', 'hardware_failure', 'software_bug', 'configuration_error', 'capacity_issue', 'backup_failure', 'authentication_failure', 'api_error', 'database_issue', 'service_unavailable' (required for create)",
                                    "enum": ["system_outage", "performance_degradation", "security_incident", "data_corruption", "integration_failure", "network_issue", "hardware_failure", "software_bug", "configuration_error", "capacity_issue", "backup_failure", "authentication_failure", "api_error", "database_issue", "service_unavailable"]
                                },
                                "detection_source": {
                                    "type": "string",
                                    "description": "How the incident was detected: 'client_reported', 'internally_detected', 'monitoring_alert', 'vendor_reported', 'scheduled_maintenance', 'emergency_maintenance' (required for create)",
                                    "enum": ["client_reported", "internally_detected", "monitoring_alert", "vendor_reported", "scheduled_maintenance", "emergency_maintenance"]
                                },
                                "detected_at": {
                                    "type": "string",
                                    "description": "Timestamp when incident was detected (required for create only, cannot be updated)"
                                },
                                "resolved_at": {
                                    "type": "string",
                                    "description": "Timestamp when incident was resolved (optional, auto-set when status changes to 'resolved')"
                                },
                                "closed_at": {
                                    "type": "string",
                                    "description": "Timestamp when incident was closed (optional, auto-set when status changes to 'closed')"
                                },
                                "incident_code": {
                                    "type": "string",
                                    "description": "Unique incident identifier code (auto-generated on create, can be updated)"
                                },
                                "rto_breach": {
                                    "type": "boolean",
                                    "description": "Whether Recovery Time Objective was breached (True/False, optional, defaults to False)"
                                },
                                "sla_breach": {
                                    "type": "boolean",
                                    "description": "Whether Service Level Agreement was breached (True/False, optional, defaults to False)"
                                },
                                "is_recurring": {
                                    "type": "boolean",
                                    "description": "Whether this is a recurring incident (True/False, optional, defaults to False)"
                                },
                                "downtime_minutes": {
                                    "type": "integer",
                                    "description": "Total downtime in minutes (non-negative integer, optional)"
                                }
                            }
                        },
                        "incident_id": {
                            "type": "string",
                            "description": "Unique identifier of the incident record (required for update action only)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverSubscriptionAgreements(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover subscription and SLA agreement entities.
        
        Supported entities:
        - client_subscriptions: Client subscription records by subscription_id, client_id, product_id, subscription_type, start_date, end_date, sla_tier, rto_hours, status
        - sla_agreements: SLA agreement records by sla_id, subscription_id, severity_level, response_time_minutes, resolution_time_hours, availability_percentage
        """
        if entity_type not in ["client_subscriptions", "sla_agreements"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'client_subscriptions' or 'sla_agreements'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        # Determine the ID field based on entity type
        id_field = "subscription_id" if entity_type == "client_subscriptions" else "sla_id"
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, id_field: str(entity_id)})
            else:
                results.append({**entity_data, id_field: str(entity_id)})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_subscription_agreements",
                "description": "Discover subscription and SLA agreement entities. Entity types: 'client_subscriptions' (client subscription records; filterable by subscription_id (string), client_id (string), product_id (string), subscription_type (enum: 'full_service', 'limited_service', 'trial', 'custom'), start_date (date YYYY-MM-DD), end_date (date YYYY-MM-DD), sla_tier (enum: 'premium', 'standard', 'basic'), rto_hours (integer), status (enum: 'active', 'expired', 'cancelled', 'suspended'), created_at (timestamp), updated_at (timestamp)); 'sla_agreements' (SLA agreement records; filterable by sla_id (string), subscription_id (string), severity_level (enum: 'P1', 'P2', 'P3', 'P4'), response_time_minutes (integer), resolution_time_hours (integer), availability_percentage (decimal), created_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'client_subscriptions' or 'sla_agreements'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For client_subscriptions, filters are: subscription_id (string), client_id (string), product_id (string), subscription_type (enum: 'full_service', 'limited_service', 'trial', 'custom'), start_date (date YYYY-MM-DD), end_date (date YYYY-MM-DD), sla_tier (enum: 'premium', 'standard', 'basic'), rto_hours (integer), status (enum: 'active', 'expired', 'cancelled', 'suspended'), created_at (timestamp), updated_at (timestamp). For sla_agreements, filters are: sla_id (string), subscription_id (string), severity_level (enum: 'P1', 'P2', 'P3', 'P4'), response_time_minutes (integer), resolution_time_hours (integer), availability_percentage (decimal), created_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageProducts(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        approval: bool,
        # For Create
        product_name: Optional[str] = None,
        product_type: Optional[str] = None,
        version: Optional[str] = None,
        vendor_support_id: Optional[str] = None,
        status: Optional[str] = "active",
        # For Update
        product_id: Optional[str] = None
    ) -> str:

        products = data.get("products", {})
        vendors = data.get("vendors", {})

        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1

        valid_types = [
            "payment_processing", "banking_system", "api_gateway",
            "data_integration", "reporting_platform", "security_service",
            "backup_service", "monitoring_tool"
        ]
        valid_status = ["active", "deprecated", "maintenance"]

        # ----- Check Approval -----
        if not approval:
            return json.dumps({
                "success": False,
                "error": "Approval missing for product management action"
            })

        # ----- CREATE -----
        if not product_id:
            # Required fields
            if not product_name or not product_type:
                return json.dumps({
                    "success": False,
                    "error": "Missing or invalid inputs"
                })

            if product_type not in valid_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid product_type. Must be one of {valid_types}"
                })

            if status and status not in valid_status:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status. Must be one of {valid_status}"
                })

            # Check product_name uniqueness
            for product in products.values():
                if product.get("product_name") == product_name:
                    return json.dumps({
                        "success": False,
                        "error": "Product name already exists"
                    })

            # Validate vendor
            if vendor_support_id:
                vendor = vendors.get(vendor_support_id)
                if not vendor or vendor.get("status") != "active":
                    return json.dumps({
                        "success": False,
                        "error": "Vendor not found or inactive"
                    })

            # Create new product
            new_id = str(generate_id(products))
            timestamp = "2025-10-01T00:00:00"

            new_product = {
                "product_id": new_id,
                "product_name": product_name,
                "product_type": product_type,
                "version": version,
                "vendor_support_id": vendor_support_id,
                "status": status,
                "created_at": timestamp
            }
            products[new_id] = new_product

            # Simulate audit record logging
            if not data.get("audit_log"):
                data["audit_log"] = []
            data["audit_log"].append({
                "action": "create_product",
                "product_id": new_id,
                "timestamp": timestamp
            })

            return json.dumps(new_product)

        # ----- UPDATE -----
        else:
            if product_id not in products:
                return json.dumps({
                    "success": False,
                    "error": "Product not found"
                })

            product = products[product_id]

            if product_name:
                # Check uniqueness
                for pid, existing in products.items():
                    if pid != product_id and existing.get("product_name") == product_name:
                        return json.dumps({
                            "success": False,
                            "error": "New product_name already exists"
                        })
                product["product_name"] = product_name

            if product_type and product_type not in valid_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid product_type. Must be one of {valid_types}"
                })

            if status and status not in valid_status:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status. Must be one of {valid_status}"
                })

            if vendor_support_id:
                vendor = vendors.get(vendor_support_id)
                if not vendor or vendor.get("status") != "active":
                    return json.dumps({
                        "success": False,
                        "error": "Vendor not found or inactive"
                    })
                product["vendor_support_id"] = vendor_support_id

            # Update allowed fields
            for field, val in [
                ("product_type", product_type), ("version", version),
                ("status", status)
            ]:
                if val is not None:
                    product[field] = val

            # Simulate audit logging
            timestamp = "2025-10-01T00:00:00"
            if not data.get("audit_log"):
                data["audit_log"] = []
            data["audit_log"].append({
                "action": "update_product",
                "product_id": product_id,
                "timestamp": timestamp
            })

            return json.dumps(product)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_products",
                "description": (
                    "Create or update product records in the incident management system. "
                    "Validates product_name uniqueness, ensures vendor is active, and requires "
                    "approval from system_administrator, incident_manager, or executive. "
                    "Handles product creation and updates with audit trail logging. "
                    "Errors trigger human handoff if approval is missing, inputs invalid, "
                    "duplicate product_name, vendor issues, or audit logging fails."
                ),
                "parameters": {
                    "type": "object",
                    "properties": {
                        "product_id": {
                            "type": "string",
                            "description": "Existing product ID for updates. "
                                           "If omitted, a new product will be created."
                        },
                        "product_name": {"type": "string"},
                        "product_type": {
                            "type": "string",
                            "description": "Must be one of: payment_processing, "
                                           "banking_system, api_gateway, data_integration, "
                                           "reporting_platform, security_service, "
                                           "backup_service, monitoring_tool"
                        },
                        "version": {"type": "string"},
                        "vendor_support_id": {"type": "string"},
                        "status": {
                            "type": "string",
                            "description": "Product status. Must be one of: "
                                           "active, deprecated, maintenance"
                        },
                        "approval": {
                            "type": "boolean",
                            "description": "Approval required from system_administrator, "
                                           "incident_manager, or executive."
                        }
                    },
                    "required": ["approval"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from datetime import datetime
from tau_bench.envs.tool import Tool

class ManagePostIncidentReviews(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, pir_data: Dict[str, Any] = None, pir_id: str = None) -> str:
        """
        Create or update post-incident review records.

        pir_data must include:
        - action (required): 'create' or 'update'
        For create:
            - incident_id (required)
            - scheduled_date (required)
            - facilitator_id (required)
            - Optional: timeline_accuracy_rating, communication_effectiveness_rating, technical_response_rating, status
        For update:
            - pir_id (required)
            - Optional: scheduled_date, facilitator_id, timeline_accuracy_rating, communication_effectiveness_rating, technical_response_rating, status
        """

        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False, 
                "error": f"Invalid {action}. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for communications"
            })

        post_incident_reviews = data.get("post_incident_reviews", {})
        users = data.get("users", {})
        incidents = data.get("incidents", {})

        incident_id = pir_data.get("incident_id")
        scheduled_date = pir_data.get("scheduled_date")
        facilitator_id = pir_data.get("facilitator_id")
        timeline_accuracy_rating = pir_data.get("timeline_accuracy_rating")
        communication_effectiveness_rating = pir_data.get("communication_effectiveness_rating")
        technical_response_rating = pir_data.get("technical_response_rating")
        status = pir_data.get("status")

        valid_statuses = ["scheduled", "completed", "cancelled"]

        def validate_date(date_str: str) -> bool:
            try:
                datetime.strptime(date_str, "%Y-%m-%d")
                return True
            except (ValueError, TypeError):
                return False

        def validate_rating(rating: int) -> bool:
            return isinstance(rating, int) and 1 <= rating <= 10

        

        if action == "create":
            # Validate required fields
            if not all([incident_id, scheduled_date, facilitator_id]):
                return json.dumps({
                    "success": False,
                    "error": "incident_id, scheduled_date, and facilitator_id are required for create action"
                })

            if not validate_date(scheduled_date):
                return json.dumps({"success": False, "error": "scheduled_date must be in format YYYY-MM-DD"})

            if incident_id not in incidents:
                return json.dumps({"success": False, "error": f"Incident {incident_id} not found"})
            if incidents[incident_id].get("status") not in ["resolved", "closed"]:
                return json.dumps({
                    "success": False,
                    "error": f"Incident must be resolved or closed, current status: {incidents[incident_id].get('status')}"
                })

            if facilitator_id not in users:
                return json.dumps({"success": False, "error": f"Facilitator {facilitator_id} not found"})
            if users[facilitator_id].get("role") not in ["incident_manager", "executive"]:
                return json.dumps({"success": False, "error": "Facilitator must have role 'incident_manager' or 'executive'"})

            # Validate ratings
            for rating_field, rating_value in [
                ("timeline_accuracy_rating", timeline_accuracy_rating),
                ("communication_effectiveness_rating", communication_effectiveness_rating),
                ("technical_response_rating", technical_response_rating)
            ]:
                if rating_value is not None and not validate_rating(rating_value):
                    return json.dumps({"success": False, "error": f"{rating_field} must be integer 1-10"})

            if status and status not in valid_statuses:
                return json.dumps({"success": False, "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"})

            new_pir_id = generate_id(post_incident_reviews)
            new_pir = {
                "pir_id": str(new_pir_id),
                "incident_id": incident_id,
                "scheduled_date": scheduled_date,
                "facilitator_id": facilitator_id,
                "timeline_accuracy_rating": timeline_accuracy_rating,
                "communication_effectiveness_rating": communication_effectiveness_rating,
                "technical_response_rating": technical_response_rating,
                "status": status if status else "scheduled",
                "created_at": "2025-10-02T12:00:00"
            }

            post_incident_reviews[str(new_pir_id)] = new_pir

            return json.dumps({
                "success": True, 
                "action": "create", 
                "pir_id": str(new_pir_id),
                "message": f"Post incident review {new_pir_id} created successfully", 
                "pir_data": new_pir})

        elif action == "update":
            if not pir_id:
                return json.dumps({"success": False, "error": "pir_id is required for update action"})
            if pir_id not in post_incident_reviews:
                return json.dumps({"success": False, "error": f"Post-incident review {pir_id} not found"})

            # Validate at least one optional field
            if all(field is None for field in [scheduled_date, facilitator_id, timeline_accuracy_rating,
                                               communication_effectiveness_rating, technical_response_rating, status]):
                return json.dumps({"success": False, "error": "At least one optional field must be provided for update"})

            if scheduled_date and not validate_date(scheduled_date):
                return json.dumps({"success": False, "error": "scheduled_date must be in format YYYY-MM-DD"})

            if facilitator_id:
                if facilitator_id not in users:
                    return json.dumps({"success": False, "error": f"Facilitator {facilitator_id} not found"})
                if users[facilitator_id].get("role") not in ["incident_manager", "executive"]:
                    return json.dumps({"success": False, "error": "Facilitator must have role 'incident_manager' or 'executive'"})

            for rating_field, rating_value in [
                ("timeline_accuracy_rating", timeline_accuracy_rating),
                ("communication_effectiveness_rating", communication_effectiveness_rating),
                ("technical_response_rating", technical_response_rating)
            ]:
                if rating_value is not None and not validate_rating(rating_value):
                    return json.dumps({"success": False, "error": f"{rating_field} must be integer 1-10"})

            if status and status not in valid_statuses:
                return json.dumps({"success": False, "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"})

            current_pir = post_incident_reviews[pir_id].copy()
            for field_name, field_value in pir_data.items():
                if field_name in ["scheduled_date", "facilitator_id", "timeline_accuracy_rating",
                                  "communication_effectiveness_rating", "technical_response_rating", "status"]:
                    if field_value is not None:
                        current_pir[field_name] = field_value

            post_incident_reviews[pir_id] = current_pir

            return json.dumps({
                "success": True, 
                "action": "update", 
                "pir_id": pir_id,
                "message": f"Post incident review {pir_id} updated successfully", 
                "pir_data": current_pir})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_post_incident_reviews",
                "description": "Create or update post-incident review (PIR) records. Supports scheduling, facilitator assignment, and rating evaluations. Validates incident status, facilitator role, ratings (1-10), and scheduled dates. Required for continuous improvement, incident analysis, and organizational learning.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {"type": "string", "enum": ["create", "update"], "description": "Action to perform"},
                        "pir_data": {
                            "type": "object",
                            "description": "Post-incident review data",
                            "properties": {
                                "incident_id": {"type": "string", "description": "Incident ID (required for create, must be resolved or closed)"},
                                "scheduled_date": {"type": "string", "description": "Scheduled date YYYY-MM-DD (required for create)"},
                                "facilitator_id": {"type": "string", "description": "Facilitator ID (required for create, must be incident_manager or executive)"},
                                "timeline_accuracy_rating": {"type": "integer", "description": "Rating 1-10 (optional)"},
                                "communication_effectiveness_rating": {"type": "integer", "description": "Rating 1-10 (optional)"},
                                "technical_response_rating": {"type": "integer", "description": "Rating 1-10 (optional)"},
                                "status": {"type": "string", "enum": ["scheduled", "completed", "cancelled"], "description": "Status (optional, default scheduled for create)"}
                            },
                        },
                        "pir_id": {"type": "string", "description": "ID of the Post incident review (required for update)"},
                    },
                    "required": ["action"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageClientSubscriptions(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, subscription_data: Dict[str, Any] = None, subscription_id: str = None) -> str:
        """
        Create or update client subscription records.
        
        Actions:
        - create: Create new subscription record (requires subscription_data with client_id, product_id, subscription_type, start_date, sla_tier, rto_hours, status)
        - update: Update existing subscription record (requires subscription_id and subscription_data with changes)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        # Access client_subscriptions data
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for client_subscriptions"
            })
        
        client_subscriptions = data.get("client_subscriptions", {})
        
        if action == "create":
            if not subscription_data:
                return json.dumps({
                    "success": False,
                    "error": "subscription_data is required for create action"
                })
            
            # Validate required fields for creation
            required_fields = ["client_id", "product_id", "subscription_type", "start_date", "sla_tier", "rto_hours", "status"]
            missing_fields = [field for field in required_fields if field not in subscription_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields for subscription creation: {', '.join(missing_fields)}"
                })
            
            # Validate only allowed fields are present
            allowed_fields = ["client_id", "product_id", "subscription_type", "start_date", "end_date", "sla_tier", "rto_hours", "status"]
            invalid_fields = [field for field in subscription_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for subscription creation: {', '.join(invalid_fields)}"
                })
            
            # Validate enum fields
            valid_subscription_types = ["full_service", "limited_service", "trial", "custom"]
            if subscription_data["subscription_type"] not in valid_subscription_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid subscription_type '{subscription_data['subscription_type']}'. Must be one of: {', '.join(valid_subscription_types)}"
                })
            
            valid_sla_tiers = ["premium", "standard", "basic"]
            if subscription_data["sla_tier"] not in valid_sla_tiers:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid sla_tier '{subscription_data['sla_tier']}'. Must be one of: {', '.join(valid_sla_tiers)}"
                })
            
            valid_statuses = ["active", "expired", "cancelled", "suspended"]
            if subscription_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{subscription_data['status']}'. Must be one of: {', '.join(valid_statuses)}"
                })
            
            # Validate RTO hours
            rto_hours = subscription_data["rto_hours"]
            if not isinstance(rto_hours, int) or rto_hours <= 0:
                return json.dumps({
                    "success": False,
                    "error": "rto_hours must be a positive integer"
                })
            
            # Validate date logic if end_date is provided
            if "end_date" in subscription_data and subscription_data["end_date"]:
                if subscription_data["end_date"] <= subscription_data["start_date"]:
                    return json.dumps({
                        "success": False,
                        "error": "end_date must be after start_date"
                    })
            
            # Check for duplicate active subscription for same client and product
            client_id = subscription_data["client_id"]
            product_id = subscription_data["product_id"]
            for existing_subscription in client_subscriptions.values():
                if (existing_subscription.get("client_id") == client_id and 
                    existing_subscription.get("product_id") == product_id and
                    existing_subscription.get("status") == "active"):
                    return json.dumps({
                        "success": False,
                        "error": f"Active subscription already exists for client {client_id} and product {product_id}"
                    })
            
            # Generate new subscription ID
            new_subscription_id = generate_id(client_subscriptions)
            
            # Create new subscription record
            new_subscription = {
                "subscription_id": str(new_subscription_id),
                "client_id": str(subscription_data["client_id"]),
                "product_id": str(subscription_data["product_id"]),
                "subscription_type": subscription_data["subscription_type"],
                "start_date": subscription_data["start_date"],
                "end_date": subscription_data.get("end_date"),
                "sla_tier": subscription_data["sla_tier"],
                "rto_hours": subscription_data["rto_hours"],
                "status": subscription_data["status"],
                "created_at": "2025-10-01T00:00:00",
                "updated_at": "2025-10-01T00:00:00"
            }
            
            client_subscriptions[str(new_subscription_id)] = new_subscription
            
            return json.dumps({
                "success": True,
                "action": "create",
                "subscription_id": str(new_subscription_id),
                "subscription_data": new_subscription
            })
        
        elif action == "update":
            if not subscription_id:
                return json.dumps({
                    "success": False,
                    "error": "subscription_id is required for update action"
                })
            
            if subscription_id not in client_subscriptions:
                return json.dumps({
                    "success": False,
                    "error": f"Subscription record {subscription_id} not found"
                })
            
            if not subscription_data:
                return json.dumps({
                    "success": False,
                    "error": "subscription_data is required for update action"
                })
            
            # Validate only allowed fields are present for updates
            allowed_update_fields = ["subscription_type", "end_date", "sla_tier", "rto_hours", "status"]
            invalid_fields = [field for field in subscription_data.keys() if field not in allowed_update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for subscription update: {', '.join(invalid_fields)}. Cannot update client_id, product_id, or start_date."
                })
            
            # Validate enum fields if provided
            if "subscription_type" in subscription_data:
                valid_subscription_types = ["full_service", "limited_service", "trial", "custom"]
                if subscription_data["subscription_type"] not in valid_subscription_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid subscription_type '{subscription_data['subscription_type']}'. Must be one of: {', '.join(valid_subscription_types)}"
                    })
            
            if "sla_tier" in subscription_data:
                valid_sla_tiers = ["premium", "standard", "basic"]
                if subscription_data["sla_tier"] not in valid_sla_tiers:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid sla_tier '{subscription_data['sla_tier']}'. Must be one of: {', '.join(valid_sla_tiers)}"
                    })
            
            if "status" in subscription_data:
                valid_statuses = ["active", "expired", "cancelled", "suspended"]
                if subscription_data["status"] not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status '{subscription_data['status']}'. Must be one of: {', '.join(valid_statuses)}"
                    })
            
            # Validate RTO hours if provided
            if "rto_hours" in subscription_data:
                rto_hours = subscription_data["rto_hours"]
                if not isinstance(rto_hours, int) or rto_hours <= 0:
                    return json.dumps({
                        "success": False,
                        "error": "rto_hours must be a positive integer"
                    })
            
            # Get current subscription data
            current_subscription = client_subscriptions[subscription_id].copy()
            
            # Validate date logic if end_date is being updated
            if "end_date" in subscription_data and subscription_data["end_date"]:
                if subscription_data["end_date"] <= current_subscription["start_date"]:
                    return json.dumps({
                        "success": False,
                        "error": "end_date must be after start_date"
                    })
            
            # Check for duplicate active subscription if status is being changed to active
            if "status" in subscription_data and subscription_data["status"] == "active":
                client_id = current_subscription["client_id"]
                product_id = current_subscription["product_id"]
                for existing_id, existing_subscription in client_subscriptions.items():
                    if (existing_id != subscription_id and
                        existing_subscription.get("client_id") == client_id and 
                        existing_subscription.get("product_id") == product_id and
                        existing_subscription.get("status") == "active"):
                        return json.dumps({
                            "success": False,
                            "error": f"Active subscription already exists for client {client_id} and product {product_id}"
                        })
            
            # Update subscription record
            updated_subscription = current_subscription.copy()
            for key, value in subscription_data.items():
                updated_subscription[key] = value
            
            updated_subscription["updated_at"] = "2025-10-01T00:00:00"
            client_subscriptions[subscription_id] = updated_subscription
            
            return json.dumps({
                "success": True,
                "action": "update",
                "subscription_id": str(subscription_id),
                "subscription_data": updated_subscription
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_client_subscriptions",
                "description": "Create or update client subscription records in the incident management system. This tool manages client subscriptions to various products and services, including service levels, SLA tiers, and recovery time objectives. For creation, establishes new subscription records with comprehensive validation to ensure proper configuration and prevent duplicate active subscriptions for the same client-product combination. For updates, modifies existing subscription records while maintaining data integrity. Validates subscription types, SLA tiers, status values, and date logic according to business requirements. Essential for client relationship management, service delivery, and SLA compliance tracking.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new subscription record, 'update' to modify existing subscription record",
                            "enum": ["create", "update"]
                        },
                        "subscription_data": {
                            "type": "object",
                            "description": "Subscription data object. For create: requires client_id, product_id, subscription_type, start_date (YYYY-MM-DD), sla_tier, rto_hours (positive integer), status, with optional end_date (YYYY-MM-DD, must be after start_date). For update: includes subscription fields to change (client_id, product_id, start_date cannot be updated). SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "client_id": {
                                    "type": "string",
                                    "description": "Reference to client record (required for create only, cannot be updated)"
                                },
                                "product_id": {
                                    "type": "string",
                                    "description": "Reference to product record (required for create only, cannot be updated)"
                                },
                                "subscription_type": {
                                    "type": "string",
                                    "description": "Type of subscription: 'full_service', 'limited_service', 'trial', 'custom'",
                                    "enum": ["full_service", "limited_service", "trial", "custom"]
                                },
                                "start_date": {
                                    "type": "string",
                                    "description": "Subscription start date in YYYY-MM-DD format (required for create only, cannot be updated)"
                                },
                                "end_date": {
                                    "type": "string",
                                    "description": "Subscription end date in YYYY-MM-DD format (optional, must be after start_date)"
                                },
                                "sla_tier": {
                                    "type": "string",
                                    "description": "Service level agreement tier: 'premium', 'standard', 'basic'",
                                    "enum": ["premium", "standard", "basic"]
                                },
                                "rto_hours": {
                                    "type": "integer",
                                    "description": "Recovery Time Objective in hours (positive integer)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Subscription status: 'active', 'expired', 'cancelled', 'suspended' (only one active subscription per client-product combination)",
                                    "enum": ["active", "expired", "cancelled", "suspended"]
                                }
                            }
                        },
                        "subscription_id": {
                            "type": "string",
                            "description": "Unique identifier of the subscription record (required for update action only)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverRootCauseAnalysisEntities(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover root cause analysis entities.
        
        Supported entities:
        - root_cause_analysis: Root cause analysis records
        """
        if entity_type not in ["root_cause_analysis"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'root_cause_analysis'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get("root_cause_analysis", {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "rca_id": str(entity_id)})
            else:
                results.append({**entity_data, "rca_id": str(entity_id)})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_root_cause_analysis_entities",
                "description": "Discover root cause analysis entities. Entity types: 'root_cause_analysis' (root cause analysis records; filterable by rca_id (string), incident_id (string), analysis_method (enum: 'five_whys', 'fishbone', 'timeline_analysis', 'fault_tree'), conducted_by_id (string), completed_at (timestamp), status (enum: 'in_progress', 'completed', 'approved'), created_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'root_cause_analysis'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For root_cause_analysis, filters are: rca_id (string), incident_id (string), analysis_method (enum: 'five_whys', 'fishbone', 'timeline_analysis', 'fault_tree'), conducted_by_id (string), completed_at (timestamp), status (enum: 'in_progress', 'completed', 'approved'), created_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageMetrics(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], metric_data: Dict[str, Any]) -> str:
        """
        Record incident performance metrics.

        metric_data must include:
        - incident_id (required)
        - metric_type (required): MTTA, MTTD, MTTR, MTTM, FTR
        - value_minutes (required)
        - target_minutes (optional)
        - recorded_at (optional)
        """

        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1

        metrics = data.get("metrics", {})
        incidents = data.get("incidents", {})

        incident_id = metric_data.get("incident_id")
        metric_type = metric_data.get("metric_type")
        value_minutes = metric_data.get("value_minutes")
        target_minutes = metric_data.get("target_minutes")
        recorded_at = metric_data.get("recorded_at")

        # Validate required fields
        if not all([incident_id, metric_type, value_minutes is not None]):
            return json.dumps({
                "success": False,
                "error": "Missing required fields: incident_id, metric_type, value_minutes"
            })

        # Validate incident exists and status
        if incident_id not in incidents:
            return json.dumps({"success": False, "error": f"Incident {incident_id} not found"})

        if incidents[incident_id].get("status") not in ["resolved", "closed"]:
            return json.dumps({
                "success": False,
                "error": f"Incident must be in 'resolved' or 'closed' status for metrics recording. Current status: {incidents[incident_id].get('status')}"
            })

        # Validate metric_type
        valid_metric_types = ["MTTA", "MTTD", "MTTR", "MTTM", "FTR"]
        if metric_type not in valid_metric_types:
            return json.dumps({
                "success": False,
                "error": f"Invalid metric_type. Must be one of: {', '.join(valid_metric_types)}"
            })

        # Validate value_minutes
        try:
            value_minutes = float(value_minutes)
            if value_minutes < 0:
                raise ValueError
        except (ValueError, TypeError):
            return json.dumps({
                "success": False,
                "error": "value_minutes must be a non-negative number"
            })

        # Validate target_minutes
        if target_minutes is not None:
            try:
                target_minutes = float(target_minutes)
                if target_minutes < 0:
                    raise ValueError
            except (ValueError, TypeError):
                return json.dumps({
                    "success": False,
                    "error": "target_minutes must be a non-negative number"
                })

        # Create new metric
        new_id = generate_id(metrics)
        new_metric = {
            "metric_id": str(new_id),
            "incident_id": incident_id,
            "metric_type": metric_type,
            "value_minutes": int(value_minutes),
            "target_minutes": int(target_minutes) if target_minutes is not None else None,
            "recorded_at": recorded_at if recorded_at else "2025-10-02T12:00:00",
            "created_at": "2025-10-02T12:00:00"
        }

        metrics[str(new_id)] = new_metric

        return json.dumps({
            "success": True,
            "action": "create",
            "metric_id": str(new_id),
            "message": f"Metrics {new_id} created successfully",
            "metric_data": new_metric
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_metrics",
                "description": "Create and record incident performance metrics in the incident management system. Supports MTTA, MTTD, MTTR, MTTM, FTR metrics. Requires approval from incident_manager or system_administrator. Can only record metrics for incidents in resolved or closed status.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "metric_data": {
                            "type": "object",
                            "description": "Metric data to record",
                            "properties": {
                                "incident_id": {"type": "string", "description": "ID of the incident (required)"},
                                "metric_type": {"type": "string", "enum": ["MTTA", "MTTD", "MTTR", "MTTM", "FTR"], "description": "Type of metric (required)"},
                                "value_minutes": {"type": "number", "description": "Metric value in minutes (required, non-negative)"},
                                "target_minutes": {"type": "number", "description": "Target value in minutes (optional, non-negative)"},
                                "recorded_at": {"type": "string", "description": "Timestamp of recording (optional)"}
                            },
                            "required": ["incident_id", "metric_type", "value_minutes"]
                        }
                    },
                    "required": ["metric_data"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageChangeRequests(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, change_data: Dict[str, Any] = None, change_id: str = None) -> str:
        """
        Create or update change request records.

        Actions:
        - create: Create new change request (requires change_data with title, change_type, requested_by_id, risk_level)
        - update: Update existing change request (requires change_id and change_data with fields to change)
        """
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1

        def generate_code(prefix: str, table: Dict[str, Any]) -> str:
            max_num = 0
            for record in table.values():
                code = record.get("change_code", "")
                if code.startswith(prefix):
                    try:
                        num = int(code.split("-")[-1])
                        max_num = max(max_num, num)
                    except:
                        pass
            return f"{prefix}-{str(max_num + 1).zfill(5)}"

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for change requests"
            })

        change_requests = data.get("change_requests", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        # Enums/allowed values
        valid_change_types = ["emergency", "standard", "normal"]
        valid_risk_levels = ["high", "medium", "low"]
        valid_statuses = ["requested", "approved", "scheduled", "in_progress", "completed", "failed", "rolled_back"]

        if action == "create":
            if not change_data:
                return json.dumps({
                    "success": False,
                    "error": "change_data is required for create action"
                })

            # Validate required fields
            required_fields = ["title", "change_type", "requested_by_id", "risk_level"]
            missing = [f for f in required_fields if f not in change_data or change_data.get(f) in [None, ""]]
            if missing:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields for change creation: {', '.join(missing)}"
                })

            # Only allow known fields to be supplied
            allowed_fields = [
                "title", "change_type", "requested_by_id", "approved_by_id", "risk_level",
                "incident_id", "scheduled_start", "scheduled_end", "actual_start", "actual_end", "status"
            ]
            invalid_fields = [k for k in change_data.keys() if k not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for change creation: {', '.join(invalid_fields)}"
                })

            title = change_data["title"]
            change_type = change_data["change_type"]
            requested_by_id = str(change_data["requested_by_id"])
            risk_level = change_data["risk_level"]
            incident_id = change_data.get("incident_id")
            approved_by_id = change_data.get("approved_by_id")
            scheduled_start = change_data.get("scheduled_start")
            scheduled_end = change_data.get("scheduled_end")
            actual_start = change_data.get("actual_start")
            actual_end = change_data.get("actual_end")
            status = change_data.get("status")

            # Validate enums
            if change_type not in valid_change_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid change_type. Must be one of: {', '.join(valid_change_types)}"
                })

            if risk_level not in valid_risk_levels:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid risk_level. Must be one of: {', '.join(valid_risk_levels)}"
                })

            if status and status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
                })

            # Validate incident if specified
            if incident_id and incident_id not in incidents:
                return json.dumps({
                    "success": False,
                    "error": f"Incident {incident_id} not found"
                })

            # Validate requested_by exists
            if requested_by_id not in users:
                return json.dumps({
                    "success": False,
                    "error": f"Requester {requested_by_id} not found"
                })

            # Generate and create
            new_id = generate_id(change_requests)
            change_code = generate_code("CHG-2025", change_requests)
            new_change_request = {
                "change_id": str(new_id),
                "change_code": change_code,
                "incident_id": incident_id,
                "title": title,
                "change_type": change_type,
                "requested_by_id": requested_by_id,
                "approved_by_id": approved_by_id,
                "risk_level": risk_level,
                "scheduled_start": scheduled_start,
                "scheduled_end": scheduled_end,
                "actual_start": actual_start,
                "actual_end": actual_end,
                "status": status if status else "requested",
                "created_at": "2025-10-02T12:00:00",
                "updated_at": "2025-10-02T12:00:00"
            }

            change_requests[str(new_id)] = new_change_request

            return json.dumps({
                "success": True,
                "action": "create",
                "change_id": str(new_id),
                "message": f"Change request {new_id} created successfully",
                "change_request_data": new_change_request
            })

        elif action == "update":
            if not change_id:
                return json.dumps({
                    "success": False,
                    "error": "change_id is required for update action"
                })

            if change_id not in change_requests:
                return json.dumps({
                    "success": False,
                    "error": f"Change request {change_id} not found"
                })

            if not change_data:
                return json.dumps({
                    "success": False,
                    "error": "change_data is required for update action"
                })

            # Only allow known update fields
            allowed_update_fields = [
                "title", "change_type", "requested_by_id", "approved_by_id", "risk_level",
                "incident_id", "scheduled_start", "scheduled_end", "actual_start", "actual_end", "status"
            ]
            invalid_fields = [k for k in change_data.keys() if k not in allowed_update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for change update: {', '.join(invalid_fields)}"
                })

            # At least one valid field must be present
            if not any(field in change_data for field in allowed_update_fields):
                return json.dumps({
                    "success": False,
                    "error": "At least one updatable field must be provided in change_data"
                })

            current_change = change_requests[change_id].copy()

            # Validate and apply updates
            if "title" in change_data:
                current_change["title"] = change_data["title"]

            if "change_type" in change_data:
                ct = change_data["change_type"]
                if ct not in valid_change_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid change_type. Must be one of: {', '.join(valid_change_types)}"
                    })
                current_change["change_type"] = ct

            if "requested_by_id" in change_data:
                rb = str(change_data["requested_by_id"])
                if rb not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"Requester {rb} not found"
                    })
                current_change["requested_by_id"] = rb

            if "approved_by_id" in change_data:
                current_change["approved_by_id"] = change_data["approved_by_id"]

            if "risk_level" in change_data:
                rl = change_data["risk_level"]
                if rl not in valid_risk_levels:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid risk_level. Must be one of: {', '.join(valid_risk_levels)}"
                    })
                current_change["risk_level"] = rl

            if "incident_id" in change_data:
                inc = change_data["incident_id"]
                if inc and inc not in incidents:
                    return json.dumps({
                        "success": False,
                        "error": f"Incident {inc} not found"
                    })
                current_change["incident_id"] = inc

            if "scheduled_start" in change_data:
                current_change["scheduled_start"] = change_data["scheduled_start"]
            if "scheduled_end" in change_data:
                current_change["scheduled_end"] = change_data["scheduled_end"]
            if "actual_start" in change_data:
                current_change["actual_start"] = change_data["actual_start"]
            if "actual_end" in change_data:
                current_change["actual_end"] = change_data["actual_end"]

            if "status" in change_data:
                st = change_data["status"]
                if st not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
                    })
                current_change["status"] = st

            current_change["updated_at"] = "2025-10-02T12:00:00"
            change_requests[change_id] = current_change

            return json.dumps({
                "success": True,
                "action": "update",
                "change_id": change_id,
                "message": f"Change request {change_id} updated successfully",
                "change_request_data": current_change
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_change_requests",
                "description": "Create or update change request records in the incident management system. Manages emergency, standard, and normal changes. Requires approval from technical support, incident managers, system administrators, or executives.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' or 'update'",
                            "enum": ["create", "update"]
                        },
                        "change_data": {
                            "type": "object",
                            "description": "Change data object. For create: requires title (short text), change_type (enum), requested_by_id (user ID), risk_level (enum). For update: include fields to change. SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "title": {"type": "string", "description": "Change title (required for create)"},
                                "change_type": {
                                    "type": "string",
                                    "description": "Type of change (required for create)",
                                    "enum": ["emergency", "standard", "normal"]
                                },
                                "requested_by_id": {"type": "string", "description": "Requester user ID (required for create)"},
                                "risk_level": {
                                    "type": "string",
                                    "description": "Risk level (required for create)",
                                    "enum": ["high", "medium", "low"]
                                },
                                "incident_id": {"type": "string", "description": "Associated incident ID (optional)"},
                                "approved_by_id": {"type": "string", "description": "Approver user ID (optional)"},
                                "scheduled_start": {"type": "string", "description": "Scheduled start timestamp (optional)"},
                                "scheduled_end": {"type": "string", "description": "Scheduled end timestamp (optional)"},
                                "actual_start": {"type": "string", "description": "Actual start timestamp (optional)"},
                                "actual_end": {"type": "string", "description": "Actual end timestamp (optional)"},
                                "status": {
                                    "type": "string",
                                    "description": "Current status (optional)",
                                    "enum": ["requested", "approved", "scheduled", "in_progress", "completed", "failed", "rolled_back"]
                                },
                                # Inline approver flags (used to indicate approval presence)
                                "technical_support": {"type": "boolean", "description": "Technical support approval flag (optional)"},
                                "incident_manager": {"type": "boolean", "description": "Incident manager approval flag (optional)"},
                                "system_administrator": {"type": "boolean", "description": "System admin approval flag (optional)"},
                                "executive": {"type": "boolean", "description": "Executive approval flag (optional)"}
                            }
                        },
                        "change_id": {
                            "type": "string",
                            "description": "Unique identifier of the change request (required for update action only)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageComponents(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        approval: bool,
        # For Create
        component_name: Optional[str] = None,
        component_type: Optional[str] = None,
        environment: Optional[str] = None,
        product_id: Optional[str] = None,
        location: Optional[str] = None,
        port_number: Optional[int] = None,
        status: Optional[str] = "online",
        # For Update
        component_id: Optional[str] = None
    ) -> str:

        components = data.get("components", {})
        products = data.get("products", {})

        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1

        valid_types = [
            "sftp_server", "api_endpoint", "database", "load_balancer",
            "firewall", "authentication_service", "payment_gateway",
            "file_storage", "monitoring_system"
        ]
        valid_envs = ["production", "staging", "development", "test"]
        valid_status = ["online", "offline", "maintenance", "degraded"]

        # ----- Check Approval -----
        if not approval:
            return json.dumps({
                "success": False,
                "error": "Approval missing for component management action"
            })

        # ----- CREATE -----
        if not component_id:
            if not component_name or not component_type or not environment:
                return json.dumps({
                    "success": False,
                    "error": "Missing or invalid inputs"
                })

            if component_type not in valid_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid component_type. Must be one of {valid_types}"
                })

            if environment not in valid_envs:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid environment. Must be one of {valid_envs}"
                })

            if status and status not in valid_status:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status. Must be one of {valid_status}"
                })

            # Validate product if provided
            if product_id:
                product = products.get(product_id)
                if not product or product.get("status") != "active":
                    return json.dumps({
                        "success": False,
                        "error": "Product not found or inactive"
                    })

            # Ensure component_name uniqueness within product_id scope
            for comp in components.values():
                if comp.get("product_id") == product_id and comp.get("component_name") == component_name:
                    return json.dumps({
                        "success": False,
                        "error": "Component name already exists within product"
                    })

            # Create new component
            new_id = str(generate_id(components))
            timestamp = "2025-10-01T00:00:00"

            new_component = {
                "component_id": new_id,
                "component_name": component_name,
                "component_type": component_type,
                "environment": environment,
                "product_id": product_id,
                "location": location,
                "port_number": port_number,
                "status": status,
                "created_at": timestamp
            }
            components[new_id] = new_component

            # Audit logging
            if not data.get("audit_log"):
                data["audit_log"] = []
            data["audit_log"].append({
                "action": "create_component",
                "component_id": new_id,
                "timestamp": timestamp
            })

            return json.dumps(new_component)

        # ----- UPDATE -----
        else:
            if component_id not in components:
                return json.dumps({
                    "success": False,
                    "error": "Component not found"
                })

            component = components[component_id]

            if component_name:
                # Ensure uniqueness within product scope
                for cid, existing in components.items():
                    if cid != component_id and existing.get("product_id") == (product_id or component["product_id"]) and existing.get("component_name") == component_name:
                        return json.dumps({
                            "success": False,
                            "error": "New component_name already exists within product"
                        })
                component["component_name"] = component_name

            if component_type and component_type not in valid_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid component_type. Must be one of {valid_types}"
                })

            if environment and environment not in valid_envs:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid environment. Must be one of {valid_envs}"
                })

            if status and status not in valid_status:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status. Must be one of {valid_status}"
                })

            if product_id:
                product = products.get(product_id)
                if not product or product.get("status") != "active":
                    return json.dumps({
                        "success": False,
                        "error": "Product not found or inactive"
                    })
                component["product_id"] = product_id

            # Apply updates
            for field, val in [
                ("component_type", component_type), ("environment", environment),
                ("location", location), ("port_number", port_number),
                ("status", status)
            ]:
                if val is not None:
                    component[field] = val

            # Audit logging
            timestamp = "2025-10-01T00:00:00"
            if not data.get("audit_log"):
                data["audit_log"] = []
            data["audit_log"].append({
                "action": "update_component",
                "component_id": component_id,
                "timestamp": timestamp
            })

            return json.dumps(component)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_components",
                "description": (
                    "Create or update infrastructure component records in the incident management system. "
                    "Validates component_name uniqueness within product scope, checks product activity, "
                    "and requires approval from system_administrator, technical_support, or incident_manager. "
                    "Handles component creation and updates with audit trail logging. "
                    "Errors trigger human handoff if approval is missing, invalid inputs, duplicate component name, "
                    "product issues, or audit logging fails."
                ),
                "parameters": {
                    "type": "object",
                    "properties": {
                        "component_id": {
                            "type": "string",
                            "description": "Existing component ID for updates. "
                                           "If omitted, a new component will be created."
                        },
                        "component_name": {"type": "string"},
                        "component_type": {
                            "type": "string",
                            "description": "Must be one of: sftp_server, api_endpoint, database, "
                                           "load_balancer, firewall, authentication_service, "
                                           "payment_gateway, file_storage, monitoring_system"
                        },
                        "environment": {
                            "type": "string",
                            "description": "Must be one of: production, staging, development, test"
                        },
                        "product_id": {"type": "string"},
                        "location": {"type": "string"},
                        "port_number": {"type": "number"},
                        "status": {
                            "type": "string",
                            "description": "Must be one of: online, offline, maintenance, degraded"
                        },
                        "approval": {
                            "type": "boolean",
                            "description": "Approval required from system_administrator, "
                                           "technical_support, or incident_manager."
                        }
                    },
                    "required": ["approval"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageSlaAgreements(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, sla_data: Dict[str, Any] = None, sla_id: str = None) -> str:
        """
        Create or update SLA agreement records.
        
        Actions:
        - create: Create new SLA agreement record (requires sla_data with subscription_id, severity_level, response_time_minutes, resolution_time_hours)
        - update: Update existing SLA agreement record (requires sla_id and sla_data with changes)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        # Access sla_agreements data
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for sla_agreements"
            })
        
        sla_agreements = data.get("sla_agreements", {})
        
        if action == "create":
            if not sla_data:
                return json.dumps({
                    "success": False,
                    "error": "sla_data is required for create action"
                })
            
            # Validate required fields for creation
            required_fields = ["subscription_id", "severity_level", "response_time_minutes", "resolution_time_hours"]
            missing_fields = [field for field in required_fields if field not in sla_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields for SLA agreement creation: {', '.join(missing_fields)}"
                })
            
            # Validate only allowed fields are present
            allowed_fields = ["subscription_id", "severity_level", "response_time_minutes", "resolution_time_hours", "availability_percentage"]
            invalid_fields = [field for field in sla_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for SLA agreement creation: {', '.join(invalid_fields)}"
                })
            
            # Validate enum fields
            valid_severity_levels = ["P1", "P2", "P3", "P4"]
            if sla_data["severity_level"] not in valid_severity_levels:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid severity_level '{sla_data['severity_level']}'. Must be one of: {', '.join(valid_severity_levels)}"
                })
            
            # Validate response time minutes
            response_time = sla_data["response_time_minutes"]
            if not isinstance(response_time, int) or response_time <= 0:
                return json.dumps({
                    "success": False,
                    "error": "response_time_minutes must be a positive integer"
                })
            
            # Validate resolution time hours
            resolution_time = sla_data["resolution_time_hours"]
            if not isinstance(resolution_time, int) or resolution_time <= 0:
                return json.dumps({
                    "success": False,
                    "error": "resolution_time_hours must be a positive integer"
                })
            
            # Validate availability percentage if provided
            if "availability_percentage" in sla_data:
                availability = sla_data["availability_percentage"]
                if not isinstance(availability, (int, float)) or availability < 0 or availability > 100:
                    return json.dumps({
                        "success": False,
                        "error": "availability_percentage must be a number between 0 and 100"
                    })
            
            # Check for duplicate SLA agreement for same subscription and severity level
            subscription_id = sla_data["subscription_id"]
            severity_level = sla_data["severity_level"]
            for existing_sla in sla_agreements.values():
                if (existing_sla.get("subscription_id") == subscription_id and 
                    existing_sla.get("severity_level") == severity_level):
                    return json.dumps({
                        "success": False,
                        "error": f"SLA agreement already exists for subscription {subscription_id} with severity level {severity_level}"
                    })
            
            # Generate new SLA ID
            new_sla_id = generate_id(sla_agreements)
            
            # Create new SLA agreement record
            new_sla = {
                "sla_id": str(new_sla_id),
                "subscription_id": str(sla_data["subscription_id"]),
                "severity_level": sla_data["severity_level"],
                "response_time_minutes": sla_data["response_time_minutes"],
                "resolution_time_hours": sla_data["resolution_time_hours"],
                "availability_percentage": sla_data.get("availability_percentage"),
                "created_at": "2025-10-01T00:00:00"
            }
            
            sla_agreements[str(new_sla_id)] = new_sla
            
            return json.dumps({
                "success": True,
                "action": "create",
                "sla_id": str(new_sla_id),
                "sla_data": new_sla
            })
        
        elif action == "update":
            if not sla_id:
                return json.dumps({
                    "success": False,
                    "error": "sla_id is required for update action"
                })
            
            if sla_id not in sla_agreements:
                return json.dumps({
                    "success": False,
                    "error": f"SLA agreement record {sla_id} not found"
                })
            
            if not sla_data:
                return json.dumps({
                    "success": False,
                    "error": "sla_data is required for update action"
                })
            
            # Validate only allowed fields are present for updates
            allowed_update_fields = ["response_time_minutes", "resolution_time_hours", "availability_percentage"]
            invalid_fields = [field for field in sla_data.keys() if field not in allowed_update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for SLA agreement update: {', '.join(invalid_fields)}. Cannot update subscription_id or severity_level."
                })
            
            # Validate response time minutes if provided
            if "response_time_minutes" in sla_data:
                response_time = sla_data["response_time_minutes"]
                if not isinstance(response_time, int) or response_time <= 0:
                    return json.dumps({
                        "success": False,
                        "error": "response_time_minutes must be a positive integer"
                    })
            
            # Validate resolution time hours if provided
            if "resolution_time_hours" in sla_data:
                resolution_time = sla_data["resolution_time_hours"]
                if not isinstance(resolution_time, int) or resolution_time <= 0:
                    return json.dumps({
                        "success": False,
                        "error": "resolution_time_hours must be a positive integer"
                    })
            
            # Validate availability percentage if provided
            if "availability_percentage" in sla_data:
                availability = sla_data["availability_percentage"]
                if availability is not None and (not isinstance(availability, (int, float)) or availability < 0 or availability > 100):
                    return json.dumps({
                        "success": False,
                        "error": "availability_percentage must be a number between 0 and 100"
                    })
            
            # Get current SLA data
            current_sla = sla_agreements[sla_id].copy()
            
            # Update SLA agreement record
            updated_sla = current_sla.copy()
            for key, value in sla_data.items():
                updated_sla[key] = value
            
            sla_agreements[sla_id] = updated_sla
            
            return json.dumps({
                "success": True,
                "action": "update",
                "sla_id": str(sla_id),
                "sla_data": updated_sla
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_sla_agreements",
                "description": "Create or update SLA agreement records in the incident management system. This tool manages service level agreements that define response and resolution time commitments for different incident severity levels. For creation, establishes new SLA agreement records with comprehensive validation to ensure proper time commitments and prevent duplicate agreements for the same subscription-severity combination. For updates, modifies existing SLA agreement records while maintaining data integrity. Validates severity levels, time commitments, and availability percentages according to business requirements. Essential for incident response planning, performance measurement, and client expectation management.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new SLA agreement record, 'update' to modify existing SLA agreement record",
                            "enum": ["create", "update"]
                        },
                        "sla_data": {
                            "type": "object",
                            "description": "SLA agreement data object. For create: requires subscription_id, severity_level, response_time_minutes (positive integer), resolution_time_hours (positive integer), with optional availability_percentage (0-100). For update: includes SLA fields to change (subscription_id and severity_level cannot be updated). SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "subscription_id": {
                                    "type": "string",
                                    "description": "Reference to client subscription record (required for create only, cannot be updated, unique with severity_level)"
                                },
                                "severity_level": {
                                    "type": "string",
                                    "description": "Incident severity level: 'P1', 'P2', 'P3', 'P4' (required for create only, cannot be updated)",
                                    "enum": ["P1", "P2", "P3", "P4"]
                                },
                                "response_time_minutes": {
                                    "type": "integer",
                                    "description": "Maximum response time in minutes (positive integer)"
                                },
                                "resolution_time_hours": {
                                    "type": "integer",
                                    "description": "Maximum resolution time in hours (positive integer)"
                                },
                                "availability_percentage": {
                                    "type": "number",
                                    "description": "Service availability commitment as percentage (0-100, optional)"
                                }
                            }
                        },
                        "sla_id": {
                            "type": "string",
                            "description": "Unique identifier of the SLA agreement record (required for update action only)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverVendors(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover vendor entities.
        
        Supported entities:
        - vendors: Vendor records by vendor_id, vendor_name, vendor_type, contact_email, status
        """
        if entity_type not in ["vendors"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'vendors'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get("vendors", {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "vendor_id": str(entity_id)})
            else:
                results.append({**entity_data, "vendor_id": str(entity_id)})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_vendors",
                "description": "Discover vendor entities. Entity types: 'vendors' (vendor records; filterable by vendor_id (string), vendor_name (string), vendor_type (enum: 'cloud_provider', 'payment_processor', 'software_vendor', 'infrastructure_provider', 'security_vendor'), contact_email (string), contact_phone (string), status (enum: 'active', 'inactive', 'suspended'), created_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'vendors'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For vendors, filters are: vendor_id (string), vendor_name (string), vendor_type (enum: 'cloud_provider', 'payment_processor', 'software_vendor', 'infrastructure_provider', 'security_vendor'), contact_email (string), contact_phone (string), status (enum: 'active', 'inactive', 'suspended'), created_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageRootCauseAnalysis(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, rca_data: Dict[str, Any] = None, rca_id: str = None) -> str:
        """
        Create or update root cause analysis records.
        
        Actions:
        - create: Create new RCA record (requires rca_data with incident_id, analysis_method, conducted_by_id, status)
        - update: Update existing RCA record (requires rca_id and rca_data with changes)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        # Access root_cause_analysis data
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for root_cause_analysis"
            })
        
        root_cause_analysis = data.get("root_cause_analysis", {})
        
        if action == "create":
            if not rca_data:
                return json.dumps({
                    "success": False,
                    "error": "rca_data is required for create action"
                })
            
            # Validate required fields for creation
            required_fields = ["incident_id", "analysis_method", "conducted_by_id", "status"]
            missing_fields = [field for field in required_fields if field not in rca_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields for RCA creation: {', '.join(missing_fields)}"
                })
            
            # Validate only allowed fields are present
            allowed_fields = ["incident_id", "analysis_method", "conducted_by_id", "completed_at", "status"]
            invalid_fields = [field for field in rca_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for RCA creation: {', '.join(invalid_fields)}"
                })
            
            # Validate enum fields
            valid_analysis_methods = ["five_whys", "fishbone", "timeline_analysis", "fault_tree"]
            if rca_data["analysis_method"] not in valid_analysis_methods:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid analysis_method '{rca_data['analysis_method']}'. Must be one of: {', '.join(valid_analysis_methods)}"
                })
            
            valid_statuses = ["in_progress", "completed", "approved"]
            if rca_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status '{rca_data['status']}'. Must be one of: {', '.join(valid_statuses)}"
                })
            
            # Check for existing RCA for the same incident
            incident_id = rca_data["incident_id"]
            for existing_rca in root_cause_analysis.values():
                if existing_rca.get("incident_id") == incident_id:
                    return json.dumps({
                        "success": False,
                        "error": f"Root cause analysis already exists for incident {incident_id}"
                    })
            
            # Generate new RCA ID
            new_rca_id = generate_id(root_cause_analysis)
            
            # Create new RCA record
            new_rca = {
                "rca_id": str(new_rca_id),
                "incident_id": str(rca_data["incident_id"]),
                "analysis_method": rca_data["analysis_method"],
                "conducted_by_id": str(rca_data["conducted_by_id"]),
                "completed_at": rca_data.get("completed_at"),
                "status": rca_data["status"],
                "created_at": "2025-10-01T00:00:00"
            }
            
            root_cause_analysis[str(new_rca_id)] = new_rca
            
            return json.dumps({
                "success": True,
                "action": "create",
                "rca_id": str(new_rca_id),
                "rca_data": new_rca
            })
        
        elif action == "update":
            if not rca_id:
                return json.dumps({
                    "success": False,
                    "error": "rca_id is required for update action"
                })
            
            if rca_id not in root_cause_analysis:
                return json.dumps({
                    "success": False,
                    "error": f"Root cause analysis record {rca_id} not found"
                })
            
            if not rca_data:
                return json.dumps({
                    "success": False,
                    "error": "rca_data is required for update action"
                })
            
            # Validate only allowed fields are present for updates
            allowed_update_fields = ["analysis_method", "completed_at", "status"]
            invalid_fields = [field for field in rca_data.keys() if field not in allowed_update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for RCA update: {', '.join(invalid_fields)}. Cannot update incident_id or conducted_by_id."
                })
            
            # Validate enum fields if provided
            if "analysis_method" in rca_data:
                valid_analysis_methods = ["five_whys", "fishbone", "timeline_analysis", "fault_tree"]
                if rca_data["analysis_method"] not in valid_analysis_methods:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid analysis_method '{rca_data['analysis_method']}'. Must be one of: {', '.join(valid_analysis_methods)}"
                    })
            
            if "status" in rca_data:
                valid_statuses = ["in_progress", "completed", "approved"]
                if rca_data["status"] not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status '{rca_data['status']}'. Must be one of: {', '.join(valid_statuses)}"
                    })
            
            # Get current RCA data
            current_rca = root_cause_analysis[rca_id].copy()
            
            # Validate status transitions
            current_status = current_rca.get("status")
            new_status = rca_data.get("status")
            
            if new_status and current_status == "approved" and new_status != "approved":
                return json.dumps({
                    "success": False,
                    "error": "Cannot change status from approved to another status"
                })
            
            # If status is being changed to completed, set completed_at if not provided
            if new_status == "completed" and current_status != "completed" and "completed_at" not in rca_data:
                rca_data["completed_at"] = "2025-10-01T00:00:00"
            
            # Update RCA record
            updated_rca = current_rca.copy()
            for key, value in rca_data.items():
                updated_rca[key] = value
            
            root_cause_analysis[rca_id] = updated_rca
            
            return json.dumps({
                "success": True,
                "action": "update",
                "rca_id": str(rca_id),
                "rca_data": updated_rca
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_root_cause_analysis",
                "description": "Create or update root cause analysis records in the incident management system. This tool manages the systematic investigation process to identify underlying causes of incidents and prevent recurrence. For creation, establishes new RCA records with comprehensive validation to ensure proper methodology selection and prevent duplicate analyses for the same incident. For updates, modifies existing RCA records while maintaining data integrity and enforcing proper status transitions. Validates analysis methods and status values according to incident management best practices. Essential for continuous improvement, incident prevention, and organizational learning from operational failures.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new RCA record, 'update' to modify existing RCA record",
                            "enum": ["create", "update"]
                        },
                        "rca_data": {
                            "type": "object",
                            "description": "Root cause analysis data object. For create: requires incident_id (unique), analysis_method, conducted_by_id, status, with optional completed_at. For update: includes RCA fields to change (incident_id and conducted_by_id cannot be updated). SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "incident_id": {
                                    "type": "string",
                                    "description": "Reference to the incident record (required for create only, cannot be updated, must be unique)"
                                },
                                "analysis_method": {
                                    "type": "string",
                                    "description": "Root cause analysis methodology: 'five_whys', 'fishbone', 'timeline_analysis', 'fault_tree'",
                                    "enum": ["five_whys", "fishbone", "timeline_analysis", "fault_tree"]
                                },
                                "conducted_by_id": {
                                    "type": "string",
                                    "description": "User ID who is conducting the analysis (required for create only, cannot be updated)"
                                },
                                "completed_at": {
                                    "type": "string",
                                    "description": "Timestamp when analysis was completed (optional, automatically set when status changes to completed)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Current status of the analysis: 'in_progress', 'completed', 'approved' (approved status cannot be changed)",
                                    "enum": ["in_progress", "completed", "approved"]
                                }
                            }
                        },
                        "rca_id": {
                            "type": "string",
                            "description": "Unique identifier of the RCA record (required for update action only)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool


class ManageClients(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, client_data: Dict[str, Any] = None, client_id: str = None) -> str:
        """
        Create or update client records.

        Actions:
        - create: Create new client (requires client_data with client_name, client_type, country)
        - update: Update existing client (requires client_id and client_data with fields to change)
        """
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for clients"
            })

        clients = data.get("clients", {})

        valid_client_types = ["enterprise", "mid_market", "small_business", "startup"]
        valid_statuses = ["active", "inactive", "suspended"]

        if action == "create":
            if not client_data:
                return json.dumps({
                    "success": False,
                    "error": "client_data is required for create action"
                })

            # Required fields
            required_fields = ["client_name", "client_type", "country"]
            missing = [f for f in required_fields if f not in client_data or not client_data.get(f)]
            if missing:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields for client creation: {', '.join(missing)}"
                })

            client_name = client_data["client_name"]
            client_type = client_data["client_type"]
            country = client_data["country"]
            registration_number = client_data.get("registration_number")
            contact_email = client_data.get("contact_email")
            industry = client_data.get("industry")
            status = client_data.get("status", "active")

            # Validate client_type
            if client_type not in valid_client_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid client_type. Must be one of: {', '.join(valid_client_types)}"
                })

            # Validate status
            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
                })

            # Check uniqueness of client_name
            for existing_client in clients.values():
                if existing_client.get("client_name") == client_name:
                    return json.dumps({
                        "success": False,
                        "error": f"Client name '{client_name}' already exists"
                    })

            # Check uniqueness of registration_number if provided
            if registration_number:
                for existing_client in clients.values():
                    if existing_client.get("registration_number") == registration_number:
                        return json.dumps({
                            "success": False,
                            "error": f"Registration number '{registration_number}' already exists"
                        })

            # Create client
            new_id = generate_id(clients)
            new_client = {
                "client_id": str(new_id),
                "client_name": client_name,
                "client_type": client_type,
                "country": country,
                "status": status,
                "created_at": "2025-10-04T12:00:00",
                "updated_at": "2025-10-04T12:00:00"
            }

            if registration_number:
                new_client["registration_number"] = registration_number
            if contact_email:
                new_client["contact_email"] = contact_email
            if industry:
                new_client["industry"] = industry

            clients[str(new_id)] = new_client

            return json.dumps({
                "success": True,
                "action": "create",
                "client_id": str(new_id),
                "message": f"Client {new_id} created successfully",
                "client_data": new_client
            })

        elif action == "update":
            if not client_id:
                return json.dumps({
                    "success": False,
                    "error": "client_id is required for update action"
                })

            if client_id not in clients:
                return json.dumps({
                    "success": False,
                    "error": f"Client {client_id} not found"
                })

            if not client_data:
                return json.dumps({
                    "success": False,
                    "error": "client_data is required for update action"
                })

            current_client = clients[client_id].copy()

            # Validate and update client_type
            if "client_type" in client_data:
                ct = client_data["client_type"]
                if ct not in valid_client_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid client_type. Must be one of: {', '.join(valid_client_types)}"
                    })
                current_client["client_type"] = ct

            # Validate and update status
            if "status" in client_data:
                st = client_data["status"]
                if st not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
                    })
                current_client["status"] = st

            # Check uniqueness of client_name if updating
            if "client_name" in client_data:
                new_name = client_data["client_name"]
                for cid, existing_client in clients.items():
                    if cid != client_id and existing_client.get("client_name") == new_name:
                        return json.dumps({
                            "success": False,
                            "error": f"Client name '{new_name}' already exists"
                        })
                current_client["client_name"] = new_name

            # Check uniqueness of registration_number if updating
            if "registration_number" in client_data:
                new_reg = client_data["registration_number"]
                for cid, existing_client in clients.items():
                    if cid != client_id and existing_client.get("registration_number") == new_reg:
                        return json.dumps({
                            "success": False,
                            "error": f"Registration number '{new_reg}' already exists"
                        })
                current_client["registration_number"] = new_reg

            # Update other fields
            for field in ["contact_email", "industry", "country"]:
                if field in client_data:
                    current_client[field] = client_data[field]

            current_client["updated_at"] = "2025-10-04T12:00:00"
            clients[client_id] = current_client

            return json.dumps({
                "success": True,
                "action": "update",
                "client_id": client_id,
                "message": f"Client {client_id} updated successfully",
                "client_data": current_client
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_clients",
                "description": "Create or update client records in the incident management system. Validates uniqueness of client names and registration numbers. Supports enterprise, mid-market, small business, and startup client types.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' or 'update'",
                            "enum": ["create", "update"]
                        },
                        "client_data": {
                            "type": "object",
                            "description": "Client data object. For create: requires client_name, client_type, country. For update: include fields to modify. SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "client_name": {"type": "string", "description": "Name of the client (required for create)"},
                                "client_type": {
                                    "type": "string",
                                    "description": "Type of client (required for create)",
                                    "enum": ["enterprise", "mid_market", "small_business", "startup"]
                                },
                                "country": {"type": "string", "description": "Client's country (required for create)"},
                                "registration_number": {"type": "string", "description": "Registration number (optional)"},
                                "contact_email": {"type": "string", "description": "Contact email (optional)"},
                                "industry": {"type": "string", "description": "Industry (optional)"},
                                "status": {
                                    "type": "string",
                                    "description": "Client status (optional)",
                                    "enum": ["active", "inactive", "suspended"]
                                }
                            }
                        },
                        "client_id": {"type": "string", "description": "Unique identifier of the client (required for update action only)"}
                    },
                    "required": ["action"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageIncidentReports(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, report_data: Dict[str, Any] = None, report_id: str = None) -> str:
        """
        Generate or update incident reports.

        Actions:
        - create: Generate new incident report (requires report_data with incident_id, report_type, generated_by_id)
        - update: Update existing incident report (requires report_id and report_data with fields to change)
        """
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        incident_reports = data.get("incident_reports", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        valid_report_types = ["executive_summary", "technical_details", "business_impact", "compliance_report", "post_mortem"]
        valid_statuses = ["draft", "completed", "distributed"]
        # valid_roles = ["incident_manager", "executive"]

        if action == "create":
            if not report_data:
                return json.dumps({
                    "success": False,
                    "error": "report_data is required for create action"
                })

            required_fields = ["incident_id", "report_type", "generated_by_id"]
            missing = [f for f in required_fields if f not in report_data or not report_data.get(f)]
            if missing:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields for report creation: {', '.join(missing)}"
                })

            incident_id = str(report_data["incident_id"])
            report_type = report_data["report_type"]
            generated_by_id = str(report_data["generated_by_id"])
            status = report_data.get("status")

            # Validate incident
            if incident_id not in incidents:
                return json.dumps({
                    "success": False,
                    "error": f"Incident {incident_id} not found"
                })

            # Validate user
            if generated_by_id not in users:
                return json.dumps({
                    "success": False,
                    "error": f"User {generated_by_id} not found"
                })

            # Validate report type
            if report_type not in valid_report_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid report_type. Must be one of: {', '.join(valid_report_types)}"
                })

            # Post-mortem incident status validation
            if report_type == "post_mortem":
                incident_status = incidents[incident_id].get("status")
                if incident_status not in ["resolved", "closed"]:
                    return json.dumps({
                        "success": False,
                        "error": f"Incident must be 'resolved' or 'closed' for post_mortem report. Current status: {incident_status}"
                    })

            if status and status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
                })

            # Generate report
            new_id = generate_id(incident_reports)
            new_report = {
                "report_id": str(new_id),
                "incident_id": incident_id,
                "report_type": report_type,
                "generated_by_id": generated_by_id,
                "generated_at": "2025-10-02T12:00:00",
                "status": status if status else "draft",
                "created_at": "2025-10-02T12:00:00",
                "updated_at": "2025-10-02T12:00:00"
            }

            incident_reports[str(new_id)] = new_report

            return json.dumps({
                "success": True,
                "action": "create",
                "report_id": str(new_id),
                "message": f"Incident report {new_id} created successfully",
                "incident_report_data": new_report
            })

        elif action == "update":
            if not report_id:
                return json.dumps({
                    "success": False,
                    "error": "report_id is required for update action"
                })

            if report_id not in incident_reports:
                return json.dumps({
                    "success": False,
                    "error": f"Incident report {report_id} not found"
                })

            if not report_data:
                return json.dumps({
                    "success": False,
                    "error": "report_data is required for update action"
                })

            current_report = incident_reports[report_id].copy()

            # Update allowed fields
            allowed_update_fields = ["report_type", "status", "generated_by_id"]
            invalid_fields = [k for k in report_data.keys() if k not in allowed_update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for report update: {', '.join(invalid_fields)}"
                })

            if "report_type" in report_data:
                rt = report_data["report_type"]
                if rt not in valid_report_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid report_type. Must be one of: {', '.join(valid_report_types)}"
                    })
                current_report["report_type"] = rt

            if "status" in report_data:
                st = report_data["status"]
                if st not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
                    })
                current_report["status"] = st

            if "generated_by_id" in report_data:
                gid = str(report_data["generated_by_id"])
                if gid not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"User {gid} not found"
                    })
                
                current_report["generated_by_id"] = gid

            current_report["updated_at"] = "2025-10-02T12:00:00"
            incident_reports[report_id] = current_report

            return json.dumps({
                "success": True,
                "action": "update",
                "report_id": report_id,
                "message": f"Incident report {report_id} updated successfully",
                "incident_report_data": current_report
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_incident_reports",
                "description": "Generate or update incident reports in the incident management system. Supports executive summaries, technical details, business impact, compliance reports, and post-mortem reports. Restricted to incident managers and executives. Post-mortem reports only allowed for resolved or closed incidents.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' or 'update'",
                            "enum": ["create", "update"]
                        },
                        "report_data": {
                            "type": "object",
                            "description": "Incident report data object. For create: requires incident_id, report_type, generated_by_id. For update: include fields to modify. SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "incident_id": {"type": "string", "description": "ID of the incident (required for create)"},
                                "report_type": {
                                    "type": "string",
                                    "description": "Type of report (required for create)",
                                    "enum": ["executive_summary", "technical_details", "business_impact", "compliance_report", "post_mortem"]
                                },
                                "generated_by_id": {"type": "string", "description": "ID of the user generating the report (required for create)"},
                                "status": {"type": "string", "description": "Current status (optional)", "enum": ["draft", "completed", "distributed"]}
                            }
                        },
                        "report_id": {"type": "string", "description": "Unique identifier of the report (required for update action only)"}
                    },
                    "required": ["action"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverUsers(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover user entities.
        
        Supported entities:
        - users: User records by user_id, client_id, vendor_id, first_name, last_name, email, role, department, timezone, status
        """
        if entity_type not in ["users"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'users'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get("users", {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "user_id": str(entity_id)})
            else:
                results.append({**entity_data, "user_id": str(entity_id)})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_users",
                "description": "Discover user entities. Entity types: 'users' (user records; filterable by user_id (string), client_id (string), vendor_id (string), first_name (string), last_name (string), email (string), phone (string), role (enum: 'incident_manager', 'technical_support', 'account_manager', 'executive', 'vendor_contact', 'system_administrator', 'client_contact'), department (string), timezone (string), status (enum: 'active', 'inactive', 'on_leave'), created_at (timestamp), updated_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'users'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For users, filters are: user_id (string), client_id (string), vendor_id (string), first_name (string), last_name (string), email (string), phone (string), role (enum: 'incident_manager', 'technical_support', 'account_manager', 'executive', 'vendor_contact', 'system_administrator', 'client_contact'), department (string), timezone (string), status (enum: 'active', 'inactive', 'on_leave'), created_at (timestamp), updated_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverProducts(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover product entities.
        
        Supported entities:
        - products: Product records by product_id, product_name, product_type, version, vendor_support_id, status
        """
        if entity_type not in ["products"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'products'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get("products", {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "product_id": str(entity_id)})
            else:
                results.append({**entity_data, "product_id": str(entity_id)})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_products",
                "description": "Discover product entities. Entity types: 'products' (product records; filterable by product_id (string), product_name (string), product_type (enum: 'payment_processing', 'banking_system', 'api_gateway', 'data_integration', 'reporting_platform', 'security_service', 'backup_service', 'monitoring_tool'), version (string), vendor_support_id (string), status (enum: 'active', 'deprecated', 'maintenance'), created_at (timestamp), updated_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'products'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For products, filters are: product_id (string), product_name (string), product_type (enum: 'payment_processing', 'banking_system', 'api_gateway', 'data_integration', 'reporting_platform', 'security_service', 'backup_service', 'monitoring_tool'), version (string), vendor_support_id (string), status (enum: 'active', 'deprecated', 'maintenance'), created_at (timestamp), updated_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverChangeEntities(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover change and rollback request entities.
        
        Supported entities:
        - change_requests: Change request records
        - rollback_requests: Rollback request records
        """
        if entity_type not in ["change_requests", "rollback_requests"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'change_requests' or 'rollback_requests'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        id_field = "change_id" if entity_type == "change_requests" else "rollback_id"
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, id_field: str(entity_id)})
            else:
                results.append({**entity_data, id_field: str(entity_id)})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_change_entities",
                "description": "Discover change and rollback request entities. Entity types: 'change_requests' (change request records; filterable by change_id (string), change_code (string), incident_id (string), title (string), change_type (enum: 'emergency', 'standard', 'normal'), requested_by_id (string), approved_by_id (string), risk_level (enum: 'high', 'medium', 'low'), scheduled_start (timestamp), scheduled_end (timestamp), actual_start (timestamp), actual_end (timestamp), status (enum: 'requested', 'approved', 'scheduled', 'in_progress', 'completed', 'failed', 'rolled_back'), created_at (timestamp)), 'rollback_requests' (rollback request records; filterable by rollback_id (string), rollback_code (string), change_id (string), incident_id (string), requested_by_id (string), approved_by_id (string), executed_at (timestamp), validation_completed (boolean: True/False), status (enum: 'requested', 'approved', 'in_progress', 'completed', 'failed'), created_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'change_requests' or 'rollback_requests'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For change_requests, filters are: change_id (string), change_code (string), incident_id (string), title (string), change_type (enum: 'emergency', 'standard', 'normal'), requested_by_id (string), approved_by_id (string), risk_level (enum: 'high', 'medium', 'low'), scheduled_start (timestamp), scheduled_end (timestamp), actual_start (timestamp), actual_end (timestamp), status (enum: 'requested', 'approved', 'scheduled', 'in_progress', 'completed', 'failed', 'rolled_back'), created_at (timestamp). For rollback_requests, filters are: rollback_id (string), rollback_code (string), change_id (string), incident_id (string), requested_by_id (string), approved_by_id (string), executed_at (timestamp), validation_completed (boolean: True/False), status (enum: 'requested', 'approved', 'in_progress', 'completed', 'failed'), created_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverClients(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover client entities.
        
        Supported entities:
        - clients: Client records by client_id, client_name, client_type, industry, country, status
        """
        if entity_type not in ["clients"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'clients'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get("clients", {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "client_id": str(entity_id)})
            else:
                results.append({**entity_data, "client_id": str(entity_id)})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_clients",
                "description": "Discover client entities. Entity types: 'clients' (client records; filterable by client_id (string), client_name (string), registration_number (string), contact_email (string), client_type (enum: 'enterprise', 'mid_market', 'small_business', 'startup'), industry (string), country (string), status (enum: 'active', 'inactive', 'suspended'), created_at (timestamp), updated_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'clients'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For clients, filters are: client_id (string), client_name (string), registration_number (string), contact_email (string), client_type (enum: 'enterprise', 'mid_market', 'small_business', 'startup'), industry (string), country (string), status (enum: 'active', 'inactive', 'suspended'), created_at (timestamp), updated_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }


# -----------------

import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverEscalations(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover escalation entities.
        
        Supported entities:
        - escalations: Escalation records
        """
        if entity_type not in ["escalations"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'escalations'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get("escalations", {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "escalation_id": str(entity_id)})
            else:
                results.append({**entity_data, "escalation_id": str(entity_id)})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_escalations",
                "description": "Discover escalation entities. Entity types: 'escalations' (escalation records; filterable by escalation_id (string), escalation_code (string), incident_id (string), escalated_by_id (string), escalated_to_id (string), escalation_reason (enum: 'sla_breach', 'severity_increase', 'resource_unavailable', 'executive_request', 'client_demand'), escalation_level (enum: 'technical', 'management', 'executive', 'vendor'), escalated_at (timestamp), acknowledged_at (timestamp), resolved_at (timestamp), status (enum: 'open', 'acknowledged', 'resolved'), created_at (timestamp)).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'escalations'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters as JSON object with key-value pairs. SYNTAX: {\"key\": \"value\"} for single filter, {\"key1\": \"value1\", \"key2\": \"value2\"} for multiple filters (AND logic). RULES: Exact matches only, dates as YYYY-MM-DD and booleans as True/False. For escalations, filters are: escalation_id (string), escalation_code (string), incident_id (string), escalated_by_id (string), escalated_to_id (string), escalation_reason (enum: 'sla_breach', 'severity_increase', 'resource_unavailable', 'executive_request', 'client_demand'), escalation_level (enum: 'technical', 'management', 'executive', 'vendor'), escalated_at (timestamp), acknowledged_at (timestamp), resolved_at (timestamp), status (enum: 'open', 'acknowledged', 'resolved'), created_at (timestamp)"
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }

# Policy:
# **Incident Management Policy & SOPs**

The current time is 2025-10-04 12:00:00 UTC

## **Introduction**

This document defines the operational guide for an Incident Management automation agent. It is designed for single-turn execution: each procedure must be self-contained and completed in one interaction.

**Validation first**: All inputs must be validated. If any required element is missing or invalid, the process halts with a clear error message.

**Logging**: Every INSERT, UPDATE, or DELETE operation must generate an audit_log entry with entity_type, entity_id, operation_type, changed_by_id, field_name, old_value, and new_value. .

**Role-based permissions**: Only designated roles may perform an action; other roles may do so only with explicit approval from a role authorized to perform it.

### **What is "Halt"?**

When a process halts, the agent immediately stops execution of the current SOP and returns a message to the user that says "cannot continue the process" \- therefore no further steps within that SOP are performed. The agent will use the **transfer_to_human** tool to transfer the request to a human agent.

## **Standard Operating Procedures**

### **Entities Lookup / Discovery**

Use this whenever you need to find, search, or verify entities; fetch details for validation or reporting; or when another SOP needs entity information first.

1. **Obtain:**  
* **Required**: entity_type  
* **Optional**: Include any filters for that entity (e.g., ID, status, dates) used to narrow the search.  
2. **Pick one discovery tool that matches the entity type:**  
* For clients, call **discover_clients** (filter by client_id, client_name, client_type, industry, country, status)  
* For **vendors**, call **discover_vendors** (filter by vendor_id, vendor_name, vendor_type, status)  
* For **users**, call **discover_users**  (filter by user_id, email, role, client_id, vendor_id, status)  
* For **products**, call **discover_products**  (filter by product_id, product_name, product_type, version, vendor_support_id, status)  
* For **infrastructure components**, call **discover_components** (filter by component_id, product_id, component_name, component_type, environment, location, port_number, status)  
* For **client subscriptions,** **sla agreements** call **discover_subscription_agreements** (filter by subscription_id, client_id, product_id, subscription_type, start_date, end_date, sla_tier, rto_hours, status, sla_id, subscription_id, severity_level, response_time_minutes, resolution_time_hours, availability_percentage).  
* For **incidents, post incident reviews** call **discover_incident_entities** (filter by incident_id, incident_code, client_id, component_id, reporter_id, assigned_manager_id, severity, status, category, detection_source, detected_at, impact, urgency).  
* For **workarounds**, call **discover_workaround_entities** (filter by workaround_id, incident_id, implemented_by_id, effectiveness, status, implemented_at)  
* For **root cause analysis**, call **discover_rca_entities** (filter by rca_id, incident_id, analysis_method, conducted_by_id, completed_at, status)  
* For **escalations**, call **discover_escalation_entities** (filter by escalation_id, escalation_code, incident_id, escalated_by_id, escalated_to_id, escalation_reason, escalation_level, escalated_at, acknowledged_at, resolved_at, status)  
* For **change requests, rollback requests**, call **discover_change_entities** (filter by change_id, change_code, rollback_id, incident_id, requested_by_id, approved_by_id, change_type, status)  
* For **metrics**, call **discover_metrics_entities** (filter by metric_id, incident_id, metric_type, value_minutes, target_minutes, recorded_at)  
* For **incident reports**, call **discover_incident_entities** (filter by report_id, incident_id, report_type, generated_by_id, generated_at, status)  
* For communications, call **discover_communication_entities** (filter by communication_id, incident_id, sender_id, recipient_id, recipient_type, communication_type, sent_at, delivery_status, pir_id, incident_id, facilitator_id, scheduled_date, timeline_accuracy_rating, communication_effectiveness_rating, technical_response_rating)  
* For **knowledge base articles**, call **discover_kb_article_entities** (filter by article_id, incident_id, created_by_id, reviewed_by_id, article_type, category, view_count, status)  
3. **Run the selected discovery tool and wait for the results.**  
4. **Acquire the result** \- whether it is a single match, multiple matches, or none.

**Halt, and use transfer_to_human if any of these occur:**

* The entity_type is missing or invalid  
* The requester is not authorized  
* The discovery tool fails to execute

---

## **Client Management Operations**

### **Create Client Record**

1. **Obtain:**  
* **Required**: client_name, client_type (enterprise, mid_market, small_business, startup), country  
* **Optional**: registration_number, contact_email, industry, status (active, inactive, suspended)  
* **Validate** that client_name and registration_number (if provided) are unique using **discover_clients**.  
2. **Create** the client record using **manage_clients**.  
3. **Create** an audit entry for client creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Client name or registration number already exists  
* Invalid client_type or country  
* Client creation failed  
* Audit trail logging failure

---

### **Update Client Information**

**1.   Obtain:**

* **Required**: client_id  
* **Optional**: client_name, registration_number, contact_email, client_type (enterprise, mid_market, small_business, startup), industry, country, status (active, inactive, suspended) (at least one must be provided)  
* **Validate** that client exists and is accessible to the user using **discover_clients**.

2**. Verify** that the approval to conduct the action is present using **check_approval**    (system_administrator or incident_manager or account_manager approval required). 

**3. If updating** client_name or registration_number, validate uniqueness using **discover_clients**.

**4. Update** the client record using **manage_clients**.

**5. Create** an audit entry for client update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Client not found  
* User not authorized for client updates  
* New client_name or registration_number already exists  
* Invalid client_type or status  
* Client update failed  
* Audit trail logging failure

---

**User Management Operations**

### **Create User Account**

1. **Obtain:**  
* **Required**: first_name, last_name, email, role (incident_manager, technical_support, account_manager, executive, vendor_contact, system_administrator, client_contact), timezone  
* **Optional**: phone, department, client_id, vendor_id, status (active, inactive, on_leave)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager approval required).  
3. **Validate** that email is unique using **discover_users**.  
4. **If client_id provided**, validate that client exists and has active status using **discover_clients**.  
5. **If vendor_id provided**, validate that vendor exists and has active status using **discover_vendors**.  
6. **Create** the user account using **manage_users**.  
7. **Create** an audit entry for user creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Email already exists  
* Client or vendor not found or inactive  
* Invalid role or timezone  
* Approval missing for elevated role creation  
* User creation failed  
* Audit trail logging failure

---

### **Update User Information**

1. **Obtain:**  
* **Required**: user_id  
* **Optional**: first_name, last_name, email, phone, role (incident_manager, technical_support, account_manager, executive, vendor_contact, system_administrator, client_contact), department, client_id, vendor_id, timezone, status (active, inactive, on_leave) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager approval required).  
3. **Validate** that user exists using **discover_users**.  
4. **If updating email**, validate uniqueness using **discover_users**.  
5. **Update** the user record using **manage_users**.  
6. **Create** an audit entry for user update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing approval for updating user information  
* User not found  
* New email already exists  
* Invalid role or status  
* Approval missing for role elevation  
* User update failed  
* Audit trail logging failure

---

## **Vendor Management Operations**

### **Create Vendor Record**

1. **Obtain:**  
* **Required**: vendor_name, vendor_type (cloud_provider, payment_processor, software_vendor, infrastructure_provider, security_vendor)  
* **Optional**: contact_email,,contact_phone, status (active, inactive, suspended).  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager or executive approval required)  
3. **Validate** that vendor_name is unique using **discover_vendors**.  
4. **Create** the vendor record using **manage_vendors**.  
5. **Create** an audit entry for vendor creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for vendor creation  
* Missing or invalid inputs  
* Vendor name already exists  
* Invalid vendor_type  
* Vendor creation failed  
* Audit trail logging failure

---

### **Update Vendor Information**

1. **Obtain:**  
* **Required**: vendor_id  
* **Optional**: vendor_name, vendor_type (cloud_provider, payment_processor, software_vendor, infrastructure_provider, security_vendor), contact_email, contact_phone, status (active, inactive, suspended) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager or executive approval required).  
3. **Validate** that vendor exists using **discover_vendors**.  
4. **If updating vendor_name**, validate uniqueness using **discover_vendors**.  
5. **Update** the vendor record using **manage_vendors**.  
6. **Create** an audit entry for vendor update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for vendor update  
* Vendor not found  
* New vendor_name already exists  
* Invalid vendor_type or status  
* Vendor update failed  
* Audit trail logging failure

---

## **Product and Infrastructure Operations**

### **Create Product Record**

1. **Obtain:**  
* **Required**: product_name, product_type (payment_processing, banking_system, api_gateway, data_integration, reporting_platform, security_service, backup_service, monitoring_tool)  
* **Optional**: version, vendor_support_id, status (active, deprecated, maintenance)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager or executive approval required)  
3. **Validate** that product_name is unique using **discover_products**.  
4. **If vendor_support_id provided**, validate that vendor exists and has active status using **discover_vendors**.  
5. **Create** the product record using **manage_products**.  
6. **Create** an audit entry for product creation using **log_audit_records**

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Product name already exists  
* Vendor not found or inactive  
* Invalid product_type  
* Product creation failed  
* Audit trail logging failure

## **Update Product Record**

1. **Obtain:**  
* **Required**: product_id  
* **Optional**: product_name, product_type (payment_processing, banking_system, api_gateway, data_integration, reporting_platform, security_service, backup_service, monitoring_tool), version, vendor_support_id, status (active, deprecated, maintenance) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or incident_manager or executive approval required).  
3. **Validate** that product exists using **discover_products**.  
4. **If updating product_name**, validate uniqueness using **discover_products**.  
5. **If updating vendor_support_id**, validate that vendor exists and has active status using **discover_vendors**.  
6. **Update** the product record using **manage_products**.  
7. **Create** an audit entry for product update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for product update  
* Product not found  
* New product_name already exists  
* Vendor not found or inactive (if updating vendor_support_id)  
* Invalid product_type or status  
* Product update failed  
* Audit trail logging failure

---

## **Create Infrastructure Component**

1. **Obtain:**  
* **Required**: component_name, component_type (sftp_server, api_endpoint, database, load_balancer, firewall, authentication_service, payment_gateway, file_storage, monitoring_system), environment (production, staging, development, test)  
* **Optional**: product_id, location, port_number, status (online, offline, maintenance, degraded)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or technical_support or incident_manager approval required).  
3. **Validate** that component_name is unique within the specified product using **discover_components**.  
4. **If product_id provided**, validate that product exists and has active status using **discover_products**.  
5. **Create** the infrastructure component using **manage_components**.  
6. **Create** an audit entry for component creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for component creation  
* Missing or invalid inputs  
* Product not found or inactive (if product_id specified)  
* Component name already exists within product  
* Invalid component_type, environment, or status  
* Component creation failed  
* Audit trail logging failure

## **Update Infrastructure Component**

1. **Obtain:**  
* **Required**: component_id  
* **Optional**: component_name, component_type (sftp_server, api_endpoint, database, load_balancer, firewall, authentication_service, payment_gateway, file_storage, monitoring_system), product_id, environment (production, staging, development, test), location, port_number, status (online, offline, maintenance, degraded) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or technical_support or incident_manager approval required).  
3. **Validate** that component exists using **discover_components**.  
4. **If updating component_name**, validate uniqueness within the specified product using **discover_components**.  
5. **If updating product_id**, validate that product exists and has active status using **discover_products**.  
6. **Update** the infrastructure component using **manage_components**.  
7. **Create** an audit entry for component update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for component update  
* Component not found  
* Product not found or inactive (if updating product_id)  
* New component_name already exists within product  
* Invalid component_type, environment, or status  
* Component update failed  
* Audit trail logging failure

---

## **Subscription and Service Level Management**

### **Create Client Subscription**

1. **Obtain:**  
* **Required**: client_id, product_id, subscription_type (full_service, limited_service, trial, custom), start_date, sla_tier (premium, standard, basic), rto_hours  
* **Optional**: end_date, status (active, expired, cancelled, suspended)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (account_manager or incident_manager or executive approval required).  
3. **Validate** that client exists and has active status using **discover_clients**.  
4. **Validate** that product exists and has active status using **discover_products**.  
5. **Create** the subscription record using **manage_client_subscriptions**.  
6. **Create** an audit entry for subscription creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for subscription creation  
* Missing or invalid inputs  
* Client not found or inactive  
* Product not found or inactive  
* Invalid subscription_type, sla_tier, or rto_hours  
* Subscription creation failed  
* Audit trail logging failure

---

### **Update Client Subscription**

1. **Obtain:**  
* **Required**: subscription_id  
* **Optional**: subscription_type (full_service, limited_service, trial, custom), start_date, end_date, sla_tier (premium, standard, basic), rto_hours, status (active, expired, cancelled, suspended) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (account_manager or incident_manager or executive approval required).  
3. **Validate** that subscription exists using **discover_subscription_agreements**.  
4. **Update** the subscription record using **manage_client_subscriptions**.  
5. **Create** an audit entry for subscription update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for subscription update  
* Subscription not found  
* Invalid subscription_type, sla_tier, status, or dates  
* Subscription update failed  
* Audit trail logging failure

---

### **Create SLA Agreement**

1. **Obtain:**  
* **Required**: subscription_id, severity_level (P1, P2, P3, P4), response_time_minutes, resolution_time_hours  
* **Optional**: availability_percentage  
2. **Verify** that the approval to conduct the action is present using **check_approval** (account_manager or system_administrator or executive approval required).  
3. **Validate** that subscription exists and has active status using **discover_subscription_agreements**.  
4. **Validate** that response and resolution times align with subscription tier using the following guidelines:  
* **Premium tier**: P1: 15-30 min response, 2-4 hrs resolution; P2: 1-2 hrs response, 8-24 hrs resolution; P3: 4-8 hrs response, 48-72 hrs resolution; P4: 24-48 hrs response, 128 hrs resolution  
* **Standard tier**: P1: 1-2 hrs response, 8-24 hrs resolution; P2: 4-8 hrs response, 24-48 hrs resolution; P3: 24 hrs response, 72-120 hrs resolution; P4: 48-72 hrs response, 168 hrs resolution  
* **Basic tier**: P1: 4-8 hrs response, 24-48 hrs resolution; P2: 24 hrs response, 72-120 hrs resolution; P3: 48-72 hrs response, 5-10 days resolution; P4: 5-7 days response, 2 weeks resolution  
5. **Create** the SLA agreement using **manage_sla_agreements**.  
6. **Create** an audit entry for SLA creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for SLA creation  
* Missing or invalid inputs  
* Subscription not found or inactive  
* Response/resolution times don't align with subscription tier  
* Invalid severity_level or availability_percentage  
* SLA creation failed  
* Audit trail logging failure

### **Update SLA Agreement**

1. **Obtain:**  
* **Required**: sla_id  
* **Optional**: severity_level (P1, P2, P3, P4), response_time_minutes, resolution_time_hours, availability_percentage (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (account_manager or system_administrator or executive approval required).  
3. **Validate** that SLA agreement exists using **discover_subscription_agreements**.  
4. **Retrieve** the associated subscription to determine subscription tier.  
5. **If updating response_time_minutes or resolution_time_hours**, validate that new times align with subscription tier using the following guidelines:  
* **Premium tier**: P1: 15-30 min response, 2-4 hrs resolution; P2: 1-2 hrs response, 8-24 hrs resolution; P3: 4-8 hrs response, 48-72 hrs resolution; P4: 24-48 hrs response, 128 hrs resolution  
* **Standard tier**: P1: 1-2 hrs response, 8-24 hrs resolution; P2: 4-8 hrs response, 24-48 hrs resolution; P3: 24 hrs response, 72-120 hrs resolution; P4: 48-72 hrs response, 168 hrs resolution  
* **Basic tier**: P1: 4-8 hrs response, 24-48 hrs resolution; P2: 24 hrs response, 72-120 hrs resolution; P3: 48-72 hrs response, 5-10 days resolution; P4: 5-7 days response, 2 weeks resolution  
6. **Update** the SLA agreement using **manage_sla_agreements**.  
7. **Create** an audit entry for SLA update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for SLA update  
* SLA agreement not found  
* Response/resolution times don't align with subscription tier  
* Invalid severity_level or availability_percentage  
* SLA update failed  
* Audit trail logging failure

---

## **Incident Operations**

### **Create Incident**

1. **Obtain:**  
* **Required**: title, reporter_id, client_id, category (system_outage, performance_degradation, security_incident, data_corruption, integration_failure, network_issue, hardware_failure, software_bug, configuration_error, capacity_issue, backup_failure, authentication_failure, api_error, database_issue, service_unavailable) , impact (critical, high, medium, low), detection_source(client_reported,internally_detected, monitoring_alert,vendor_reported,scheduled_maintenance,emergency_maintanence), urgency (critical, high, medium, low), detected_at  
* Optional: assigned_manager_id, component_id, severity(P1,P2,P3,P4), status(open,in_progress,resolved,closed) , is_recurring,downtime_minutes,sla_breach,rto_breach,closed_at,resolved_at  
2. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or technical_support or system_administrator or executive approval required).  
3. **Validate** that reporter exists and has active status using **discover_users**.  
4. **Validate** that client exists and has active status using **discover_clients**.  
5. **If component_id provided**, validate that component exists using **discover_products**.  
6. **If assigned_manager_id provided**, validate that user exists using **discover_users**.  
7. **Create** the incident record using **manage_incidents.**  
8. **Create** an audit entry for incident creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for creating an incident  
* Missing or invalid inputs  
* Reporter not found or inactive  
* Client not found or inactive  
* Component not found  
* Assigned manager not found  
* Invalid category, impact, urgency, or severity  
* Incident creation failed  
* Audit trail logging failure

---

### **Update Incident**

1. **Obtain:**  
* **Required**: incident_id  
2. **Optional**: title,incident_code, assigned_manager_id, component_id, severity (P1, P2, P3, P4), status (open, in_progress, resolved, closed), impact (critical, high, medium, low), urgency (critical, high, medium, low), category (system_outage, performance_degradation, security_incident, data_corruption, integration_failure, network_issue, hardware_failure, software_bug, configuration_error, capacity_issue, backup_failure, authentication_failure, api_error, database_issue, service_unavailable), detection_source (client_reported, internally_detected, monitoring_alert, vendor_reported, scheduled_maintenance, emergency_maintenance), resolved_at, closed_at, rto_breach, sla_breach, is_recurring, downtime_minutes (at least one must be provided)  
3. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or technical_support or system_administrator or executive approval required)  
4. **Validate** that incident exists using **discover_incident_entities**.  
5. **If updating assigned_manager_id**, validate that user exists using **discover_users**.  
6. **Update** the incident record using **manage_incidents**.  
7. **Create** an audit entry for incident update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing to update incident  
* Incident not found  
* Assigned manager not found or has invalid role  
* Invalid severity, impact, urgency, category, or timestamps  
* Incident update failed  
* Audit trail logging failure

---

### **Resolve Incident**

1. **Obtain:**  
* **Required**: incident_id  
2. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or technical_support or executive approval required)  
3. **Validate** that incident exists and has status of in_progress or open using **discover_incident_entities**.  
4. **Update** incident status to resolved and set resolved_at timestamp using **manage_incidents**.  
5. **Create** an audit entry for incident resolution using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing approval to resolve incident  
* Incident not found or invalid status  
* Report generation failed  
* Incident resolution update failed  
* Audit trail logging failure

---

### **Close Incident**

1. **Obtain:**  
* **Required**: incident_id  
2. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or executive approval required).  
3. **Validate** that incident exists and has status of resolved using **discover_incident_entities**.  
4. **Update** incident status to closed and set closed_at timestamp using **manage_incidents**.  
5. **Create** an audit entry for incident closure using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing to close incident  
* Incident not found or status not resolved  
* Incident closure failed  
* Audit trail logging failure

---

## **Communication Management**

### **Create Communication**

1. **Obtain:**  
* **Required**: incident_id, sender_id, recipient_id, recipient_type (client, internal_team, executive, vendor, regulatory), communication_type (email, sms, phone_call, status_page, portal_update)  
* **Optional**: delivery_status (sent, delivered, failed, pending), sent_at  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( incident_manager or technical_support or system_administrator or account_manager approval required).  
3. **Validate** that incident exists using **discover_incident_entities**.  
4. **Validate** that sender and recipient exists and has active status using **discover_users**.  
5. **Create** the communication record using **manage_communications**.  
6. **Create** an audit entry for communication using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing approval  for creating communication record  
* Missing or invalid inputs  
* Incident not found  
* Sender not found or inactive  
* Recipient not found (if specified)  
* Invalid recipient_type or communication_type  
* Communication recording failed  
* Audit trail logging failure

## **Update Communication**

1. **Obtain:**  
* **Required**: communication_id  
* **Optional**: incident_id, sender_id, recipient_id, recipient_type (client, internal_team, executive, vendor, regulatory), communication_type (email, sms, phone_call, status_page, portal_update), delivery_status (sent, delivered, failed, pending), sent_at (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( incident_manager or technical_support or system_administrator or account_manager approval required).  
3. **Validate** that communication record exists using **discover_communication_entities**.  
4. If updating incident_id, sender_id, or recipient_id, validate that the communication record has delivery_status of "pending" using **discover_communication_entities**. These fields can only be updated when delivery_status is "pending".  
5. **If updating incident_id**, validate that incident exists using **discover_incident_entities**.  
6. **If updating sender_id**, validate that sender exists and has active status using **discover_users**.  
7. **If updating recipient_id**, validate that recipient exists using **discover_users**.  
8. **Update** the communication record using **manage_communications**.  
9. **Create** an audit entry for communication update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing to update communication record  
* Communication record not found  
* Incident not found (if updating incident_id)  
* Sender not found or inactive (if updating sender_id)  
* Recipient not found (if updating recipient_id)  
* Invalid recipient_type, communication_type, or delivery_status  
* Communication update failed  
* Audit trail logging failure

---

## **Workaround and Resolution Management**

### **Create Workaround**

1. **Obtain:**  
* **Required**: incident_id, implemented_by_id, effectiveness (complete, partial, minimal),implemented_at  
* **Optional**: status (active, inactive, replaced)   
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that incident exists and has status of open or in_progress using **discover_incident_entities**.  
4. **Create** the workaround record using **manage_work_arounds**.  
5. **Create** an audit entry for workaround implementation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Incident not found or invalid status  
* Implementing user not found or has invalid role  
* Invalid effectiveness level  
* Workaround creation failed  
* Audit trail logging failure

---

## **Update Workaround**

1. **Obtain:**  
* **Required**: workaround_id  
* **Optional**: effectiveness (complete, partial, minimal), status (active, inactive, replaced) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that workaround record exists using **discover_workaround_entities**.  
4. **Update** the workaround record using **manage_work_arounds**.  
5. **Create** an audit entry for workaround update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for workaround update  
* Workaround not found  
* Invalid effectiveness level or status  
* Workaround update failed  
* Audit trail logging failure

---

### **Conduct Root Cause Analysis**

1. **Obtain:**  
* **Required**: incident_id, conducted_by_id, analysis_method (five_whys, fishbone, timeline_analysis, fault_tree)  
* **Optional**: completed_at, status (in_progress, completed, approved)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that incident exists and has status of resolved or closed using **discover_incident_entities**.  
4. **Create** the root cause analysis record using **manage_root_cause_analysis**.  
5. **Create** an audit entry for RCA initiation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for conduct root cause analysis  
* Missing or invalid inputs  
* Incident not found or invalid status  
* Invalid analysis_method  
* RCA creation failed  
* Audit trail logging failure

---

### **Update Root Cause Analysis**

1. **Obtain:**  
* **Required**: rca_id  
* **Optional**: analysis_method (five_whys, fishbone, timeline_analysis, fault_tree), completed_at, status (in_progress, completed, approved) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that RCA record exists using **discover_rca_entities**.  
4. **Update** the RCA record using **manage_root_cause_analysis**.  
5. **Create** an audit entry for RCA update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for updating rca  
* RCA not found  
* Invalid analysis_method or status  
* RCA update failed  
* Audit trail logging failure

---

## **Escalation Management**

### **Create Escalation**

1. **Obtain:**  
* **Required**: incident_id, escalated_by_id, escalated_to_id, escalation_reason (sla_breach, severity_increase, resource_unavailable, executive_request, client_demand), escalated_at ,escalation_level (technical, management, executive, vendor)  
* **Optional**: acknowledged_at, resolved_at, status (open, acknowledged, resolved)  
2. **Validate** that incident exists and has status of open or in_progress using **discover_incident_entities**.  
3. **Validate** that escalated_by and escalated_to  user exists and has active status using **discover_users**.  
4. **Create** the escalation record using **manage_escalations**.  
5. **Create** an audit entry for escalation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Incident not found or invalid status  
* Escalating user not found or inactive  
* Escalation target user not found or has invalid role for level  
* Invalid escalation_reason or escalation_level  
* Escalation creation failed  
* Audit trail logging failure

---

### **Update Escalation Status**

1. **Obtain:**  
* **Required**: escalation_id  
* **Optional**: escalation_code, acknowledged_at, resolved_at, status (open, acknowledged, resolved) (at least one must be provided)  
2. **Validate** that escalation exists using **discover_escalation_entities**.  
3. **Update** the escalation record using **manage_escalations**.  
4. **Create** an audit entry for escalation update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Escalation not found  
* User not authorized to update escalation  
* Invalid status or timestamps  
* Escalation update failed  
* Audit trail logging failure

---

## **Change Management Operations**

### **Create Change Request**

1. **Obtain:**  
* **Required**: title, change_type (emergency, standard, normal), requested_by_id, risk_level (high, medium, low)  
* **Optional**: incident_id, approved_by_id, scheduled_start, scheduled_end, actual_start, actual_end, status (requested, approved, scheduled, in_progress, completed, failed, rolled_back)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required)..  
3. **If incident_id provided**, validate that incident exists using **discover_incident_entities**  
4. **Create** the change request record using **manage_change_requests**.  
5. **Create** an audit entry for change request using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing Approval for creating a change request  
* Missing or invalid inputs  
* Incident not found (if specified)  
* Invalid change_type, risk_level, or status  
* Change request creation failed  
* Audit trail logging failure

---

### **Update Change Request**

1. **Obtain:**  
* **Required**: change_id  
* **Optional**: title,change_code, change_type (emergency, standard, normal), approved_by_id, risk_level (high, medium, low), scheduled_start, scheduled_end, actual_start, actual_end, status (requested, approved, scheduled, in_progress, completed, failed, rolled_back) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager or system_administrator or executive approval required).  
3. **Validate** that change request exists using **discover_change_entities**.  
4. **Update** the change request using **manage_change_requests**.  
5. **Create** an audit entry for change update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for update change request  
* Change request not found  
* User not authorized  
* Invalid change_type, risk_level, status, or timestamps  
* Change request update failed  
* Audit trail logging failure

---

### **Create Rollback Request**

1. **Obtain:**  
* **Required**: change_id, requested_by_id  
* **Optional**: incident_id, approved_by_id, executed_at, validation_completed, status (requested, approved, in_progress, completed, failed).  
2. **Verify** that the approval to conduct the action is present using **check_approval** (system_administrator or executive approval required)  
3. **Validate** that change request exists using **discover_change_entities**.  
4. **If incident_id provided**, validate that incident exists using **discover_incident_entities**.  
5. **Create** the rollback request using **manage_rollback_requests**.  
6. **Create** an audit entry for rollback request using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for rollback request  
* Missing or invalid inputs  
* Change request not found  
* Requesting user not found or has invalid role  
* Incident not found (if specified)  
* Rollback request creation failed  
* Audit trail logging failure

---

### **Update Rollback Request**

1. **Obtain:**  
* **Required**: rollback_id  
* **Optional**: rollback_code , approved_by_id, executed_at, validation_completed, status (requested, approved, in_progress, completed, failed) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** (  incident_manager or system_administrator or executive approval required).  
3. **Validate** that rollback request exists using **discover_change_entities**.  
4. **Update** the rollback request using **manage_rollback_requests**.  
5. **Create** an audit entry for rollback update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing Approval for rollback request  
* Rollback request not found  
* User not authorized  
* Invalid status or timestamps  
* Rollback update failed  
* Audit trail logging failure

---

## **Metrics and Reporting Operations**

### **Record Performance Metrics**

1. **Obtain:**  
* **Required**: incident_id, metric_type (MTTA, MTTD, MTTR, MTTM, FTR), value_minutes  
* **Optional**: target_minutes, recorded_at  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( incident_manager or system_administrator approval required).  
3. **Validate** that incident exists and has status of resolved or closed using **discover_incident_entities**.  
4. **Create** the metrics record using **manage_metrics**.  
5. **Create** an audit entry for metrics recording using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Incident not found or invalid status  
* User not authorized  
* Invalid metric_type or value_minutes  
* Metrics recording failed  
* Audit trail logging failure

---

### **Generate Incident Report**

1. **Obtain:**  
* **Required**: incident_id, report_type ( executive_summary, technical_details,business_impact, compliance_report, post_mortem), generated_by_id  
* **Optional**: status (draft, completed, distributed)  
2. **Validate** that generating user exists and has appropriate role (incident_manager, executive) using **discover_users**..  
3. **Generate** the report using **manage_incident_reports**.  
4. **Create** an audit entry for report generation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing approval for generating report  
* Missing or invalid inputs  
* Invalid report_type or status  
* Incident not resolved/closed for post_mortem  
* Report generation failed  
* Audit trail logging failure

---

## **Knowledge Management Operations**

### **Create Knowledge Base Article**

1. **Obtain:**  
* **Required**: title, article_type (troubleshooting, resolution_steps, prevention_guide, faq), created_by_id, category(authentication_issues, payment_processing, api_integration, data_synchronization, system_outages, performance_degradation, security_incidents, backup_recovery, user_management, billing_issues, compliance_procedures, vendor_escalations, configuration_changes, monitoring_alerts, network_connectivity, database_issues, file_transfer_problems, reporting_errors, mobile_app_issues, browser_compatibility, third_party_integrations, scheduled_maintenance, emergency_procedures, client_onboarding, account_provisioning, sla_management, incident_response, change_management, capacity_planning, disaster_recovery)  
* **Optional**: incident_id, reviewed_by_id, view_count, status (draft, published, archived)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager approval required).  
3. **If incident_id provided**, validate that incident exists and is resolved or closed using **discover_incident_entities**.  
4. **If reviewed_by_id provided**, validate that reviewer exists and has appropriate role using **discover_users**.  
5. **Create** the knowledge base article using **manage_kb_articles**.  
6. **Create** an audit entry for article creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Missing or invalid inputs  
* Creating user not found or has invalid role  
* Incident not found or invalid status (if specified)  
* Reviewer not found (if specified)  
* Invalid article_type, category, or status  
* Knowledge article creation failed  
* Audit trail logging failure

---

### **Update Knowledge Base Article**

1. **Obtain:**  
* **Required**: article_id  
* **Optional**: title, article_type (troubleshooting, resolution_steps, prevention_guide, faq), incident_id, reviewed_by_id, category, view_count, status (draft, published, archived) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( technical_support or incident_manager approval required).  
3. **Validate** that article exists using **discover_kb_article_entities**.  
4. **If updating reviewed_by_id**, validate that reviewer exists using **discover_users**.  
5. **Update** the knowledge article using **manage_kb_articles**.  
6. **Create** an audit entry for article update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Article not found  
* User not authorized  
* Reviewer not found (if specified)  
* Invalid article_type, category, or status  
* Article update failed  
* Audit trail logging failure

---

### **Create Post-Incident Review**

1. **Obtain:**  
* **Required**: incident_id, scheduled_date, facilitator_id  
* **Optional**: timeline_accuracy_rating, communication_effectiveness_rating, technical_response_rating, status (scheduled, completed, cancelled)   
2. **Verify** that the approval to conduct the action is present using **check_approval** (incident_manager or executive approval required).  
3. **Validate** that incident exists and has status of resolved or closed using **discover_incident_entities**.  
4. **Validate** that facilitator exists and has an appropriate role (incident_manager, executive) using **discover_users**.  
5. **Create** the post-incident review record using **manage_post_incident_reviews**.  
6. **Create** an audit entry for PIR creation using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing for PIR creation  
* Missing or invalid inputs  
* Incident not found or invalid status  
* Facilitator not found or has invalid role  
* Invalid scheduled_date or ratings  
* PIR creation failed  
* Audit trail logging failure

---

### **Update Post-Incident Review**

1. **Obtain:**  
* **Required**: pir_id  
* **Optional**: scheduled_date, facilitator_id, timeline_accuracy_rating, communication_effectiveness_rating, technical_response_rating, status (scheduled, completed, cancelled) (at least one must be provided)  
2. **Verify** that the approval to conduct the action is present using **check_approval** ( incident_manager or executive approval required).  
3. **Validate** that PIR exists using **discover_incident_entities**..  
4. **Update** the post-incident review using **manage_post_incident_review**.  
5. **Create** an audit entry for PIR update using **log_audit_records**.

**Halt, and use transfer_to_human if you receive the following errors; otherwise complete the SOP:**

* Approval missing  
* PIR not found  
* User not authorized  
* Invalid scheduled_date, ratings, or status  
* PIR update failed  
* Audit trail logging failure

---

## **Authority and Access Controls**

**Permission Validation**

All operations verify user authority based on:

* **role** field (incident_manager, technical_support, account_manager, executive, vendor_contact, system_administrator, client_contact)  
* **client_id** association through client_id field in users table  
* **vendor_id** association through vendor_id field in users table  
* **status** field must be active in users table

Operations requiring elevated permissions use a check_approval tool to verify proper authorization before proceeding.

# Database Schema:
// Use DBML to define your database structure
// Docs: https://dbml.dbdiagram.io/docs

// B2B Incident Management Database Schema
// This schema represents a comprehensive database for managing incidents,
// clients, products, infrastructure, and operational processes

Table clients {
  client_id string [primary key]
  client_name varchar(100) [not null]
  registration_number varchar(100)
  contact_email string
  client_type enum('enterprise','mid_market','small_business','startup') [not null]
  industry varchar(100)
  country varchar(100)
  status enum('active','inactive','suspended') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table vendors {
  vendor_id string [primary key]
  vendor_name varchar(100) [not null]
  vendor_type enum('cloud_provider','payment_processor','software_vendor','infrastructure_provider','security_vendor') [not null]
  contact_email varchar(100)
  contact_phone varchar(20)
  // escalation_contact varchar(100)
  status enum('active','inactive','suspended') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table users {
  user_id string [primary key]
  client_id string
  vendor_id string
  first_name varchar(100) [not null]
  last_name varchar(100) [not null]
  email varchar(320) [not null, unique]
  phone varchar(20)
  role enum('incident_manager','technical_support', 'account_manager','executive','vendor_contact','system_administrator', 'client_contact') [not null]
  department varchar(100)
  timezone varchar(50) [not null]
  status enum('active','inactive','on_leave') [not null, default: 'active']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table products {
  product_id string [primary key]
  product_name varchar(100) [not null]
  product_type enum('payment_processing','banking_system','api_gateway','data_integration','reporting_platform','security_service','backup_service','monitoring_tool') [not null]
  version varchar(50)
  vendor_support_id string // references vendors.vendor_id
  // internal_team_lead_id string // references users.user_id
  status enum('active','deprecated','maintenance') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table infrastructure_components {
  component_id string [primary key]
  product_id string
  component_name varchar(100) [not null]
  component_type enum('sftp_server','api_endpoint','database','load_balancer','firewall','authentication_service','payment_gateway','file_storage','monitoring_system') [not null]
  environment enum('production','staging','development','test') [not null]
  location varchar(100)
  port_number int
  status enum('online','offline','maintenance','degraded') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table client_subscriptions {
  subscription_id string [primary key]
  client_id string [not null]
  product_id string [not null]
  subscription_type enum('full_service','limited_service','trial','custom') [not null]
  start_date date [not null]
  end_date date
  sla_tier enum('premium','standard','basic') [not null]
  rto_hours int [not null] // Recovery Time Objective
  status enum('active','expired','cancelled','suspended') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table sla_agreements {
  sla_id string [primary key]
  subscription_id string [not null]
  severity_level enum('P1','P2','P3','P4') [not null]
  response_time_minutes int [not null]
  resolution_time_hours int [not null]
  availability_percentage decimal(5,2)
  created_at timestamp [not null, default: `NOW()`]
}

Table incidents {
  incident_id string [primary key]
  incident_code varchar(50) [unique, not null] // e.g., 'INC-2024-00123', 'INCIDENT-001234'
  title varchar(100) [not null]
  reporter_id string [not null]
  assigned_manager_id string
  client_id string [not null]
  component_id string
  // vendor_id string // For vendor-related incidents
  // vendor_ticket_id varchar(100) // Vendor's ticket reference
  // vendor_status varchar(100) // Status from vendor side
  // vendor_estimated_resolution timestamp // Vendor's ETA
  severity enum('P1','P2','P3','P4') [not null]
  status enum('open','in_progress','resolved','closed') [not null]
  impact enum('critical','high','medium','low') [not null]
  urgency enum('critical','high','medium','low') [not null]
  // category enum('client_onboarding','client_support','client_escalation','data_update','system_outage','security_breach','performance_issue','integration_failure','vendor_issue') [not null]
  
  // Technical categories - WHAT went wrong
  category enum(
    'system_outage',
    'performance_degradation',
    'security_incident',
    'data_corruption',
    'integration_failure',
    'network_issue',
    'hardware_failure',
    'software_bug',
    'configuration_error',
    'capacity_issue',
    'backup_failure',
    'authentication_failure',
    'api_error',
    'database_issue',
    'service_unavailable'
  ) [not null]
  
  // Business/operational context - WHO is affected and WHY it matters
  detection_source enum(
    'client_reported',
    'internally_detected',
    'monitoring_alert',
    'vendor_reported',
    'scheduled_maintenance',
    'emergency_maintenance'
  ) [not null]
  
  detected_at timestamp [not null]
  resolved_at timestamp
  closed_at timestamp
  rto_breach boolean [default: false]
  sla_breach boolean [default: false]
  is_recurring boolean [default: false]
  downtime_minutes int
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

// Table incident_updates {
//   update_id string [primary key]
//   incident_id string [not null]
//   updated_by_id string [not null]
//   update_type enum('status_change','severity_change','assignment','workaround','resolution','communication') [not null]
//   field_name varchar(50) [not null]
//   old_value varchar(100)
//   new_value varchar(100)
//   created_at timestamp [not null, default: `NOW()`]
// }

Table audit_log {
  audit_id string [primary key]
  entity_type varchar(100) [not null] // Which table was modified (e.g., 'incidents', 'clients', 'users')
  entity_id string [not null] // ID of the record that changed
  operation_type enum('INSERT','UPDATE','DELETE') [not null]
  changed_by_id string [not null] // User who made the change
  field_name varchar(100) // Specific field that changed (can be null for multi-field updates)
  old_value text // Previous value
  new_value text // New value
  created_at timestamp [not null, default: `NOW()`]
}

Table workarounds {
  workaround_id string [primary key]
  incident_id string [not null]
  implemented_by_id string [not null]
  effectiveness enum('complete','partial','minimal') [not null]
  status enum('active','inactive','replaced') [not null]
  implemented_at timestamp [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table root_cause_analysis {
  rca_id string [primary key]
  incident_id string [not null]
  analysis_method enum('five_whys','fishbone','timeline_analysis','fault_tree') [not null]
  conducted_by_id string [not null]
  completed_at timestamp
  status enum('in_progress','completed','approved') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table communications {
  communication_id string [primary key]
  incident_id string [not null]
  sender_id string [not null]
  recipient_id string
  recipient_type enum('client','internal_team','executive','vendor','regulatory') [not null]
  communication_type enum('email','sms','phone_call','status_page','portal_update') [not null]
  sent_at timestamp [not null]
  delivery_status enum('sent','delivered','failed','pending') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table escalations {
  escalation_id string [primary key]
  escalation_code varchar(50) [unique, not null] // e.g., 'ESC-2024-00789', 'ESCALATION-001234'
  incident_id string [not null]
  escalated_by_id string [not null]
  escalated_to_id string [not null]
  escalation_reason enum('sla_breach','severity_increase','resource_unavailable','executive_request','client_demand') [not null]
  escalation_level enum('technical','management','executive','vendor') [not null]
  escalated_at timestamp [not null]
  acknowledged_at timestamp
  resolved_at timestamp
  status enum('open','acknowledged','resolved') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table change_requests {
  change_id string [primary key]
  change_code varchar(50) [unique, not null] // e.g., 'CHG-2024-00456', 'CR-001234'
  incident_id string
  title varchar(100) [not null]
  change_type enum('emergency','standard','normal') [not null]
  requested_by_id string [not null]
  approved_by_id string
  risk_level enum('high','medium','low') [not null]
  scheduled_start timestamp
  scheduled_end timestamp
  actual_start timestamp
  actual_end timestamp
  status enum('requested','approved','scheduled','in_progress','completed','failed','rolled_back') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table rollback_requests {
  rollback_id string [primary key]
  rollback_code varchar(50) [unique, not null] // e.g., 'RBK-2024-00321', 'ROLLBACK-001234'
  change_id string [not null]
  incident_id string
  requested_by_id string [not null]
  approved_by_id string
  executed_at timestamp
  validation_completed boolean [default: false]
  status enum('requested','approved','in_progress','completed','failed') [not null]
  created_at timestamp [not null, default: `NOW()`]
}



// Vendor incidents are now handled directly in the incidents table
// with vendor_id and vendor_ticket_id fields

Table metrics {
  metric_id string [primary key]
  incident_id string [not null]
  metric_type enum('MTTA','MTTD','MTTR','MTTM','FTR') [not null]
  value_minutes int [not null]
  target_minutes int
  recorded_at timestamp [not null]
  created_at timestamp [not null, default: `NOW()`]
}

// Table compliance_events {
//   compliance_id string [primary key]
//   incident_id string [not null]
//   regulation_type enum('GDPR','HIPAA','SOX','PCI_DSS','FFIEC','CCPA','FCC','NERC') [not null]
//   event_type enum('breach_assessment','notification_required','reporting_deadline','audit_trigger') [not null]
//   deadline timestamp
//   completed_at timestamp
//   responsible_party_id string [not null]
//   status enum('pending','in_progress','completed','overdue') [not null]
//   created_at timestamp [not null, default: `NOW()`]
// }

Table incident_reports {
  report_id string [primary key]
  incident_id string [not null]
  report_type enum('executive_summary','technical_details','business_impact','compliance_report','post_mortem') [not null]
  generated_by_id string [not null]
  generated_at timestamp [not null]
  status enum('draft','completed','distributed') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table knowledge_base_articles {
  article_id string [primary key]
  // article_code varchar(50) [unique, not null] // e.g., 'KB-00741'
  incident_id string
  title varchar(100) [not null]
  article_type enum('troubleshooting','resolution_steps','prevention_guide','faq') [not null]
  created_by_id string [not null]
  reviewed_by_id string
  category enum(
    'authentication_issues',
    'payment_processing', 
    'api_integration',
    'data_synchronization',
    'system_outages',
    'performance_degradation',
    'security_incidents',
    'backup_recovery',
    'user_management',
    'billing_issues',
    'compliance_procedures',
    'vendor_escalations',
    'configuration_changes',
    'monitoring_alerts',
    'network_connectivity',
    'database_issues',
    'file_transfer_problems',
    'reporting_errors',
    'mobile_app_issues',
    'browser_compatibility',
    'third_party_integrations',
    'scheduled_maintenance',
    'emergency_procedures',
    'client_onboarding',
    'account_provisioning',
    'sla_management',
    'incident_response',
    'change_management',
    'capacity_planning',
    'disaster_recovery'
  )
  view_count int [default: 0]
  status enum('draft','published','archived') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table post_incident_reviews {
  pir_id string [primary key]
  incident_id string [not null]
  scheduled_date timestamp [not null]
  facilitator_id string [not null]
  timeline_accuracy_rating int
  communication_effectiveness_rating int
  technical_response_rating int
  status enum('scheduled','completed','cancelled') [not null]
  created_at timestamp [not null, default: `NOW()`]
}

// Relationships
Ref: users.client_id > clients.client_id
Ref: users.vendor_id > vendors.vendor_id
// Ref: products.internal_team_lead_id > users.user_id
Ref: products.vendor_support_id > vendors.vendor_id
Ref: client_subscriptions.client_id > clients.client_id
Ref: client_subscriptions.product_id > products.product_id
Ref: sla_agreements.subscription_id > client_subscriptions.subscription_id
Ref: incidents.reporter_id > users.user_id
Ref: incidents.assigned_manager_id > users.user_id
Ref: incidents.client_id > clients.client_id
Ref: incidents.component_id > infrastructure_components.component_id
// Ref: incidents.vendor_id > vendors.vendor_id
// Ref: incident_updates.incident_id > incidents.incident_id
// Ref: incident_updates.updated_by_id > users.user_id
Ref: workarounds.incident_id > incidents.incident_id
Ref: workarounds.implemented_by_id > users.user_id
Ref: root_cause_analysis.incident_id > incidents.incident_id
Ref: root_cause_analysis.conducted_by_id > users.user_id
Ref: communications.incident_id > incidents.incident_id
Ref: communications.sender_id > users.user_id
Ref: escalations.incident_id > incidents.incident_id
Ref: escalations.escalated_by_id > users.user_id
Ref: escalations.escalated_to_id > users.user_id
Ref: change_requests.incident_id > incidents.incident_id
Ref: change_requests.requested_by_id > users.user_id
Ref: change_requests.approved_by_id > users.user_id
Ref: rollback_requests.change_id > change_requests.change_id
Ref: rollback_requests.incident_id > incidents.incident_id
Ref: rollback_requests.requested_by_id > users.user_id
Ref: rollback_requests.approved_by_id > users.user_id
Ref: metrics.incident_id > incidents.incident_id
// Ref: compliance_events.incident_id > incidents.incident_id
// Ref: compliance_events.responsible_party_id > users.user_id
Ref: incident_reports.incident_id > incidents.incident_id
Ref: incident_reports.generated_by_id > users.user_id
Ref: knowledge_base_articles.incident_id > incidents.incident_id
Ref: knowledge_base_articles.created_by_id > users.user_id
Ref: knowledge_base_articles.reviewed_by_id > users.user_id
Ref: post_incident_reviews.incident_id > incidents.incident_id
Ref: post_incident_reviews.facilitator_id > users.user_id
Ref: infrastructure_components.product_id > products.product_id

You have to provide the json file for each function separately including all the tests for that function in the actions part. You are going to provide the bash script that will create and populate those json files in a folder named tools_regression_tests/interface_1/.

Note: ids are just numeric strings "1", "2", ...
