Assume you are an experienced tester. I am going to give you python functions and you are going to give me the inputs to test this function. The inputs are provided in the form of actions. You have to provide diverse tests with different number of parameters (if applicable). You have to provide edge cases and normal cases. Try to use all of the fields in one of the cases. You have to provide invalid cases. You have to provide empty cases if applicable. However, you have to follow the format that I provide to you below.

# Format:
{
    "env": "hr_experts",
    "interface_num": 1,
    "task": {
        "actions": [
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            },
            {
                "name": "discover_user_entities",
                "arguments": {
                    "entity_type": "users",
                    "filters": {
                        "email": "sarahcampos144@hotmail.com"
                    }
                }
            }
        ]
    }
}

where the name of action is the function name and the arguments are the parameters of the function. You have to provide multiple actions for a single file in a single test if applicable. 

# Functions:
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool


class ManagePerformanceReview(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, review_data: Dict[str, Any] = None, review_id: str = None) -> str:
        """
        Create or update performance review records.
        
        Actions:
        - create: Create new performance review (requires review_data with employee_id, reviewer_id, review_period_start, review_period_end, review_type, overall_rating)
        - update: Update existing performance review (requires review_id, review_data, and hr_manager_approval for final approval)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
            
        def is_valid_date_order(start_date: str, end_date: str) -> bool:
            """Check if start date is before end date - simplified for demo"""
            return start_date <= end_date
            
        # def is_valid_status_progression(current_status: str, new_status: str) -> bool:
        #     """Validate status progression follows proper workflow"""
        #     # Define proper progression: draft → submitted → approved
        #     workflow_order = ["draft", "submitted", "approved"]
            
        #     if current_status not in workflow_order or new_status not in workflow_order:
        #         return False
            
        #     current_index = workflow_order.index(current_status)
        #     new_index = workflow_order.index(new_status)
            
        #     # Can only move forward or stay the same
        #     return new_index >= current_index
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for performance reviews"
            })
        
        performance_reviews = data.get("performance_reviews", {})
        employees = data.get("employees", {})
        users = data.get("users", {})
        
        if action == "create":
            if not review_data:
                return json.dumps({
                    "success": False,
                    "error": "review_data is required for create action"
                })
            
            # Validate required fields
            required_fields = ["employee_id", "reviewer_id", "review_period_start", "review_period_end", "review_type", "overall_rating"]
            missing_fields = [field for field in required_fields if field not in review_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid performance review details: {', '.join(missing_fields)}"
                })
            
            # Validate that employee exists and has active status
            employee_id = str(review_data["employee_id"])
            if employee_id not in employees:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Employee {employee_id} not found"
                })
            
            employee = employees[employee_id]
            if employee.get("employment_status") != "active":
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Employee {employee_id} does not have active status"
                })
            
            # Validate that reviewer exists and has active status
            reviewer_id = str(review_data["reviewer_id"])
            if reviewer_id not in users:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Reviewer {reviewer_id} not found"
                })
            
            reviewer = users[reviewer_id]
            if reviewer.get("status") != "active":
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Reviewer {reviewer_id} does not have active status"
                })
            
            # Validate that review period dates are logical (start date before end date)
            review_period_start = review_data["review_period_start"]
            review_period_end = review_data["review_period_end"]
            if not is_valid_date_order(review_period_start, review_period_end):
                return json.dumps({
                    "success": False,
                    "error": "Halt: Review period start date must be before end date"
                })
            
            # Validate review_type is within accepted categories according to policy
            valid_types = ["annual", "quarterly", "probationary", "project-based"]
            if review_data["review_type"] not in valid_types:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid review_type. Must be one of: {', '.join(valid_types)}"
                })
            
            # Validate overall_rating - using common rating scale
            valid_ratings = ["exceeds_expectations", "meets_expectations", "below_expectations", "unsatisfactory"]
            if review_data["overall_rating"] not in valid_ratings:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid overall_rating. Must be one of: {', '.join(valid_ratings)}"
                })
            
            # Validate only allowed fields are present
            allowed_fields = ["employee_id", "reviewer_id", "review_period_start", "review_period_end", 
                            "review_type", "overall_rating", "goals_achievement_score", "communication_score",
                            "teamwork_score", "leadership_score", "technical_skills_score"]
            invalid_fields = [field for field in review_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for performance review creation: {', '.join(invalid_fields)}"
                })
            
            # Generate new review ID
            new_review_id = generate_id(performance_reviews)
            
            # Create performance review with required information: employee, reviewer, review period dates, review type, overall rating
            # Set optional score information if provided for various competency areas
            new_review = {
                "review_id": str(new_review_id),
                "employee_id": employee_id,
                "reviewer_id": reviewer_id,
                "review_period_start": review_period_start,
                "review_period_end": review_period_end,
                "review_type": review_data["review_type"],
                "overall_rating": review_data["overall_rating"],
                "goals_achievement_score": review_data.get("goals_achievement_score"),
                "communication_score": review_data.get("communication_score"),
                "teamwork_score": review_data.get("teamwork_score"),
                "leadership_score": review_data.get("leadership_score"),
                "technical_skills_score": review_data.get("technical_skills_score"),
                "status": "draft",  # System default: draft status for proper progression
                "created_at": "2025-10-01T12:00:00",
                "updated_at": "2025-10-01T12:00:00"
            }
            
            performance_reviews[str(new_review_id)] = new_review
            
            return json.dumps({
                "success": True,
                "action": "create",
                "review_id": str(new_review_id),
                "message": f"Performance review {new_review_id} created successfully",
                "review_data": new_review
            })
        
        elif action == "update":
            if not review_id:
                return json.dumps({
                    "success": False,
                    "error": "review_id is required for update action"
                })
            
            if review_id not in performance_reviews:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Performance review {review_id} not found"
                })
            
            if not review_data:
                return json.dumps({
                    "success": False,
                    "error": "review_data is required for update action"
                })
            
            # Get current review for validation
            current_review = performance_reviews[review_id]
            current_status = current_review.get("status", "draft")
            
            # Authorization Check - HR Manager approval required for final approval
            if "status" in review_data and review_data["status"] == "approved":
                hr_manager_approval = review_data.get("hr_manager_approval", False)
                if not hr_manager_approval:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: HR Manager approval required"
                    })
            
            # Validate only allowed fields for updates
            allowed_update_fields = ["overall_rating", "goals_achievement_score", "communication_score",
                                   "teamwork_score", "leadership_score", "technical_skills_score", 
                                   "status", "hr_manager_approval"]
            invalid_fields = [field for field in review_data.keys() if field not in allowed_update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for performance review update: {', '.join(invalid_fields)}. Cannot update employee_id, reviewer_id, or review_period_dates."
                })
            
            # Validate status transitions follow proper workflow if status is being updated
            if "status" in review_data:
                new_status = review_data["status"]
                valid_statuses = ["draft", "submitted", "approved"]
                
                if new_status not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid status. Must be one of: {', '.join(valid_statuses)}"
                    })
                
                # # Update status through proper progression (draft to submitted to approved)
                # if not is_valid_status_progression(current_status, new_status):
                #     return json.dumps({
                #         "success": False,
                #         "error": f"Halt: Invalid status transition from {current_status} to {new_status}"
                #     })
            
            # Validate overall_rating if provided
            if "overall_rating" in review_data:
                valid_ratings = ["exceeds_expectations", "meets_expectations", "below_expectations", "unsatisfactory"]
                if review_data["overall_rating"] not in valid_ratings:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid overall_rating. Must be one of: {', '.join(valid_ratings)}"
                    })
            
            # Update performance review
            updated_review = current_review.copy()
            for key, value in review_data.items():
                if key != "hr_manager_approval":  # Skip approval from being stored
                    updated_review[key] = value
            
            updated_review["updated_at"] = "2025-10-01T12:00:00"
            performance_reviews[review_id] = updated_review
            
            return json.dumps({
                "success": True,
                "action": "update",
                "review_id": review_id,
                "message": f"Performance review {review_id} updated successfully",
                "review_data": updated_review
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_performance_review",
                "description": "Create or update performance review records in the HR system. This tool manages performance review cycles with comprehensive validation and workflow controls. For creation, establishes new performance reviews with proper validation of employee/reviewer existence, review period logic, and competency scoring. For updates, modifies existing reviews while enforcing proper status progression and requiring HR Manager approval for final approval. Validates review types against accepted categories, ensures proper date ordering, validates rating scales, and enforces status workflow progression (draft → submitted → approved). Essential for performance management, employee development tracking, and maintaining accurate review records.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new performance review, 'update' to modify existing review",
                            "enum": ["create", "update"]
                        },
                        "review_data": {
                            "type": "object",
                            "description": "Performance review data object. For create: requires employee_id, reviewer_id, review_period_start, review_period_end, review_type, overall_rating. Optional: competency scores. For update: fields to change, requires hr_manager_approval for final approval. SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "employee_id": {
                                    "type": "string",
                                    "description": "Employee identifier (required for create, must exist with active status, cannot be updated)"
                                },
                                "reviewer_id": {
                                    "type": "string",
                                    "description": "Reviewer identifier (required for create, must exist with active status, cannot be updated)"
                                },
                                "review_period_start": {
                                    "type": "string",
                                    "description": "Review period start date in YYYY-MM-DD format (required for create, must be before end date, cannot be updated)"
                                },
                                "review_period_end": {
                                    "type": "string",
                                    "description": "Review period end date in YYYY-MM-DD format (required for create, must be after start date, cannot be updated)"
                                },
                                "review_type": {
                                    "type": "string",
                                    "description": "Type of performance review (required for create, cannot be updated)",
                                    "enum": ["annual", "quarterly", "probationary", "project-based"]
                                },
                                "overall_rating": {
                                    "type": "string",
                                    "description": "Overall performance rating (required for create)",
                                    "enum": ["exceeds_expectations", "meets_expectations", "below_expectations", "unsatisfactory"]
                                },
                                "goals_achievement_score": {
                                    "type": "number",
                                    "description": "Goals achievement competency score"
                                },
                                "communication_score": {
                                    "type": "number",
                                    "description": "Communication skills competency score"
                                },
                                "teamwork_score": {
                                    "type": "number",
                                    "description": "Teamwork competency score"
                                },
                                "leadership_score": {
                                    "type": "number",
                                    "description": "Leadership competency score"
                                },
                                "technical_skills_score": {
                                    "type": "number",
                                    "description": "Technical skills competency score"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Review status (follows progression: draft → submitted → approved)",
                                    "enum": ["draft", "submitted", "approved"]
                                },
                                "hr_manager_approval": {
                                    "type": "boolean",
                                    "description": "HR Manager approval status (True/False, required for final approval to approved status)"
                                }
                            }
                        },
                        "review_id": {
                            "type": "string",
                            "description": "Unique identifier of the performance review (required for update action only)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool


class ManageInterview(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, interview_data: Dict[str, Any] = None, interview_id: str = None) -> str:
        """
        Create or update interview records.
        
        Actions:
        - create: Schedule new interview (requires interview_data with application_id, interviewer_id, interview_type, scheduled_date, recruiter_approval or hiring_manager_approval)
        - update: Record interview outcome (requires interview_id and interview_data with outcome details)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
            
        def is_future_datetime(datetime_str: str) -> bool:
            """Check if datetime is in future - simplified for demo"""
            # In real implementation, would compare with current datetime
            # For demo purposes, assume dates starting with "2024" or earlier are not future
            return not (datetime_str.startswith("2024") or datetime_str.startswith("2023"))
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for interviews"
            })
        
        interviews = data.get("interviews", {})
        job_applications = data.get("job_applications", {})
        users = data.get("users", {})
        
        if action == "create":
            if not interview_data:
                return json.dumps({
                    "success": False,
                    "error": "interview_data is required for create action"
                })
            
            # Validate required fields
            required_fields = ["application_id", "interviewer_id", "interview_type", "scheduled_date"]
            missing_fields = [field for field in required_fields if field not in interview_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid interview scheduling details: {', '.join(missing_fields)}"
                })
            
            # Validate that application exists
            application_id = str(interview_data["application_id"])
            if application_id not in job_applications:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Invalid interview scheduling details - application not found"
                })
            
            # Validate that interviewer exists
            interviewer_id = str(interview_data["interviewer_id"])
            if interviewer_id not in users:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Invalid interview scheduling details - interviewer not found"
                })
            
            # No authorization check required for interview scheduling per policy
            
            # Validate interview_type enum according to policy
            valid_types = ["phone screening", "technical", "behavioral", "panel", "final"]
            if interview_data["interview_type"] not in valid_types:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid interview_type. Must be one of: {', '.join(valid_types)}"
                })
            
            # Validate that scheduled date and time is in the future
            scheduled_date = interview_data["scheduled_date"]
            if not is_future_datetime(scheduled_date):
                return json.dumps({
                    "success": False,
                    "error": "Halt: Scheduled date and time must be in the future"
                })
            
            # Validate that duration is positive time value with reasonable default
            duration_minutes = interview_data.get("duration_minutes", 60)  # Standard duration default
            if not isinstance(duration_minutes, (int, float)) or duration_minutes <= 0:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Duration must be a positive time value"
                })
            
            # Validate only allowed fields are present for creation
            allowed_fields = ["application_id", "interviewer_id", "interview_type", "scheduled_date", 
                            "duration_minutes"]
            invalid_fields = [field for field in interview_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for interview creation: {', '.join(invalid_fields)}"
                })
            
            # Generate new interview ID
            new_interview_id = generate_id(interviews)
            
            # Create new interview record with system defaults
            new_interview = {
                "interview_id": str(new_interview_id),
                "application_id": application_id,
                "interviewer_id": interviewer_id,
                "interview_type": interview_data["interview_type"],
                "scheduled_date": scheduled_date,
                "duration_minutes": duration_minutes,
                "status": "scheduled",  # System default: scheduled status
                "overall_rating": None,
                "technical_score": None,
                "communication_score": None,
                "cultural_fit_score": None,
                "recommendation": None,
                "created_at": "2025-10-01T12:00:00",
                "updated_at": "2025-10-01T12:00:00"
            }
            
            interviews[str(new_interview_id)] = new_interview
            
            return json.dumps({
                "success": True,
                "action": "create",
                "interview_id": str(new_interview_id),
                "message": f"Interview {new_interview_id} scheduled successfully",
                "interview_data": new_interview
            })
        
        elif action == "update":
            if not interview_id:
                return json.dumps({
                    "success": False,
                    "error": "interview_id is required for update action"
                })
            
            if interview_id not in interviews:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Interview {interview_id} not found"
                })
            
            if not interview_data:
                return json.dumps({
                    "success": False,
                    "error": "interview_data is required for update action"
                })
            
            # Get current interview for validation
            current_interview = interviews[interview_id]
            current_status = current_interview.get("status")
            
            # Validate that interview has scheduled or completed status
            if current_status not in ["scheduled", "completed"]:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Interview must have scheduled or completed status for outcome recording"
                })
            
            # Validate only allowed fields for updates (outcome recording)
            allowed_update_fields = ["overall_rating", "technical_score", "communication_score", 
                                   "cultural_fit_score", "recommendation", "status"]
            invalid_fields = [field for field in interview_data.keys() if field not in allowed_update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for interview outcome recording: {', '.join(invalid_fields)}"
                })
            
            # Validate overall rating is within accepted scale if provided
            if "overall_rating" in interview_data:
                valid_ratings = ["excellent", "good", "average", "below_average", "poor"]
                if interview_data["overall_rating"] not in valid_ratings:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid overall_rating. Must be one of: {', '.join(valid_ratings)}"
                    })
            
            # Validate individual scores are within acceptable numeric range if provided
            score_fields = ["technical_score", "communication_score", "cultural_fit_score"]
            for score_field in score_fields:
                if score_field in interview_data:
                    score = interview_data[score_field]
                    if score is not None and (not isinstance(score, (int, float)) or score < 0 or score > 10):
                        return json.dumps({
                            "success": False,
                            "error": f"Halt: {score_field} must be within acceptable numeric range (0-10)"
                        })
            
            # Validate recommendation is within accepted options if provided
            if "recommendation" in interview_data:
                valid_recommendations = ["strong hire", "hire", "no hire", "strong no hire"]
                if interview_data["recommendation"] not in valid_recommendations:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid recommendation. Must be one of: {', '.join(valid_recommendations)}"
                    })
            
            # Update interview record with outcome information
            updated_interview = current_interview.copy()
            for key, value in interview_data.items():
                updated_interview[key] = value
            
            # Change status to completed if outcome is being recorded
            if any(field in interview_data for field in ["overall_rating", "recommendation"]):
                updated_interview["status"] = "completed"
            
            updated_interview["updated_at"] = "2025-10-01T12:00:00"
            interviews[interview_id] = updated_interview
            
            # Update related job application status based on interview outcome
            application_id = current_interview.get("application_id")
            if application_id and application_id in job_applications:
                application = job_applications[application_id]
                current_app_status = application.get("status")
                new_app_status = current_app_status
                
                recommendation = updated_interview.get("recommendation")
                overall_rating = updated_interview.get("overall_rating")
                interview_type = updated_interview.get("interview_type")
                
                # Update job application status based on interview outcome per policy
                if recommendation in ["strong hire", "hire"]:
                    if current_app_status == "interviewing":
                        new_app_status = "offer_made"
                elif recommendation in ["no hire", "strong no hire"]:
                    new_app_status = "rejected"
                elif not recommendation and overall_rating:
                    # When no recommendation provided, use rating
                    if overall_rating in ["poor", "below_average"]:
                        new_app_status = "rejected"
                    # excellent/good ratings remain at interviewing for potential additional interviews
                
                # Final interviews with positive recommendations automatically advance to offer_made
                if interview_type == "final" and recommendation in ["strong hire", "hire"]:
                    new_app_status = "offer_made"
                
                # Update application status if changed
                if new_app_status != current_app_status:
                    updated_application = application.copy()
                    updated_application["status"] = new_app_status
                    updated_application["updated_at"] = "2025-10-01T12:00:00"
                    job_applications[application_id] = updated_application
            
            return json.dumps({
                "success": True,
                "action": "update",
                "interview_id": interview_id,
                "message": f"Interview {interview_id} outcome recorded successfully",
                "interview_data": updated_interview
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_interview",
                "description": "Create or update interview records in the HR recruitment system. This tool manages interview scheduling and outcome recording with comprehensive validation and workflow controls. For creation (scheduling), establishes new interviews with proper validation of application/interviewer existence, future date requirements, and authorization. For updates (outcome recording), captures interview results and automatically updates related job application status based on recommendations and ratings. Validates interview types, ensures scheduled dates are in future, validates score ranges, and enforces proper status transitions. Essential for recruitment workflow management, candidate evaluation tracking, and maintaining accurate hiring records.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to schedule new interview, 'update' to record interview outcome",
                            "enum": ["create", "update"]
                        },
                        "interview_data": {
                            "type": "object",
                            "description": "Interview data object. For create: requires application_id, interviewer_id, interview_type, scheduled_date. Optional: duration_minutes. For update: outcome fields like overall_rating, scores, recommendation. SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "application_id": {
                                    "type": "string",
                                    "description": "Job application identifier (required for create, must exist in system)"
                                },
                                "interviewer_id": {
                                    "type": "string",
                                    "description": "Interviewer user identifier (required for create, must exist in system)"
                                },
                                "interview_type": {
                                    "type": "string",
                                    "description": "Type of interview being scheduled",
                                    "enum": ["phone screening", "technical", "behavioral", "panel", "final"]
                                },
                                "scheduled_date": {
                                    "type": "string",
                                    "description": "Interview date and time in YYYY-MM-DDTHH:MM:SS format (must be in future)"
                                },
                                "duration_minutes": {
                                    "type": "integer",
                                    "description": "Interview duration in minutes (positive value, defaults to 60)"
                                },
                                "overall_rating": {
                                    "type": "string",
                                    "description": "Overall interview rating (for outcome recording)",
                                    "enum": ["excellent", "good", "average", "below_average", "poor"]
                                },
                                "technical_score": {
                                    "type": "number",
                                    "description": "Technical skills score (0-10 range, for outcome recording)"
                                },
                                "communication_score": {
                                    "type": "number",
                                    "description": "Communication skills score (0-10 range, for outcome recording)"
                                },
                                "cultural_fit_score": {
                                    "type": "number",
                                    "description": "Cultural fit score (0-10 range, for outcome recording)"
                                },
                                "recommendation": {
                                    "type": "string",
                                    "description": "Hiring recommendation (affects job application status)",
                                    "enum": ["strong hire", "hire", "no hire", "strong no hire"]
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Interview status (automatically set to completed for outcome recording)"
                                }
                            }
                        },
                        "interview_id": {
                            "type": "string",
                            "description": "Unique identifier of the interview (required for update action only)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageBenefitsPlan(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, plan_data: Dict[str, Any] = None, plan_id: str = None) -> str:
        """
        Create or update benefits plan records.
        
        Actions:
        - create: Create new benefits plan (requires plan_data with plan_name, plan_type, effective_date, hr_director_approval or finance_officer_approval)
        - update: Update existing benefits plan (requires plan_id and plan_data with changes and approval)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for benefits plans"
            })
        
        benefits_plans = data.get("benefits_plans", {})
        
        if action == "create":
            if not plan_data:
                return json.dumps({
                    "success": False,
                    "error": "plan_data is required for create action"
                })
            
            # Validate required fields for creation
            required_fields = ["plan_name", "plan_type", "effective_date"]
            missing_fields = [field for field in required_fields if field not in plan_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid benefits plan details: {', '.join(missing_fields)}"
                })
            
            # Authorization Check - HR Director or Finance Officer approval required
            hr_approval = plan_data.get("hr_director_approval", False)
            finance_approval = plan_data.get("finance_officer_approval", False)
            
            if not hr_approval and not finance_approval:
                return json.dumps({
                    "success": False,
                    "error": "Halt: HR Director or Finance Officer approval required"
                })
            
            # Validate plan_type enum according to policy
            valid_types = ["health insurance", "dental", "vision", "life insurance", "disability", "retirement", "paid time off", "flexible spending"]
            if plan_data["plan_type"] not in valid_types:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid plan_type. Must be one of: {', '.join(valid_types)}"
                })
            
            # Validate cost amounts are non-negative monetary values if provided
            for cost_field in ["employee_cost", "employer_cost"]:
                if cost_field in plan_data:
                    cost_value = plan_data[cost_field]
                    if cost_value is not None and (not isinstance(cost_value, (int, float)) or cost_value < 0):
                        return json.dumps({
                            "success": False,
                            "error": f"Halt: {cost_field} must be a non-negative monetary value"
                        })
            
            # Validate date consistency - expiration date must occur after effective date if provided
            effective_date = plan_data["effective_date"]
            expiration_date = plan_data.get("expiration_date")
            if expiration_date and expiration_date <= effective_date:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Expiration date must occur after effective date"
                })
            
            # Check for duplicate plan name
            plan_name = plan_data["plan_name"].strip()
            for existing_plan in benefits_plans.values():
                if existing_plan.get("plan_name", "").strip().lower() == plan_name.lower():
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Benefits plan with name '{plan_name}' already exists"
                    })
            
            # Validate only allowed fields are present
            allowed_fields = ["plan_name", "plan_type", "provider", "employee_cost", "employer_cost", 
                            "status", "effective_date", "expiration_date", "hr_director_approval", "finance_officer_approval"]
            invalid_fields = [field for field in plan_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for benefits plan creation: {', '.join(invalid_fields)}"
                })
            
            # Generate new plan ID
            new_plan_id = generate_id(benefits_plans)
            
            # Create new benefits plan with system defaults
            new_plan = {
                "plan_id": str(new_plan_id),
                "plan_name": plan_data["plan_name"],
                "plan_type": plan_data["plan_type"],
                "provider": plan_data.get("provider"),
                "employee_cost": plan_data.get("employee_cost"),
                "employer_cost": plan_data.get("employer_cost"),
                "status": plan_data.get("status", "active"),  # System default: active status
                "effective_date": plan_data["effective_date"],
                "expiration_date": plan_data.get("expiration_date"),
                "created_at": "2025-10-01T12:00:00",
                "updated_at": "2025-10-01T12:00:00"
            }
            
            benefits_plans[str(new_plan_id)] = new_plan
            
            return json.dumps({
                "success": True,
                "action": "create",
                "plan_id": str(new_plan_id),
                "message": f"Benefits plan {new_plan_id} created successfully",
                "plan_data": new_plan
            })
        
        elif action == "update":
            if not plan_id:
                return json.dumps({
                    "success": False,
                    "error": "plan_id is required for update action"
                })
            
            if plan_id not in benefits_plans:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Benefits plan {plan_id} not found"
                })
            
            if not plan_data:
                return json.dumps({
                    "success": False,
                    "error": "plan_data is required for update action"
                })
            
            # Authorization Check - HR Director or Finance Officer approval required
            hr_approval = plan_data.get("hr_director_approval", False)
            finance_approval = plan_data.get("finance_officer_approval", False)
            
            if not hr_approval and not finance_approval:
                return json.dumps({
                    "success": False,
                    "error": "Halt: HR Director or Finance Officer approval required"
                })
            
            # Validate plan exists and get current plan
            current_plan = benefits_plans[plan_id]
            
            # Validate only allowed fields for updates
            allowed_update_fields = ["plan_name", "plan_type", "provider", "employee_cost", "employer_cost", 
                                   "status", "effective_date", "expiration_date", "hr_director_approval", "finance_officer_approval"]
            invalid_fields = [field for field in plan_data.keys() if field not in allowed_update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for benefits plan update: {', '.join(invalid_fields)}"
                })
            
            # Validate status enum if provided
            if "status" in plan_data:
                valid_statuses = ["active", "inactive"]
                if plan_data["status"] not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid status. Must be one of: {', '.join(valid_statuses)}"
                    })
            
            # Validate plan_type enum if provided
            if "plan_type" in plan_data:
                valid_types = ["health insurance", "dental", "vision", "life insurance", "disability", "retirement", "paid time off", "flexible spending"]
                if plan_data["plan_type"] not in valid_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid plan_type. Must be one of: {', '.join(valid_types)}"
                    })
            
            # Validate cost amounts are non-negative monetary values if provided
            for cost_field in ["employee_cost", "employer_cost"]:
                if cost_field in plan_data:
                    cost_value = plan_data[cost_field]
                    if cost_value is not None and (not isinstance(cost_value, (int, float)) or cost_value < 0):
                        return json.dumps({
                            "success": False,
                            "error": f"Halt: {cost_field} must be a non-negative monetary value"
                        })
            
            # Validate date consistency while maintaining date consistency
            effective_date = plan_data.get("effective_date", current_plan.get("effective_date"))
            expiration_date = plan_data.get("expiration_date", current_plan.get("expiration_date"))
            
            if effective_date and expiration_date and expiration_date <= effective_date:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Expiration date must occur after effective date"
                })
            
            # Check for duplicate plan name if plan name is being updated
            if "plan_name" in plan_data:
                plan_name = plan_data["plan_name"].strip()
                for existing_id, existing_plan in benefits_plans.items():
                    if (existing_id != plan_id and 
                        existing_plan.get("plan_name", "").strip().lower() == plan_name.lower()):
                        return json.dumps({
                            "success": False,
                            "error": f"Halt: Benefits plan with name '{plan_name}' already exists"
                        })
            
            # Update benefits plan while maintaining date consistency
            updated_plan = current_plan.copy()
            for key, value in plan_data.items():
                if key not in ["hr_director_approval", "finance_officer_approval"]:  # Skip approval from being stored
                    updated_plan[key] = value
            
            updated_plan["updated_at"] = "2025-10-01T12:00:00"
            benefits_plans[plan_id] = updated_plan
            
            return json.dumps({
                "success": True,
                "action": "update",
                "plan_id": plan_id,
                "message": f"Benefits plan {plan_id} updated successfully",
                "plan_data": updated_plan
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_benefits_plan",
                "description": "Create or update benefits plan records in the HR system. This tool manages employee benefits plans with comprehensive validation and authorization controls. For creation, establishes new benefits plans with proper validation of plan details, cost amounts, and HR Director or Finance Officer authorization. For updates, modifies existing plans while maintaining data integrity and date consistency. Validates plan types against supported categories, ensures cost amounts are non-negative, and enforces proper date relationships. Essential for benefits administration, employee enrollment management, and compliance with benefits regulations.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new benefits plan, 'update' to modify existing plan",
                            "enum": ["create", "update"]
                        },
                        "plan_data": {
                            "type": "object",
                            "description": "Benefits plan data object. For create: requires plan_name, plan_type, effective_date, and hr_director_approval or finance_officer_approval. Optional fields: provider, employee_cost, employer_cost, status, expiration_date. For update: fields to change with required approval. SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "plan_name": {
                                    "type": "string",
                                    "description": "Name of the benefits plan (must be unique)"
                                },
                                "plan_type": {
                                    "type": "string",
                                    "description": "Type of benefits plan",
                                    "enum": ["health insurance", "dental", "vision", "life insurance", "disability", "retirement", "paid time off", "flexible spending"]
                                },
                                "provider": {
                                    "type": "string",
                                    "description": "Benefits plan provider/carrier name"
                                },
                                "employee_cost": {
                                    "type": "number",
                                    "description": "Monthly cost to employee (must be non-negative)"
                                },
                                "employer_cost": {
                                    "type": "number",
                                    "description": "Monthly cost to employer (must be non-negative)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Plan status (defaults to 'active')",
                                    "enum": ["active", "inactive"]
                                },
                                "effective_date": {
                                    "type": "string",
                                    "description": "Plan effective date in YYYY-MM-DD format (required for create)"
                                },
                                "expiration_date": {
                                    "type": "string",
                                    "description": "Plan expiration date in YYYY-MM-DD format (must be after effective_date)"
                                },
                                "hr_director_approval": {
                                    "type": "boolean",
                                    "description": "HR Director approval status (True/False)"
                                },
                                "finance_officer_approval": {
                                    "type": "boolean",
                                    "description": "Finance Officer approval status (True/False)"
                                }
                            }
                        },
                        "plan_id": {
                            "type": "string",
                            "description": "Unique identifier of the benefits plan (required for update action only)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool


class ManagePayrollRecord(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, payroll_data: Dict[str, Any] = None, payroll_id: str = None) -> str:
        """
        Create or update payroll records.
        
        Actions:
        - create: Process payroll run (requires payroll_data with employee_id, pay_period_start, pay_period_end, hourly_rate, finance_officer_approval)
        - update: Payroll correction (requires payroll_id, payroll_data with correction details, and finance_officer_approval)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
            
        def is_valid_date_order(start_date: str, end_date: str) -> bool:
            """Check if start date is before end date - simplified for demo"""
            return start_date <= end_date
            
        def aggregate_approved_timesheet_hours(employee_id: str, pay_period_start: str, pay_period_end: str, timesheets: Dict[str, Any]) -> float:
            """Aggregate approved timesheet hours for the specified pay period"""
            total_hours = 0.0
            for timesheet in timesheets.values():
                if (timesheet.get("employee_id") == employee_id and 
                    timesheet.get("status") == "approved" and
                    pay_period_start <= timesheet.get("work_date", "") <= pay_period_end):
                    total_hours += float(timesheet.get("total_hours", 0))
            return total_hours
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for payroll records"
            })
        
        payroll_records = data.get("payroll_records", {})
        employees = data.get("employees", {})
        employee_timesheets = data.get("employee_timesheets", {})
        
        if action == "create":
            if not payroll_data:
                return json.dumps({
                    "success": False,
                    "error": "payroll_data is required for create action"
                })
            
            # Validate that all required information is provided: employee, pay period dates
            required_fields = ["employee_id", "pay_period_start", "pay_period_end", "hourly_rate"]
            missing_fields = [field for field in required_fields if field not in payroll_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid payroll run details: {', '.join(missing_fields)}"
                })
            
            # Validate that employee exists in system
            employee_id = str(payroll_data["employee_id"])
            if employee_id not in employees:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Employee {employee_id} not found"
                })
            
            # Authorization Check - Finance Officer approval required
            finance_officer_approval = payroll_data.get("finance_officer_approval", False)
            if not finance_officer_approval:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Finance Officer approval required"
                })
            
            # Validate that pay period dates are logical (start date before end date)
            pay_period_start = payroll_data["pay_period_start"]
            pay_period_end = payroll_data["pay_period_end"]
            if not is_valid_date_order(pay_period_start, pay_period_end):
                return json.dumps({
                    "success": False,
                    "error": "Halt: Pay period start date must be before end date"
                })
            
            # Validate that hourly rate is positive monetary value
            try:
                hourly_rate = float(payroll_data["hourly_rate"])
                if hourly_rate <= 0:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Hourly rate must be positive monetary value"
                    })
            except (ValueError, TypeError):
                return json.dumps({
                    "success": False,
                    "error": "Halt: Invalid hourly rate format - must be positive monetary value"
                })
            
            # Aggregate approved timesheet hours for the specified pay period
            hours_worked = aggregate_approved_timesheet_hours(employee_id, pay_period_start, pay_period_end, employee_timesheets)
            
            # Validate only allowed fields are present
            allowed_fields = ["employee_id", "pay_period_start", "pay_period_end", "hourly_rate", 
                            "payment_date", "approved_by", "finance_officer_approval"]
            invalid_fields = [field for field in payroll_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for payroll creation: {', '.join(invalid_fields)}"
                })
            
            # Generate new payroll ID
            new_payroll_id = generate_id(payroll_records)
            
            # Create payroll record with required information: employee, pay period dates, hourly rate
            # Calculate hours worked from approved timesheets
            new_payroll = {
                "payroll_id": str(new_payroll_id),
                "employee_id": employee_id,
                "pay_period_start": pay_period_start,
                "pay_period_end": pay_period_end,
                "hours_worked": hours_worked,  # Calculated from approved timesheets
                "hourly_rate": hourly_rate,
                "payment_date": payroll_data.get("payment_date"),
                "status": payroll_data.get("status", "approved"),  # Default to approved if not specified, use provided status if given
                "approved_by": payroll_data.get("approved_by"),
                "created_at": "2025-10-01T12:00:00",
                "updated_at": "2025-10-01T12:00:00"
            }
            
            payroll_records[str(new_payroll_id)] = new_payroll
            
            return json.dumps({
                "success": True,
                "action": "create",
                "payroll_id": str(new_payroll_id),
                "message": f"Payroll record {new_payroll_id} created successfully with {hours_worked} hours",
                "payroll_data": new_payroll
            })
        
        elif action == "update":
            if not payroll_id:
                return json.dumps({
                    "success": False,
                    "error": "payroll_id is required for update action"
                })
            
            # Validate that payroll record exists in the system
            if payroll_id not in payroll_records:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Payroll record {payroll_id} not found"
                })
            
            if not payroll_data:
                return json.dumps({
                    "success": False,
                    "error": "payroll_data is required for update action"
                })
            
            # Authorization Check - Finance Officer approval required for corrections
            finance_officer_approval = payroll_data.get("finance_officer_approval", False)
            if not finance_officer_approval:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Finance Officer approval required"
                })
            
            # Validate only allowed fields for corrections
            allowed_update_fields = ["hours_worked", "hourly_rate", "payment_date", "status", "approved_by", "finance_officer_approval"]
            invalid_fields = [field for field in payroll_data.keys() if field not in allowed_update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for payroll correction: {', '.join(invalid_fields)}. Cannot update employee_id or pay_period_dates."
                })
            
            # Validate that correction information is valid (hours worked and hourly rate must be positive)
            if "hours_worked" in payroll_data:
                try:
                    hours_worked = float(payroll_data["hours_worked"])
                    if hours_worked <= 0:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: Hours worked must be positive"
                        })
                except (ValueError, TypeError):
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Invalid hours worked format - must be positive"
                    })
            
            if "hourly_rate" in payroll_data:
                try:
                    hourly_rate = float(payroll_data["hourly_rate"])
                    if hourly_rate <= 0:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: Hourly rate must be positive"
                        })
                except (ValueError, TypeError):
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Invalid hourly rate format - must be positive"
                    })
            
            # Validate status enum if provided
            if "status" in payroll_data:
                valid_statuses = ["draft", "approved", "paid", "cancelled"]
                if payroll_data["status"] not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid status. Must be one of: {', '.join(valid_statuses)}"
                    })
            
            # Adjust payroll record with correction details
            current_payroll = payroll_records[payroll_id]
            updated_payroll = current_payroll.copy()
            
            for key, value in payroll_data.items():
                if key != "finance_officer_approval":  # Skip approval from being stored
                    updated_payroll[key] = value
            
            # Update modification timestamp
            updated_payroll["updated_at"] = "2025-10-01T12:00:00"
            payroll_records[payroll_id] = updated_payroll
            
            return json.dumps({
                "success": True,
                "action": "update",
                "payroll_id": payroll_id,
                "message": f"Payroll record {payroll_id} corrected successfully",
                "payroll_data": updated_payroll
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_payroll_record",
                "description": "Create or update payroll records in the HR payroll system. This tool manages payroll processing and corrections with comprehensive validation and authorization controls. For creation (payroll run), establishes new payroll records with proper validation of employee existence, pay period logic, and Finance Officer authorization. Automatically aggregates approved timesheet hours for the specified pay period and calculates total hours worked. For updates (payroll correction), modifies existing payroll records while maintaining data integrity and requiring Finance Officer approval for corrections. Validates hours worked and hourly rates are positive, ensures proper date ordering, and enforces field restrictions for corrections. Essential for payroll processing, employee compensation management, and maintaining accurate payroll records.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to process payroll run, 'update' to make payroll correction",
                            "enum": ["create", "update"]
                        },
                        "payroll_data": {
                            "type": "object",
                            "description": "Payroll data object. For create: requires employee_id, pay_period_start, pay_period_end, hourly_rate, finance_officer_approval. Optional: payment_date, approved_by. For update: requires finance_officer_approval plus correction fields. SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "employee_id": {
                                    "type": "string",
                                    "description": "Employee identifier (required for create, must exist in system, cannot be updated)"
                                },
                                "pay_period_start": {
                                    "type": "string",
                                    "description": "Pay period start date in YYYY-MM-DD format (required for create, must be before end date, cannot be updated)"
                                },
                                "pay_period_end": {
                                    "type": "string",
                                    "description": "Pay period end date in YYYY-MM-DD format (required for create, must be after start date, cannot be updated)"
                                },
                                "hourly_rate": {
                                    "type": "number",
                                    "description": "Employee hourly rate (required for create, must be positive monetary value)"
                                },
                                "hours_worked": {
                                    "type": "number",
                                    "description": "Total hours worked (auto-calculated from timesheets for create, can be corrected in update, must be positive)"
                                },
                                "payment_date": {
                                    "type": "string",
                                    "description": "Payment date in YYYY-MM-DD format"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Payroll status (auto-set to approved for create if Finance Officer approved)",
                                    "enum": ["draft", "approved", "paid", "cancelled"]
                                },
                                "approved_by": {
                                    "type": "string",
                                    "description": "User who approved the payroll"
                                },
                                "finance_officer_approval": {
                                    "type": "boolean",
                                    "description": "Finance Officer approval status (True/False, required for both create and update operations)"
                                }
                            }
                        },
                        "payroll_id": {
                            "type": "string",
                            "description": "Unique identifier of the payroll record (required for update action only)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManagePayrollDeduction(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, deduction_data: Dict[str, Any] = None, deduction_id: str = None) -> str:
        """
        Create or update payroll deduction records.
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for payroll deductions"
            })
        
        payroll_deductions = data.get("payroll_deductions", {})
        payroll_records = data.get("payroll_records", {})
        users = data.get("users", {})
        
        if action == "create":
            if not deduction_data:
                return json.dumps({
                    "success": False,
                    "error": "deduction_data is required for create action"
                })
            
            # Validate required fields
            required_fields = ["payroll_id", "deduction_type", "amount", "created_by"]
            missing_fields = [field for field in required_fields if field not in deduction_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid payroll deduction details: {', '.join(missing_fields)}"
                })
            
            # Authorization Check - Payroll Administrator or Finance Officer approval required
            payroll_admin_approval = deduction_data.get("payroll_administrator_approval", False)
            finance_officer_approval = deduction_data.get("finance_officer_approval", False)
            
            if not payroll_admin_approval and not finance_officer_approval:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Payroll Administrator or Finance Officer approval required"
                })
            
            # Validate that payroll record exists in the system
            payroll_id = str(deduction_data["payroll_id"])
            if payroll_id not in payroll_records:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Payroll record {payroll_id} not found"
                })
            
            # Validate that creator exists in the user system
            created_by = str(deduction_data["created_by"])
            if created_by not in users:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Creator {created_by} not found in user system"
                })
            
            # Validate deduction_type enum
            valid_types = ["tax", "insurance", "retirement", "garnishment", "equipment", "other"]
            if deduction_data["deduction_type"] not in valid_types:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid deduction_type. Must be one of: {', '.join(valid_types)}"
                })
            
            # Validate amount is positive monetary value
            try:
                amount = float(deduction_data["amount"])
                if amount <= 0:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Deduction amount must be positive monetary value"
                    })
            except (ValueError, TypeError):
                return json.dumps({
                    "success": False,
                    "error": "Halt: Invalid amount format - must be positive monetary value"
                })
            
            # Validate only allowed fields are present
            allowed_fields = ["payroll_id", "deduction_type", "amount", "created_by", 
                            "payroll_administrator_approval", "finance_officer_approval"]
            invalid_fields = [field for field in deduction_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for payroll deduction creation: {', '.join(invalid_fields)}"
                })
            
            # Generate new deduction ID
            new_deduction_id = generate_id(payroll_deductions)
            
            # Create new deduction record
            new_deduction = {
                "deduction_id": str(new_deduction_id),
                "payroll_id": payroll_id,
                "deduction_type": deduction_data["deduction_type"],
                "amount": deduction_data["amount"],
                "created_by": created_by,
                "created_at": "2025-10-01T12:00:00"
            }
            
            payroll_deductions[str(new_deduction_id)] = new_deduction
            
            return json.dumps({
                "success": True,
                "action": "create",
                "deduction_id": str(new_deduction_id),
                "message": f"Payroll deduction {new_deduction_id} created successfully",
                "deduction_data": new_deduction
            })
        
        elif action == "update":
            if not deduction_id:
                return json.dumps({
                    "success": False,
                    "error": "deduction_id is required for update action"
                })
            
            # Validate that payroll deduction record exists in the system
            if deduction_id not in payroll_deductions:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Payroll deduction {deduction_id} not found"
                })
            
            if not deduction_data:
                return json.dumps({
                    "success": False,
                    "error": "deduction_data is required for update action"
                })
            
            # Authorization Check - Payroll Administrator or Finance Officer approval required for corrections
            payroll_admin_approval = deduction_data.get("payroll_administrator_approval", False)
            finance_officer_approval = deduction_data.get("finance_officer_approval", False)
            
            if not payroll_admin_approval and not finance_officer_approval:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Payroll Administrator or Finance Officer approval required for deduction correction"
                })
            
            # Validate that only modifiable fields are being updated (deduction_type, amount)
            # Check that core fields are not being modified (payroll_id, created_by, deduction_id)
            allowed_update_fields = ["deduction_type", "amount", "payroll_administrator_approval", "finance_officer_approval"]
            invalid_fields = [field for field in deduction_data.keys() if field not in allowed_update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for payroll deduction update: {', '.join(invalid_fields)}. Cannot update payroll_id, created_by, or deduction_id."
                })
            
            # Validate deduction_type enum if provided
            if "deduction_type" in deduction_data:
                valid_types = ["tax", "insurance", "retirement", "garnishment", "equipment", "other"]
                if deduction_data["deduction_type"] not in valid_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid deduction_type. Must be one of: {', '.join(valid_types)}"
                    })
            
            # Validate amount if provided
            if "amount" in deduction_data:
                try:
                    amount = float(deduction_data["amount"])
                    if amount <= 0:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: Deduction amount must be positive monetary value"
                        })
                except (ValueError, TypeError):
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Invalid amount format - must be positive monetary value"
                    })
            
            # Update deduction record - Adjust payroll deduction record with correction details
            # Maintain original creation information (payroll_id, created_by, created_at)
            current_deduction = payroll_deductions[deduction_id]
            updated_deduction = current_deduction.copy()
            
            for key, value in deduction_data.items():
                if key not in ["payroll_administrator_approval", "finance_officer_approval"]:  # Skip approval from being stored
                    updated_deduction[key] = value
            
            # Update modification timestamp
            updated_deduction["updated_at"] = "2025-10-01T12:00:00"
            payroll_deductions[deduction_id] = updated_deduction
            
            return json.dumps({
                "success": True,
                "action": "update",
                "deduction_id": deduction_id,
                "message": f"Payroll deduction {deduction_id} updated successfully",
                "deduction_data": updated_deduction
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_payroll_deduction",
                "description": "Create or update payroll deduction records in the HR payroll system. This tool manages payroll deductions with comprehensive validation, authorization controls, and data integrity checks. For creation, establishes new deductions with proper validation of payroll record existence, creator verification, deduction type compliance, and required Payroll Administrator or Finance Officer approval authorization. For updates (corrections), modifies existing deductions while maintaining data integrity and requiring proper authorization for corrections. Validates deduction amounts are positive monetary values, ensures payroll record exists, verifies creator exists in user system, and enforces approval requirements for all operations. Essential for payroll processing, deduction management, and maintaining accurate payroll records with proper authorization controls.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new payroll deduction, 'update' to make deduction correction",
                            "enum": ["create", "update"]
                        },
                        "deduction_data": {
                            "type": "object",
                            "description": "Deduction data object. For create: requires payroll_id (must exist), deduction_type, amount (positive), created_by (must exist in users), and payroll_administrator_approval or finance_officer_approval. For update: fields to change with required approval authorization. SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "payroll_id": {
                                    "type": "string",
                                    "description": "Payroll record identifier (required for create, must exist in system, cannot be updated)"
                                },
                                "deduction_type": {
                                    "type": "string",
                                    "description": "Type of payroll deduction",
                                    "enum": ["tax", "insurance", "retirement", "garnishment", "equipment", "other"]
                                },
                                "amount": {
                                    "type": "number",
                                    "description": "Deduction amount (must be positive monetary value)"
                                },
                                "created_by": {
                                    "type": "string",
                                    "description": "User who created the deduction (required for create, must exist in user system, cannot be updated)"
                                },
                                "payroll_administrator_approval": {
                                    "type": "boolean",
                                    "description": "Payroll Administrator approval status (True/False, required for create and update operations)"
                                },
                                "finance_officer_approval": {
                                    "type": "boolean",
                                    "description": "Finance Officer approval status (True/False, required for create and update operations)"
                                }
                            }
                        },
                        "deduction_id": {
                            "type": "string",
                            "description": "Unique identifier of the payroll deduction (required for update action only)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool


class ManageEmployeeBenefits(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, benefits_data: Dict[str, Any] = None, enrollment_id: str = None) -> str:
        """
        Create or update employee benefits records.
        
        Actions:
        - create: Create new employee benefits enrollment (requires benefits_data with employee_id, plan_id, enrollment_date, coverage_level)
        - update: Update existing enrollment (requires enrollment_id and benefits_data with changes)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
            
        def is_future_date(date_str: str) -> bool:
            """Check if date is in future - simplified for demo"""
            # In real implementation, would compare with current date
            # For demo purposes, assume dates starting with "2026" or later are future
            return date_str.startswith("2026") or date_str.startswith("2027")
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for employee benefits"
            })
        
        employee_benefits = data.get("employee_benefits", {})
        employees = data.get("employees", {})
        benefits_plans = data.get("benefits_plans", {})
        
        if action == "create":
            if not benefits_data:
                return json.dumps({
                    "success": False,
                    "error": "benefits_data is required for create action"
                })
            
            # Validate required fields
            required_fields = ["employee_id", "plan_id", "enrollment_date", "coverage_level"]
            missing_fields = [field for field in required_fields if field not in benefits_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid benefits enrollment details: {', '.join(missing_fields)}"
                })
            
            # Validate that employee exists and has active status
            employee_id = str(benefits_data["employee_id"])
            if employee_id not in employees:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Employee {employee_id} not found"
                })
            
            employee = employees[employee_id]
            if employee.get("employment_status") != "active":
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Employee {employee_id} does not have active status"
                })
            
            # Validate that benefits plan exists and has active status
            plan_id = str(benefits_data["plan_id"])
            if plan_id not in benefits_plans:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Benefits plan {plan_id} not found"
                })
            
            plan = benefits_plans[plan_id]
            if plan.get("status") != "active":
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Benefits plan {plan_id} does not have active status"
                })
            
            # Validate that enrollment date is not in future
            enrollment_date = benefits_data["enrollment_date"]
            if is_future_date(enrollment_date):
                return json.dumps({
                    "success": False,
                    "error": "Halt: Enrollment date cannot be in future"
                })
            
            # Validate coverage_level enum according to policy
            valid_levels = ["employee only", "employee plus spouse", "employee plus children", "family coverage"]
            if benefits_data["coverage_level"] not in valid_levels:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid coverage_level. Must be one of: {', '.join(valid_levels)}"
                })
            
            # Check that employee is not already enrolled in the same plan type
            plan_type = plan.get("plan_type")
            for existing_enrollment in employee_benefits.values():
                if (existing_enrollment.get("employee_id") == employee_id and 
                    existing_enrollment.get("status") == "active"):
                    existing_plan_id = str(existing_enrollment.get("plan_id"))
                    if existing_plan_id in benefits_plans:
                        existing_plan_type = benefits_plans[existing_plan_id].get("plan_type")
                        if existing_plan_type == plan_type:
                            return json.dumps({
                                "success": False,
                                "error": f"Halt: Employee {employee_id} is already enrolled in {plan_type} plan"
                            })
            
            # Validate only allowed fields are present
            allowed_fields = ["employee_id", "plan_id", "enrollment_date", "coverage_level", "status",
                            "beneficiary_name", "beneficiary_relationship"]
            invalid_fields = [field for field in benefits_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for benefits enrollment: {', '.join(invalid_fields)}"
                })
            
            # Generate new enrollment ID
            new_enrollment_id = generate_id(employee_benefits)
            
            # Create new employee benefits record with system defaults
            new_benefits = {
                "enrollment_id": str(new_enrollment_id),
                "employee_id": employee_id,
                "plan_id": plan_id,
                "enrollment_date": enrollment_date,
                "status": benefits_data.get("status", "active"),  # System default: active enrollment status
                "coverage_level": benefits_data["coverage_level"],
                "beneficiary_name": benefits_data.get("beneficiary_name"),
                "beneficiary_relationship": benefits_data.get("beneficiary_relationship"),
                "created_at": "2025-10-01T12:00:00",
                "updated_at": "2025-10-01T12:00:00"
            }
            
            employee_benefits[str(new_enrollment_id)] = new_benefits
            
            return json.dumps({
                "success": True,
                "action": "create",
                "enrollment_id": str(new_enrollment_id),
                "message": f"Employee benefits enrollment {new_enrollment_id} created successfully",
                "benefits_data": new_benefits
            })
        
        elif action == "update":
            if not enrollment_id:
                return json.dumps({
                    "success": False,
                    "error": "enrollment_id is required for update action"
                })
            
            if enrollment_id not in employee_benefits:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Employee benefits enrollment {enrollment_id} not found"
                })
            
            if not benefits_data:
                return json.dumps({
                    "success": False,
                    "error": "benefits_data is required for update action"
                })
            
            # Get current enrollment for validation
            current_benefits = employee_benefits[enrollment_id]
            current_status = current_benefits.get("status", "active")
            
            # Validate only allowed fields for updates
            allowed_update_fields = ["coverage_level", "status", "beneficiary_name", "beneficiary_relationship"]
            invalid_fields = [field for field in benefits_data.keys() if field not in allowed_update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for benefits enrollment update: {', '.join(invalid_fields)}. Cannot update employee_id, plan_id, or enrollment_date."
                })
            
            # Validate status transitions if status is being updated
            if "status" in benefits_data:
                valid_statuses = ["active", "terminated", "pending"]
                new_status = benefits_data["status"]
                
                if new_status not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid status. Must be one of: {', '.join(valid_statuses)}"
                    })
                
                # Validate status transitions - cannot reactivate terminated enrollments
                if current_status == "terminated" and new_status in ["active", "pending"]:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Cannot reactivate terminated benefits enrollment"
                    })
            
            # Validate coverage_level enum if provided
            if "coverage_level" in benefits_data:
                valid_levels = ["employee only", "employee plus spouse", "employee plus children", "family coverage"]
                if benefits_data["coverage_level"] not in valid_levels:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid coverage_level. Must be one of: {', '.join(valid_levels)}"
                    })
            
            # Update employee benefits record
            updated_benefits = current_benefits.copy()
            for key, value in benefits_data.items():
                updated_benefits[key] = value
            
            updated_benefits["updated_at"] = "2025-10-01T12:00:00"
            employee_benefits[enrollment_id] = updated_benefits
            
            return json.dumps({
                "success": True,
                "action": "update",
                "enrollment_id": enrollment_id,
                "message": f"Employee benefits enrollment {enrollment_id} updated successfully",
                "benefits_data": updated_benefits
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_employee_benefits",
                "description": "Create or update employee benefits enrollment records in the HR system. This tool manages employee benefits enrollments with comprehensive validation and data integrity controls. For creation, establishes new benefits enrollments with proper validation of employee/plan existence, enrollment dates, and duplicate prevention. For updates, modifies existing enrollments while maintaining data integrity and validating status transitions. Validates coverage levels, prevents duplicate enrollments in same plan type, and ensures enrollment dates are not in future. Essential for benefits administration, employee enrollment management, and maintaining accurate benefits records.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new benefits enrollment, 'update' to modify existing enrollment",
                            "enum": ["create", "update"]
                        },
                        "benefits_data": {
                            "type": "object",
                            "description": "Benefits enrollment data object. For create: requires employee_id, plan_id, enrollment_date, coverage_level. Optional fields: status, beneficiary_name, beneficiary_relationship. For update: fields to change (cannot update employee_id, plan_id, or enrollment_date). SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "employee_id": {
                                    "type": "string",
                                    "description": "Employee identifier (required for create, cannot be updated)"
                                },
                                "plan_id": {
                                    "type": "string",
                                    "description": "Benefits plan identifier (required for create, cannot be updated)"
                                },
                                "enrollment_date": {
                                    "type": "string",
                                    "description": "Enrollment date in YYYY-MM-DD format (required for create, cannot be updated, must not be in future)"
                                },
                                "coverage_level": {
                                    "type": "string",
                                    "description": "Coverage level for benefits",
                                    "enum": ["employee only", "employee plus spouse", "employee plus children", "family coverage"]
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Enrollment status (defaults to 'active', terminated enrollments cannot be reactivated)",
                                    "enum": ["active", "terminated", "pending"]
                                },
                                "beneficiary_name": {
                                    "type": "string",
                                    "description": "Name of benefits beneficiary"
                                },
                                "beneficiary_relationship": {
                                    "type": "string",
                                    "description": "Relationship of beneficiary to employee"
                                }
                            }
                        },
                        "enrollment_id": {
                            "type": "string",
                            "description": "Unique identifier of the benefits enrollment (required for update action only)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# -----------------

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool


class ManageJobApplication(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, application_data: Dict[str, Any] = None, application_id: str = None) -> str:
        """
        Create or update job application records.
        
        Actions:
        - create: Create new application (requires candidate_id, position_id, application_date, recruiter_id)
        - update: Update existing application (requires application_id, application_data with status updates, and recruiter_approval or hiring_manager_approval)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
            
        def is_future_date(date_str: str) -> bool:
            """Check if date is in future - simplified for demo"""
            # In real implementation, would compare with current date
            # For demo purposes, assume dates starting with "2026" or later are future
            return date_str.startswith("2026") or date_str.startswith("2027")
            
        # def is_valid_status_transition(current_status: str, new_status: str) -> bool:
        #     """Validate status transitions follow proper workflow"""
        #     # Define the linear progression workflow
        #     workflow_order = ["submitted", "under_review", "screening", "interviewing", "offer_made", "accepted"]
        #     terminal_states = ["accepted", "rejected", "withdrawn"]
        #     exit_states = ["rejected", "withdrawn"]
            
        #     # Cannot transition from terminal states
        #     if current_status in terminal_states:
        #         return False
            
        #     # Can exit to rejected/withdrawn from any active stage
        #     if new_status in exit_states:
        #         return True
                
        #     # Cannot move backward in workflow
        #     if current_status in workflow_order and new_status in workflow_order:
        #         current_index = workflow_order.index(current_status)
        #         new_index = workflow_order.index(new_status)
        #         # Can only move forward one step or stay the same
        #         return new_index >= current_index and new_index <= current_index + 1
            
        #     return False
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for job applications"
            })
        
        applications = data.get("job_applications", {})
        candidates = data.get("candidates", {})
        job_positions = data.get("job_positions", {})
        users = data.get("users", {})
        
        if action == "create":
            if not application_data:
                return json.dumps({
                    "success": False,
                    "error": "application_data is required for create action"
                })
            
            # Validate required fields for creation
            required_fields = ["candidate_id", "position_id", "application_date", "recruiter_id"]
            missing_fields = [field for field in required_fields if field not in application_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid application details: {', '.join(missing_fields)}"
                })
            
            # Validate that candidate exists and is valid
            candidate_id = str(application_data["candidate_id"])
            if candidate_id not in candidates:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Candidate {candidate_id} not found"
                })
            
            # Validate that position exists and is valid
            position_id = str(application_data["position_id"])
            if position_id not in job_positions:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Position {position_id} not found"
                })
            
            # Validate that assigned recruiter exists and has recruiter role
            recruiter_id = str(application_data["recruiter_id"])
            if recruiter_id not in users:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Recruiter {recruiter_id} not found"
                })
            
            recruiter = users[recruiter_id]
            if recruiter.get("role") != "recruiter":
                return json.dumps({
                    "success": False,
                    "error": f"Halt: User {recruiter_id} does not have recruiter role"
                })
            
            # Validate that application date is not in future
            application_date = application_data["application_date"]
            if is_future_date(application_date):
                return json.dumps({
                    "success": False,
                    "error": "Halt: Application date cannot be in future"
                })
            
            # Validate AI screening score if provided
            if "ai_screening_score" in application_data:
                score = application_data["ai_screening_score"]
                if score is not None and (not isinstance(score, (int, float)) or score < 0 or score > 100):
                    return json.dumps({
                        "success": False,
                        "error": "Halt: AI screening score must be within 0-100 percentage range"
                    })
            
            # Validate final_decision enum if provided
            if "final_decision" in application_data:
                valid_decisions = ["hire", "reject", "hold"]
                if application_data["final_decision"] not in valid_decisions:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid final_decision. Must be one of: {', '.join(valid_decisions)}"
                    })
            
            # Validate allowed fields
            allowed_fields = ["candidate_id", "position_id", "application_date", "recruiter_id", 
                            "ai_screening_score", "final_decision", "status"]
            invalid_fields = [field for field in application_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for application creation: {', '.join(invalid_fields)}"
                })
            
            # Validate status if provided
            if "status" in application_data:
                valid_statuses = ["submitted", "under_review", "screening", "interviewing", "offer_made", "accepted", "rejected", "withdrawn"]
                if application_data["status"] not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid status. Must be one of: {', '.join(valid_statuses)}"
                    })
            
            # Generate new application ID
            new_app_id = generate_id(applications)
            
            # Create new application record with system defaults
            new_application = {
                "application_id": str(new_app_id),
                "candidate_id": candidate_id,
                "position_id": position_id,
                "application_date": application_date,
                "status": application_data.get("status", "submitted"),  # System default: submitted status
                "recruiter_id": recruiter_id,
                "ai_screening_score": application_data.get("ai_screening_score"),
                "final_decision": application_data.get("final_decision"),
                "created_at": "2025-10-01T12:00:00",
                "updated_at": "2025-10-01T12:00:00"
            }
            
            applications[str(new_app_id)] = new_application
            
            return json.dumps({
                "success": True,
                "action": "create",
                "application_id": str(new_app_id),
                "message": f"Job application {new_app_id} created successfully",
                "application_data": new_application
            })
        
        elif action == "update":
            if not application_id:
                return json.dumps({
                    "success": False,
                    "error": "application_id is required for update action"
                })
            
            if application_id not in applications:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Invalid application status change - application not found"
                })
            
            if not application_data:
                return json.dumps({
                    "success": False,
                    "error": "application_data is required for update action"
                })
            
            # Authorization Check - Recruiter or Hiring Manager approval required for stage management
            recruiter_approval = application_data.get("recruiter_approval", False)
            hiring_manager_approval = application_data.get("hiring_manager_approval", False)
            
            if not recruiter_approval and not hiring_manager_approval:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Recruiter or Hiring Manager approval required"
                })
            
            # Get current application for validation
            current_application = applications[application_id]
            current_status = current_application.get("status", "submitted")
            
            # Validate allowed update fields
            allowed_update_fields = ["status", "ai_screening_score", "final_decision", "recruiter_approval", "hiring_manager_approval"]
            invalid_fields = [field for field in application_data.keys() if field not in allowed_update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for application update: {', '.join(invalid_fields)}"
                })
            
            # Validate status transitions if status is being updated
            if "status" in application_data:
                new_status = application_data["status"]
                valid_statuses = ["submitted", "under_review", "screening", "interviewing", "offer_made", "accepted", "rejected", "withdrawn"]
                
                if new_status not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid status. Must be one of: {', '.join(valid_statuses)}"
                    })
                
                # # Validate status transitions follow proper workflow
                # if not is_valid_status_transition(current_status, new_status):
                #     return json.dumps({
                #         "success": False,
                #         "error": "Halt: Invalid application status change"
                #     })
            
            # Validate AI screening score if provided
            if "ai_screening_score" in application_data:
                score = application_data["ai_screening_score"]
                if score is not None and (not isinstance(score, (int, float)) or score < 0 or score > 100):
                    return json.dumps({
                        "success": False,
                        "error": "Halt: AI screening score must be within 0-100 percentage range"
                    })
            
            # Validate final_decision enum if provided
            if "final_decision" in application_data:
                valid_decisions = ["hire", "reject", "hold"]
                if application_data["final_decision"] not in valid_decisions:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid final_decision. Must be one of: {', '.join(valid_decisions)}"
                    })
            
            # Update application record, ensure status transitions are valid
            updated_application = current_application.copy()
            for key, value in application_data.items():
                if key not in ["recruiter_approval", "hiring_manager_approval"]:  # Skip approval from being stored
                    updated_application[key] = value
            
            updated_application["updated_at"] = "2025-10-01T12:00:00"
            applications[application_id] = updated_application
            
            return json.dumps({
                "success": True,
                "action": "update",
                "application_id": application_id,
                "message": f"Job application {application_id} updated successfully",
                "application_data": updated_application
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_job_application",
                "description": "Create or update job application records in the HR recruitment system. This tool manages job applications with comprehensive validation and workflow controls. For creation, establishes new applications with proper validation of candidate/position/recruiter existence and application date requirements. For updates (stage management), modifies application status while enforcing linear workflow progression and requiring proper authorization. Validates status transitions follow proper workflow (submitted → under_review → screening → interviewing → offer_made → accepted), prevents backward movement and terminal state transitions, validates AI screening scores, and ensures recruiter role verification. Essential for recruitment workflow management, candidate tracking, and maintaining accurate application records.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new application, 'update' to manage application stage",
                            "enum": ["create", "update"]
                        },
                        "application_data": {
                            "type": "object",
                            "description": "Application data object. For create: requires candidate_id, position_id, application_date, recruiter_id. Optional: ai_screening_score, final_decision, status. For update: requires recruiter_approval or hiring_manager_approval plus fields to change. SYNTAX: {\"key\": \"value\"}",
                            "properties": {
                                "candidate_id": {
                                    "type": "string",
                                    "description": "Candidate identifier (required for create, must exist in system)"
                                },
                                "position_id": {
                                    "type": "string",
                                    "description": "Job position identifier (required for create, must exist in system)"
                                },
                                "application_date": {
                                    "type": "string",
                                    "description": "Application date in YYYY-MM-DD format (required for create, cannot be in future)"
                                },
                                "recruiter_id": {
                                    "type": "string",
                                    "description": "Assigned recruiter identifier (required for create, must exist and have recruiter role)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Application status (defaults to 'submitted', must follow linear workflow progression)",
                                    "enum": ["submitted", "under_review", "screening", "interviewing", "offer_made", "accepted", "rejected", "withdrawn"]
                                },
                                "ai_screening_score": {
                                    "type": "number",
                                    "description": "AI screening score percentage (0-100 range)"
                                },
                                "final_decision": {
                                    "type": "string",
                                    "description": "Final hiring decision",
                                    "enum": ["hire", "reject", "hold"]
                                },
                                "recruiter_approval": {
                                    "type": "boolean",
                                    "description": "Recruiter approval status (True/False, required for updates)"
                                },
                                "hiring_manager_approval": {
                                    "type": "boolean",
                                    "description": "Hiring Manager approval status (True/False, required for updates)"
                                }
                            }
                        },
                        "application_id": {
                            "type": "string",
                            "description": "Unique identifier of the job application (required for update action only)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }

# Policy:
HR Payroll Policy & SOPs
Introduction
This document defines the operational guide for an HR Payroll automation agent. It is designed for single-turn execution: each procedure must be self-contained and completed in one interaction.
Validation first: All inputs must be validated. If any required element is missing or invalid, the process halts with a clear error message.
Halt conditions: If approvals are missing, compliance not satisfied, or external systems fail, the process halts with explicit instructions.
Logging: All steps must be logged. Every create, update, approve, reject, delete, or execute action must generate an audit log entry.
Role-based permissions: Only the defined roles can perform specified actions.
The elevated roles are: HR director, payroll_administrator, finance_officer, it_administrator, compliance_officer
Roles & Responsibilities
HR Director
Approve HR policies and major structural changes (departments, job levels).
Own role definitions and segregation of duties.
Escalation owner for compliance-critical HR actions.
Create and update department records
Create and update benefits plans
Create job positions
Post and close job openings
HR Manager
Oversee daily HR operations across recruitment, onboarding, leave, and employee records.
Ensure SOP adherence and timely approvals where required.
Process employee onboarding
Process employee offboarding and terminations
Manage performance review cycles
Update employee profiles
Create and manage training programs
Process leave requests
Create and update department records
Create job positions
Manage skills managements and job position skill requirements
Post and close job openings
Hiring Manager
Raise requisitions, participate in interviews, provide hiring decisions.
Cannot access payroll or benefits data unless explicitly granted.
Participate in interview scheduling and outcome recording
Manage application stage transitions per workflow
Create job positions
Associate skills with job positions
Post and close job openings
Schedule interviews and record outcomes
Can approve timesheet entries
Recruiter
Manage candidates and applications, schedule interviews, record outcomes.
Cannot approve compensation, payroll, or benefits.
Create and manage candidate records
Create job applications and manage application stages
Schedule interviews and record interview outcomes
Manage application stage transitions per workflow
Add candidate records to the system
Create job positions
Post and close job openings
Payroll Administrator
Create, update, and process payroll records, bonuses, and deductions.
Cannot approve their own payroll runs.
Submit and manage timesheet entries
Process payroll runs and calculations
Process payroll corrections
Aggregate hours and compute gross pay, deductions, and net pay
Process timesheet submissions and corrections
Finance Officer
Validate payroll accuracy and statutory deductions; approve or reject payroll runs.
Reconcile payroll with finance ledgers; authorize reimbursements and payouts.
Process expense reimbursements
Validate payroll calculations and reconciliation
Create and update benefits plans
Update expense reimbursement records
Compliance Officer
Approve or reject compliance-sensitive actions (tax filings, terminations, incidents).
Halt operations if legal or regulatory violations are detected.
IT / System Administrator
Configure RBAC, MFA, encryption; manage backups and audit logs.
Provision/deprovision system access promptly upon status change.
Employee
Provide accurate personal information; submit timesheets promptly.
Acknowledge policies and participate in reviews and training as required.
Submit timesheet entries with accurate work dates and hours
Enroll in and complete training programs
Submit leave requests with proper documentation
Participate in performance review cycles
Submit expense reimbursement requests
Upload and manage personal documents
Standard Operating Procedures
User Provisioning
Input Validation
Validate that email is present, follows valid email format, and is unique in the system using discover_user_entities
Validate that role is one of the supported system roles (HR Director, HR Manager, Recruiter, Payroll Administrator, Hiring Manager, Finance Officer, IT Administrator, Compliance Officer, Employee)
Validate that first name and last name are provided and non-empty
Check that user with this email does not already exist in the system using discover_user_entities
Authorization Check
Check if HR Director or IT Administrator approval is required for elevated roles (administrative and financial access roles) using check_approval
If approval is missing for elevated roles, then output 'Halt: Approval missing for elevated role assignment'
Record Creation
Create new user with required information: first name, last name, email, role using manage_user
Set optional information if provided: phone number
Set system defaults: active status, multi-factor authentication enabled
Generate unique user identifier
Audit Logging
Log the user provisioning action as a creation event in the audit trail using manage_audit_logs
Create/Update Department
Input Validation
For creation:
Validate that department name is provided and non-empty
Validate that assigned manager exists in the employee system and has active status using discover_employee_entities
Validate that budget amount follows proper decimal format if provided
For updates: Validate that department exists and has active status using discover_department_entities
Authorization Check
Check that HR Director approval is obtained for department creation, updates, or manager changes using check_approval
If approval is missing, then output 'Halt: Approval missing for department operation'
Record Management
For creation:
Create department with required information: department name, assigned manager using manage_department
Set optional information if provided: budget allocation
Set system defaults: active status
For updates: Update specified information while maintaining organizational integrity using manage_department
Audit Logging
Log the department action as creation or update event in the audit trail using manage_audit_logs
Create/Update Job Position
Input Validation
For creation:
Validate that position title and department assignment are provided
Validate that assigned department exists and has active status using discover_department_entities
Validate that employment type is within supported categories (full-time, part-time, contract, intern, temporary)
Validate that minimum hourly rate does not exceed maximum rate if both provided
Validate that salary rates are positive monetary values
For updates: Validate that position exists in the system using discover_job_entities
Authorization Check
Check that HR Director or Hiring Manager approval is obtained for positions using check_approval
If approval is missing, then output 'Halt: Approval missing for publishable position'
Post Job Opening
Input Validation
Validate that position exists and currently has draft status using discover_job_entities
Validate that position contains all required information for publication
Status Update
Change job position status from draft to open for public visibility using manage_job_position
Update modification timestamp
Audit Logging
Log the job posting action as an update event in the audit trail using manage_audit_logs
Skills Management
Validate that the skill name is provided and valid. If skill name is missing or invalid, then output 'Halt: Invalid skill details: [list]'
Check that HR Director approval is obtained for skills catalog operations using check_approval. If approval is missing, then output 'Halt: Approval missing for skills operation'
For creation, check that skill name does not already exist using discover_job_entities. If duplicate exists, then output 'Halt: Skill name already exists'
Create or update the skill record with the status provided (active/inactive) using manage_skill
Log the skills catalog action in the audit log using manage_audit_logs
Job Position Skills Management
Validate that the position ID is valid and skill IDs are provided using discover_job_entities. If position ID is invalid or skill IDs missing, then output 'Halt: Invalid position skills details: [list]'
Check that HR Director or Hiring Manager approval is obtained for position skills changes using check_approval. If approval is missing, then output 'Halt: Approval missing for position skills operation'
Verify that the job position exists and all specified skills exist in the skills catalog using discover_job_entities
For adding skills, check that skills are not already associated with the position. For removing skills, check that skills are currently associated
Add or remove skill associations for the job position using manage_job_position_skills
Log the position skills management action in the audit log using manage_audit_logs
Close Job Opening
Input Validation
Validate that position exists and currently has open status using discover_job_entities
Status Update
Change job position status from open to closed using manage_job_position
Audit Logging
Log the job closing event as an update event in the audit trail using manage_audit_logs
Adding Candidate Record
Input Validation
Validate that first name, last name, and email are provided and non-empty
Validate that email is unique in the system using discover_recruitment_entities
Validate that source is within accepted recruitment channels (job board, referral, company website, recruiter, social media, career fair)
Record Creation
Create candidate with required information: first name, last name, email, recruitment source using manage_candidate
Set optional information if provided: phone number, address
Set the status of the candidate as new if the status is not specified. The allowed statuses are: 'new', 'screening','interviewing','offer','hired','rejected','withdrawn'
Audit Logging
Log the candidate creation as a creation event in the audit trail using manage_audit_logs
Create/Update Job Application
Input Validation
For creation:
Validate that candidate and position exist and are valid using discover_recruitment_entities and discover_job_entities
Validate that assigned recruiter exists and has recruiter role using discover_user_entities
Validate that application date is provided and not in future
For updates:
Validate that application exists using discover_recruitment_entities
Validate status transitions follow proper workflow. Applications follow a linear progression: submitted → under_review → screening (with AI scoring) → interviewing → offer_made → accepted. Applications can exit to 'rejected' or 'withdrawn' from any active stage but cannot move backward, transition from terminal states (accepted, rejected, withdrawn), or skip intermediate steps.
Record Management
For creation:
Create application with required information: candidate, position, application date, assigned recruiter using manage_job_applications
Set status of the application as submitted unless the state is specified. The allowed states are: 'submitted','under_review','screening','interviewing','offer_made','accepted','rejected','withdrawn'
For updates:
Update specified information, ensure status transitions are valid using manage_job_applications
Optional information that are not required to create the job application but preferred: AI screening score (percentage), final hiring decision, current status
Audit Logging
Log the application action as creation or update event in the audit trail using manage_audit_logs
Manage Application Stage
Input Validation
Validate that the application exists, and the stage transition is valid using discover_recruitment_entities. If application is not found or stage transition is invalid, then output 'Halt: Invalid application status change'
Validate that AI screening score is within acceptable percentage range (0-100) if provided
Validate that final decision is within accepted options (hire, reject, hold) if provided
Authorization Check
Check that Recruiter or Hiring Manager approval is obtained using check_approval
Record Update
Update job application status and AI screening score if provided using manage_job_applications
Set final hiring decision (hire, reject, hold) if provided
Audit Logging
Log the stage change as an update event in the audit trail using manage_audit_logs
Schedule Interview
Input Validation
Validate that the application and interviewer exist using discover_recruitment_entities and discover_user_entities. If application or interviewer is missing → output 'Halt: Invalid interview scheduling details'
Validate that interview type is within accepted categories (phone screening, technical, behavioral, panel, final)
Validate that scheduled date and time is in the future
Validate that duration is a positive time value with reasonable default
Record Creation
Create interview with required information: application, interviewer, interview type, scheduled date and time using manage_interviews
Set optional information if provided: duration
Set system defaults: scheduled status, standard duration
Generate unique interview identifier
Audit Logging
Log the interview scheduling as a creation event in the audit trail using manage_audit_logs
Record Interview Outcome
Input Validation
Validate that interview exists and has scheduled or completed status using discover_recruitment_entities
Validate that overall rating is within accepted scale (excellent through poor)
Validate that individual scores are within acceptable numeric range if provided (technical, communication, cultural fit)
Validate that recommendation is within accepted options (strong hire, hire, no hire, strong no hire)
Record Update
Update interview with outcome information: overall rating, individual scores, recommendation using manage_interviews
Change status to completed
Update related job application status based on interview outcome using manage_job_applications. The update for job application is as follows: positive recommendations ('strong_hire' or 'hire') advance 'interviewing' status to 'offer_made', while negative recommendations ('no_hire' or 'strong_no_hire') immediately set status to 'rejected'. When no recommendation is provided, applications with 'excellent' or 'good' ratings remain at 'interviewing' for potential additional interviews, while 'poor' or 'below_average' ratings trigger 'rejected' status. Final interviews with positive recommendations automatically advance to 'offer_made'.
Audit Logging
Log the interview outcome as an update event in the audit trail using manage_audit_logs
Employee Onboarding
Input Validation
Validate that all required information is provided: user account, position assignment, hire date
Validate that user account exists and is not already associated with an employee record using discover_user_entities and discover_employee_entities
Validate that assigned position exists and has active status using discover_job_entities
Validate that hire date is not in the past
Validate that hourly rate is positive monetary value, if provided
Validate optional information if provided: manager assignment (must exist in employee system using discover_employee_entities), date of birth, address
Authorization Check
Check that HR Manager approval is obtained and Compliance verification for eligibility documents is completed using check_approval
If approvals are missing, then output 'Halt: Approval or compliance verification missing'
Record Creation
Create employee record with required information: user account, position, hire date using manage_employee
Set optional information if provided: manager assignment, personal details, compensation rate
Set system defaults: active employment status
Update user account to active status using manage_user
Document Generation
Generate and store welcome documents in the document management system using manage_document_storage
Audit Logging
Log all onboarding actions as creation events in the audit trail using manage_audit_logs
Update Employee Profile
Input Validation
Validate that employee exists and has active status using discover_employee_entities
Validate that employment status is within accepted values (active, terminated, on leave, suspended)
Validate that hourly rate is positive monetary value if provided
Record Update
Update employee record information using manage_employee
Track before and after values for audit purposes
Audit Logging
Log before and after values as update events in the audit trail using manage_audit_logs
Employee Offboarding
Input Validation
Validate that employee exists and has active employment status using discover_employee_entities
Check for pending payroll records that have not been finalized using discover_payroll_entities
Check for active benefits enrollments using discover_benefits_entities
Check for incomplete training programs using discover_training_entities
Authorization Check
Check that HR Manager and Compliance Officer approvals are obtained using check_approval
If approvals are missing, then output 'Halt: Required approvals missing'
Record Updates
Set employee employment status to terminated using manage_employee
Update user account status to inactive using manage_user
Terminate active benefits enrollments using manage_employee_benefits
Cancel incomplete training enrollments using manage_employee_training
Audit Logging
Log all offboarding steps as update events in the audit trail using manage_audit_logs
Timesheet Submission
Input Validation
Validate that employee exists and has active status using discover_employee_entities
Validate that work date is provided and not in future
Validate that clock in and clock out times are provided and logical (clock in occurs before clock out)
Validate that break duration is non-negative time value with reasonable default
Record Creation
Create timesheet with required information: employee, work date, clock in time, clock out time using manage_timesheet_entries
Calculate total hours worked based on time difference minus break duration
Set optional information if provided: break duration, project assignment
Set system defaults: submitted status, zero break time
Audit Logging
Log the timesheet submission as a creation event in the audit trail using manage_audit_logs
Timesheet Approval/Correction
Input Validation
Validate that timesheet exists in the system using discover_timesheet_entities
Validate that approver has payroll administrator or hiring manager role using discover_user_entities
Validate status transitions follow proper workflow (draft or submitted to approved or rejected)
Authorization Check
Verify approver is authorized manager (Payroll Administrator or Hiring Manager) using check_approval
If unauthorized, then output 'Halt: Unauthorized access'
Record Update
Update timesheet with approver information and change status to approved or rejected using manage_timesheet_entries
Adjust time information if correction requested (total hours, break duration)
Audit Logging
Log approval and corrections as update events in the audit trail using manage_audit_logs
Process Payroll Run
Input Validation
Validate that all required information is provided: employee, pay period dates
Validate that pay period dates are logical (start date before end date)
Validate that hourly rate is positive monetary value
Aggregate approved timesheet hours for the specified pay period using discover_timesheet_entities
Authorization Check
Check that Finance Officer approval is obtained using check_approval
If approval is missing, then output 'Halt: Finance Officer approval required'
Record Creation/Update
Create payroll record with required information: employee, pay period dates, hourly rate using manage_payroll_records
Calculate hours worked from approved timesheets
Audit Logging
Log all payroll transactions as creation events in the audit trail using manage_audit_logs
Payroll Correction
Input Validation
Validate that payroll record exists in the system using discover_payroll_entities
Validate that correction information is valid (hours worked and hourly rate must be positive)
Authorization Check
Check that Finance Officer approval is obtained using check_approval
If approval is missing, then output 'Halt: Finance Officer approval required'
Record Update
Adjust payroll record with correction details using manage_payroll_records
Update modification timestamp
Audit Logging
Log the payroll correction as an update event in the audit trail using manage_audit_logs
Create/Update Benefits Plan
Input Validation
For creation:
Validate that plan name and plan type are provided
Validate that plan type is within supported categories (health insurance, dental, vision, life insurance, disability, retirement, paid time off, flexible spending)
Validate that effective date is provided and expiration date occurs after effective date if provided
Validate that cost amounts are non-negative monetary values if provided
For updates: Validate that plan exists in the system using discover_benefits_entities
Authorization Check
Check that HR Director or Finance Officer approval is obtained using check_approval
If approval is missing, then output 'Halt: HR Director or Finance Officer approval required'
Record Management
For creation: Create plan with required information: plan name, plan type, effective date using manage_benefits_plans
Set optional information if provided: provider, employee cost, employer cost, expiration date
Set system defaults: active status
For updates: Update specified information while maintaining date consistency using manage_benefits_plans
Audit Logging
Log the benefits plan action as creation or update event in the audit trail using manage_audit_logs
Employee Benefits Enrollment & Update
Input Validation
For enrollment: Validate that employee and benefits plan exist and have active status using discover_employee_entities and discover_benefits_entities
Validate that enrollment date is provided and not in future
Validate that coverage level is within accepted options (employee only, employee plus spouse, employee plus children, family coverage)
Check that employee is not already enrolled in the same plan type using discover_benefits_entities
For updates: Validate that enrollment record exists using discover_benefits_entities
Record Management
For enrollment: Create benefits enrollment with required information: employee, plan, enrollment date, coverage level using manage_employee_benefits
Set optional information if provided: beneficiary name and relationship
Set system defaults: active enrollment status
For updates: Update specified information, validate status transitions using manage_employee_benefits
Audit Logging
Log the benefits enrollment change as creation or update event in the audit trail using manage_audit_logs
Performance Review Cycle
Input Validation
Validate that employee and reviewer exist and have active status using discover_employee_entities
Validate that review period dates are logical (start date before end date)
Validate that review type is within accepted categories (annual, quarterly, probationary, project-based)
Authorization Check
Check that HR Manager approval is obtained for final approval using check_approval
If approval is missing, then output 'Halt: HR Manager approval required'
Record Management
Create performance review with required information: employee, reviewer, review period dates, review type, overall rating using manage_performance_reviews
Set optional score information if provided for various competency areas
Update status through proper progression (draft to submitted to approved)
Audit Logging
Log all status transitions as creation or update events in the audit trail using manage_audit_logs
Creating Training Program
Validate that all program fields are provided and valid. If program fields are missing or invalid, then output 'Halt: Invalid training program details'
Create or update training programs with mandatory flag if the training is required and set status to 'active' using manage_training_programs
Log the training program action in the audit trail using manage_audit_logs
Employee Training Enrollment & Completion
Validate that the employee and training program are valid using discover_employee_entities and discover_training_entities. If employee or program is invalid, then output 'Halt: Invalid training enrollment'
Create or update employee training record with status progression (enrolled → completed) and set expiry date if applicable using manage_employee_training
Log the training enrollment and completion in the audit trail using manage_audit_logs
Document Upload & Management
Validate that the document type is supported and all required metadata is provided. If document type is unsupported or metadata is missing, then output 'Halt: Invalid document metadata: [list]'
Insert document into document storage system with confidentiality level and retention period in years, and store file pointer using manage_document_storage
Log the document creation in the audit trail using manage_audit_logs
Audit Trail Logging (Global)
Input Validation
Validate that all required information is provided: user, action type, reference type, reference identifier
Validate that user exists in the system using discover_user_entities
Validate that action type is within accepted values (create, read, update, delete, approve, reject)
For field-level changes, validate that field name, old value, and new value are provided
Record Creation
Create audit log entry with all provided information using manage_audit_logs
Set timestamp to current system time
For record-level operations (create or delete), set field-level change information to null
Error Handling
If audit log write fails, then output 'Halt: Audit trail failure'
Leave Request Processing
Input Validation
Validate that employee exists and has active status using discover_employee_entities
Validate that leave type is within accepted categories (annual, sick, family medical leave, personal, bereavement, jury duty)
Validate that start and end dates are provided and logical (start date on or before end date, not in past)
Calculate requested days from date range
Record Creation
Create leave request with required information: employee, leave type, start date, end date, requested days using manage_leave_requests
Calculate and set remaining balance after this request
Set the approval status as pending unless logging a leave request that has many changes incurred to it.
Audit Logging
Log the leave request submission as a creation event in the audit trail using manage_audit_logs
Create/Update Expense Reimbursement
Input Validation
For creation:
Validate that employee, expense date, amount, and expense type are provided
Validate that employee exists and has active status using discover_employee_entities
Validate that expense type is within accepted categories (travel, meals, equipment, training, other)
Validate that amount is positive monetary value
Validate that expense date is not in future
For updates: Validate that reimbursement record exists and has submitted status using discover_expense_entities
Record Management
For creation: Create reimbursement with required information: employee, expense date, amount, expense type using manage_expense_reimbursements
For updates: Update specified information (amount, receipt location) only if status allows modification using manage_expense_reimbursements
Audit Logging
Log the reimbursement action as creation or update event in the audit trail using manage_audit_logs
Process Expense Reimbursement
Input Validation
Validate that reimbursement record exists in the system using discover_expense_entities
Validate that approving user exists and has appropriate role using discover_user_entities
Validate that status is within accepted values (approved, rejected, paid)
Validate status transitions follow proper workflow (submitted to approved or rejected, approved to paid)
Record Update
Update reimbursement status to specified value using manage_expense_reimbursements
Set approver information to approving user if status is approved
Set payment date if status is paid and payment date is provided
Audit Logging
Log the reimbursement processing as an update event in the audit trail using manage_audit_logs
Payroll Deductions Management
Input Validation
Validate that payroll record exists in the system using discover_payroll_entities
Validate that deduction type is within accepted categories (tax, insurance, retirement, garnishment, equipment, other)
Validate that deduction amount is positive monetary value
Validate that creator exists in the user system using discover_user_entities
Record Creation
Create deduction with required information: payroll record, deduction type, amount, creator using manage_payroll_deductions
Generate unique deduction identifier
Audit Logging
Log the deduction creation as a creation event in the audit trail using manage_audit_logs



# Database Schema:
// Use DBML to define your database structure
// HR Management System Database Schema
// This schema represents a comprehensive database for managing human resources operations,
// including recruitment, payroll, employee management, compliance, and AI/LLM governance

Table users {
  user_id string [primary key]
  first_name varchar(100) [not null]
  last_name varchar(100) [not null]
  email varchar(320) [not null, unique]
  phone_number varchar(20)
  role enum('hr_director','hr_manager','recruiter','payroll_administrator','hiring_manager','finance_officer','it_administrator','compliance_officer','employee') [not null]
  status enum('active','inactive','suspended') [not null, default: 'active']
  // last_login timestamp
  mfa_enabled boolean [default: true]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table departments {
  department_id string [primary key]
  department_name varchar(255) [not null]
  manager_id string [not null]
  budget decimal(15,2)
  status enum('active','inactive') [not null, default: 'active']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table job_positions {
  position_id string [primary key]
  title varchar(255) [not null]
  department_id string [not null]
  job_level enum('entry','junior','mid','senior','lead','manager','director','executive') [not null]
  employment_type enum('full_time','part_time','contract','intern','temporary') [not null]
  hourly_rate_min  decimal(12,2)
  hourly_rate_max  decimal(12,2)
  // required_skills text
  status enum('open','closed','draft') [not null]
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table skills {
  skill_id string [primary key]
  skill_name text [not null]
  status enum('active','inactive') [default: 'active']
}

Table job_position_skills {
  position_id string [not null]
  skill_id string [not null]
  primary key (position_id, skill_id)
}

Ref: job_position_skills.position_id > job_positions.position_id
Ref: job_position_skills.skill_id > skills.skill_id


Table employees {
  employee_id string [primary key]
  user_id string [not null, unique]
  position_id string [not null]
  hire_date date [not null]
  employment_status enum('active','terminated','on_leave','suspended') [not null, default: 'active']
  manager_id string
  date_of_birth date
  address text
  hourly_rate int
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table candidates {
  candidate_id string [primary key]
  first_name varchar(100) [not null]
  last_name varchar(100) [not null]
  email varchar(320) [not null]
  phone_number varchar(20)
  address text
  // resume_file_path varchar(500)
  // linkedin_profile varchar(500)
  source enum('job_board','referral','company_website','recruiter','social_media','career_fair') [not null]
  status enum('new','screening','interviewing','offer','hired','rejected','withdrawn') [not null, default: 'new']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table job_applications {
  application_id string [primary key]
  candidate_id string [not null]
  position_id string [not null]
  application_date date [not null]
  status enum('submitted','under_review','screening','interviewing','offer_made','accepted','rejected','withdrawn') [not null, default: 'submitted']
  recruiter_id string [not null]
  // cover_letter text
  ai_screening_score decimal(5,2)
  // ai_recommendations text
  final_decision enum('hire','reject','hold') 
  // decision_reason text
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table interviews {
  interview_id string [primary key]
  application_id string [not null]
  interviewer_id string [not null]
  interview_type enum('phone_screening','technical','behavioral','panel','final') [not null]
  scheduled_date timestamp [not null]
  duration_minutes integer [default: 60]
  status enum('scheduled','completed','cancelled','no_show') [not null, default: 'scheduled']
  overall_rating enum('excellent','good','average','below_average','poor')
  technical_score decimal(3,1)
  communication_score decimal(3,1)
  cultural_fit_score decimal(3,1)
  // notes text
  recommendation enum('strong_hire','hire','no_hire','strong_no_hire')
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table payroll_records {
  payroll_id string [primary key]
  employee_id string [not null]
  pay_period_start date [not null]
  pay_period_end date [not null]
  hours_worked decimal(6,2)
  // overtime_hours decimal(6,2)
  hourly_rate decimal(12,2) [not null]
  // overtime_pay decimal(12,2)
  // bonus decimal(12,2)
  // gross_pay decimal(12,2) [not null]
  // total_deductions decimal(12,2) [not null]   // 👈 single field
  // net_pay decimal(12,2) [not null]
  payment_date date
  status enum('draft','approved','paid','cancelled') [not null, default: 'draft']
  approved_by string
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table payroll_deductions {
  deduction_id string [primary key]
  payroll_id string [not null]
  deduction_type enum('tax','insurance','retirement','garnishment','equipment','other') [not null]
  // description varchar(255) [not null]
  amount decimal(10,2) [not null]
  // is_pre_tax boolean [default: false]
  created_by string [not null]
  created_at timestamp [not null, default: `NOW()`]
}

Table benefits_plans {
  plan_id string [primary key]
  plan_name varchar(255) [not null]
  plan_type enum('health_insurance','dental','vision','life_insurance','disability','retirement_401k','pto','flexible_spending') [not null]
  provider varchar(255)
  // description text
  employee_cost decimal(10,2)
  employer_cost decimal(10,2)
  status enum('active','inactive') [not null, default: 'active']
  effective_date date [not null]
  expiration_date date
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table employee_benefits {
  enrollment_id string [primary key]
  employee_id string [not null]
  plan_id string [not null]
  enrollment_date date [not null]
  status enum('active','terminated','pending') [not null, default: 'active']
  // employee_contribution decimal(10,2)
  coverage_level enum('employee_only','employee_spouse','employee_children','family') [not null]
  beneficiary_name varchar(255)
  beneficiary_relationship varchar(100)
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table performance_reviews {
  review_id string [primary key]
  employee_id string [not null]
  reviewer_id string [not null]
  review_period_start date [not null]
  review_period_end date [not null]
  review_type enum('annual','quarterly','probationary','project_based') [not null]
  overall_rating enum('exceeds_expectations','meets_expectations','below_expectations','unsatisfactory') [not null]
  goals_achievement_score decimal(3,1)
  communication_score decimal(3,1)
  teamwork_score decimal(3,1)
  leadership_score decimal(3,1)
  technical_skills_score decimal(3,1)
  // comments text
  // development_goals text
  status enum('draft','submitted','approved') [not null, default: 'draft']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

// Table leave_requests {
//   leave_id string [primary key]
//   employee_id string [not null]
//   leave_type enum('annual','sick','fmla','personal','bereavement','jury_duty') [not null]
//   start_date date [not null]
//   end_date date [not null]
//   days_requested decimal(3,1) [not null]
//   // reason text
//   status enum('pending','approved','rejected','cancelled') [not null, default: 'pending']
//   processed_by string
//   processing_date timestamp
//   remaining_balance decimal(5,1)
//   created_at timestamp [not null, default: `NOW()`]
//   updated_at timestamp [not null, default: `NOW()`]
// }

Table leave_requests {
  leave_id string [primary key]
  employee_id string [not null]
  leave_type enum('annual','sick','fmla','personal','bereavement','jury_duty') [not null]
  start_date date [not null]
  end_date date [not null]
  days_requested decimal(3,1) [not null]
  status enum('pending','approved','rejected','cancelled') [not null, default: 'pending']
  approved_by string
  approval_date timestamp
  remaining_balance decimal(5,1) // filled after approval
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}



Table expense_reimbursements {
  reimbursement_id string [primary key]
  employee_id string [not null]
  expense_date date [not null]
  amount decimal(10,2) [not null]
  expense_type enum('travel','meals','equipment','training','other') [not null]
  // description text [not null]
  receipt_file_path varchar(500)
  status enum('submitted','approved','rejected','paid') [not null, default: 'submitted']
  approved_by string
  payment_date date
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table training_programs {
  program_id string [primary key]
  program_name varchar(255) [not null]
  program_type enum('onboarding','compliance','technical','leadership','safety','diversity','ai_ethics') [not null]
  // description text
  duration_hours integer [not null]
  delivery_method enum('in_person','online','hybrid','self_paced') [not null]
  mandatory boolean [default: false]
  status enum('active','inactive','draft') [not null, default: 'active']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table employee_training {
  training_record_id string [primary key]
  employee_id string [not null]
  program_id string [not null]
  enrollment_date date [not null]
  completion_date date
  status enum('enrolled','in_progress','completed','failed','cancelled') [not null, default: 'enrolled']
  score decimal(5,2)
  certificate_issued boolean [default: false]
  expiry_date date
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

Table audit_logs {
  log_id string [primary key]
  user_id string [not null]
  action enum('create','read','update','delete','approve','reject') [not null]
  reference_type string [not null]
  reference_id string [not null]
  field_name varchar(100)
  old_value text
  new_value text
  timestamp timestamp [not null, default: `NOW()`]
}


// Table compliance_records {
//   compliance_id string [primary key]
//   record_type enum('eeoc_report','flsa_audit','ada_accommodation','fmla_leave','safety_incident','data_breach','ai_bias_test') [not null]
//   employee_id string
//   // description text [not null]
//   compliance_officer_id string [not null]
//   status enum('open','under_review','resolved','escalated') [not null, default: 'open']
//   severity enum('low','medium','high','critical') [not null]
//   due_date date
//   // resolution_notes text
//   created_at timestamp [not null, default: `NOW()`]
//   updated_at timestamp [not null, default: `NOW()`]
// }


Table document_storage {
  document_id string [primary key]
  document_name varchar(255) [not null]
  document_type enum('contract','policy','handbook','form','certificate','report','resume','offer_letter') [not null]
  employee_id string
  file_path varchar(500) [not null]
  // file_size_bytes bigint
  upload_date timestamp [not null]
  uploaded_by string [not null]
  confidentiality_level enum('public','internal','confidential','restricted') [not null, default: 'internal']
  retention_period_years integer [not null, default: 7]
  expiry_date date
  status enum('active','archived','deleted') [not null, default: 'active']
  created_at timestamp [not null, default: `NOW()`]
}

// RELATIONSHIPS

// User and Employee relationships
Ref: employees.user_id > users.user_id
Ref: employees.manager_id > employees.employee_id
Ref: employees.position_id > job_positions.position_id

// Department relationships
Ref: departments.manager_id > employees.employee_id
Ref: job_positions.department_id > departments.department_id

// Application and Interview relationships
Ref: job_applications.candidate_id > candidates.candidate_id
Ref: job_applications.position_id > job_positions.position_id
Ref: job_applications.recruiter_id > users.user_id
Ref: interviews.application_id > job_applications.application_id
Ref: interviews.interviewer_id > users.user_id

// Payroll relationships
Ref: payroll_records.employee_id > employees.employee_id
Ref: payroll_records.approved_by > users.user_id

// Benefits relationships
Ref: employee_benefits.employee_id > employees.employee_id
Ref: employee_benefits.plan_id > benefits_plans.plan_id

// Performance and Training relationships
Ref: performance_reviews.employee_id > employees.employee_id
Ref: performance_reviews.reviewer_id > users.user_id
Ref: employee_training.employee_id > employees.employee_id
Ref: employee_training.program_id > training_programs.program_id

Ref: audit_logs.user_id > users.user_id


// Compliance and Incident relationships
// Ref: compliance_records.employee_id > employees.employee_id
// Ref: compliance_records.compliance_officer_id > users.user_id

// Document relationships
Ref: document_storage.employee_id > employees.employee_id
Ref: document_storage.uploaded_by > users.user_id

Table employee_timesheets {
  timesheet_id string [primary key]
  employee_id string [not null]
  work_date date [not null]
  clock_in_time timestamp
  clock_out_time timestamp
  break_duration_minutes integer [default: 0]
  total_hours decimal(4,2)
  // overtime_hours decimal(4,2) [default: 0]
  project_code varchar(50)
  // notes text
  approved_by string
  status enum('draft','submitted','approved','rejected') [not null, default: 'draft']
  created_at timestamp [not null, default: `NOW()`]
  updated_at timestamp [not null, default: `NOW()`]
}

// Additional relationships for new tables
Ref: employee_timesheets.employee_id > employees.employee_id
Ref: employee_timesheets.approved_by > users.user_id

Ref: payroll_deductions.payroll_id > payroll_records.payroll_id
Ref: payroll_deductions.created_by > users.user_id

Ref: leave_requests.employee_id > employees.employee_id
Ref: leave_requests.approved_by > users.user_id

Ref: expense_reimbursements.employee_id > employees.employee_id
Ref: expense_reimbursements.approved_by > users.user_id


You have to provide the json file for each function separately including all the tests for that function in the actions part. You are going to provide the bash script that will create and populate those json files in a folder named tools_regression_tests/interface_1/.
